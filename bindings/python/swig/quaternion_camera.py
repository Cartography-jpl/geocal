# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
from ._swig_wrap import _quaternion_camera

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _quaternion_camera.SWIG_PyInstanceMethod_New
_swig_new_static_method = _quaternion_camera.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_MODULE_ALREADY_DONE = _quaternion_camera.SWIG_MODULE_ALREADY_DONE
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _quaternion_camera.delete_SwigPyIterator
    value = _swig_new_instance_method(_quaternion_camera.SwigPyIterator_value)
    incr = _swig_new_instance_method(_quaternion_camera.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_quaternion_camera.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_quaternion_camera.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_quaternion_camera.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_quaternion_camera.SwigPyIterator_copy)
    next = _swig_new_instance_method(_quaternion_camera.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_quaternion_camera.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_quaternion_camera.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_quaternion_camera.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_quaternion_camera.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_quaternion_camera.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_quaternion_camera.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_quaternion_camera.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_quaternion_camera.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_quaternion_camera.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _quaternion_camera:
_quaternion_camera.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _quaternion_camera.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_function.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_function.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.generic_object
import geocal_swig.observer
import geocal_swig.camera
import geocal_swig.with_parameter
class QuaternionCamera(geocal_swig.camera.Camera):
    r"""

    A lot of cameras follow the model of "rotate into the detector space,
    do a nonlinear correction".

    This class supports this by handling the rotation of a ScLookVector
    and conversion to FrameCoordinate (and vice versa). This base class
    doesn't model any nonlinear corrections - we just model a pinhole. But
    derived classes can override the dcs_to_focal_plane and
    focal_plane_to_dcs functions to put in whatever functionality is
    desired.

    There are 2 conventions used for the frame coordinates. The convention
    used by some cameras we have implemented is that the line direction is
    +x, and the sample direction is +y.

    However, another convention is that line goes in the +y direction and
    sample goes in +x direction. This is what was used in the VICAR
    procedure sc2rpc. Note that this is more than just a rotation from the
    other convention, it is both a rotation and a reflection (so the
    chirality is different).

    We support both conventions, depending on the setting of the
    frame_convention.

    In addition to either x or y direction for line, we can have
    increasing line go in the positive direction or negative direction.
    Likewise for sample.

    The conversion goes:

    FrameCoordinate -> focal plane xfp, yfp -> DcsLookVector ->
    ScLookVector

    The focal plane coordinates are on the actual CCD (so offset from an
    origin in mm). The conversion to DcsLookVector capture any non-
    linearity, it gives the look vector in the detector coordinate system
    for the given location on the focal plane. The conversion to
    ScLookVector captures the angle orientation of the camera relative to
    the space craft.

    C++ includes: quaternion_camera.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LINE_IS_X = _quaternion_camera.QuaternionCamera_LINE_IS_X
    LINE_IS_Y = _quaternion_camera.QuaternionCamera_LINE_IS_Y
    INCREASE_IS_POSITIVE = _quaternion_camera.QuaternionCamera_INCREASE_IS_POSITIVE
    INCREASE_IS_NEGATIVE = _quaternion_camera.QuaternionCamera_INCREASE_IS_NEGATIVE
    _v_focal_length = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_focal_length)

    @property
    def focal_length(self):
        return self._v_focal_length()

    @focal_length.setter
    def focal_length(self, value):
      self._v_focal_length(value)

    _v_focal_length_with_derivative = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_focal_length_with_derivative)

    @property
    def focal_length_with_derivative(self):
        return self._v_focal_length_with_derivative()

    @focal_length_with_derivative.setter
    def focal_length_with_derivative(self, value):
      self._v_focal_length_with_derivative(value)

    principal_point = _swig_new_instance_method(_quaternion_camera.QuaternionCamera_principal_point)
    principal_point_with_derivative = _swig_new_instance_method(_quaternion_camera.QuaternionCamera_principal_point_with_derivative)
    _v_line_pitch = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_line_pitch)

    @property
    def line_pitch(self):
        return self._v_line_pitch()

    @line_pitch.setter
    def line_pitch(self, value):
      self._v_line_pitch(value)

    _v_line_pitch_with_derivative = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_line_pitch_with_derivative)

    @property
    def line_pitch_with_derivative(self):
        return self._v_line_pitch_with_derivative()

    @line_pitch_with_derivative.setter
    def line_pitch_with_derivative(self, value):
      self._v_line_pitch_with_derivative(value)

    _v_sample_pitch = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_sample_pitch)

    @property
    def sample_pitch(self):
        return self._v_sample_pitch()

    @sample_pitch.setter
    def sample_pitch(self, value):
      self._v_sample_pitch(value)

    _v_sample_pitch_with_derivative = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_sample_pitch_with_derivative)

    @property
    def sample_pitch_with_derivative(self):
        return self._v_sample_pitch_with_derivative()

    @sample_pitch_with_derivative.setter
    def sample_pitch_with_derivative(self, value):
      self._v_sample_pitch_with_derivative(value)

    _v_frame_convention = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_frame_convention)

    @property
    def frame_convention(self):
        return self._v_frame_convention()

    @frame_convention.setter
    def frame_convention(self, value):
      self._v_frame_convention(value)

    _v_line_direction = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_line_direction)

    @property
    def line_direction(self):
        return self._v_line_direction()

    @line_direction.setter
    def line_direction(self, value):
      self._v_line_direction(value)

    _v_sample_direction = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_sample_direction)

    @property
    def sample_direction(self):
        return self._v_sample_direction()

    @sample_direction.setter
    def sample_direction(self, value):
      self._v_sample_direction(value)

    _v_frame_to_sc = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_frame_to_sc)

    @property
    def frame_to_sc(self):
        return self._v_frame_to_sc()

    @frame_to_sc.setter
    def frame_to_sc(self, value):
      self._v_frame_to_sc(value)

    _v_frame_to_sc_with_derivative = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_frame_to_sc_with_derivative)

    @property
    def frame_to_sc_with_derivative(self):
        return self._v_frame_to_sc_with_derivative()

    @frame_to_sc_with_derivative.setter
    def frame_to_sc_with_derivative(self, value):
      self._v_frame_to_sc_with_derivative(value)

    _v_ypr = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_ypr)

    @property
    def ypr(self):
        return self._v_ypr()

    @ypr.setter
    def ypr(self, value):
      self._v_ypr(value)

    _v_ypr_with_derivative = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_ypr_with_derivative)

    @property
    def ypr_with_derivative(self):
        return self._v_ypr_with_derivative()

    @ypr_with_derivative.setter
    def ypr_with_derivative(self, value):
      self._v_ypr_with_derivative(value)

    _v_euler = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_euler)

    @property
    def euler(self):
        return self._v_euler()

    @euler.setter
    def euler(self, value):
      self._v_euler(value)

    _v_euler_with_derivative = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_euler_with_derivative)

    @property
    def euler_with_derivative(self):
        return self._v_euler_with_derivative()

    @euler_with_derivative.setter
    def euler_with_derivative(self, value):
      self._v_euler_with_derivative(value)

    focal_plane_to_fc = _swig_new_instance_method(_quaternion_camera.QuaternionCamera_focal_plane_to_fc)
    fc_to_focal_plane = _swig_new_instance_method(_quaternion_camera.QuaternionCamera_fc_to_focal_plane)
    sc_look_vector = _swig_new_instance_method(_quaternion_camera.QuaternionCamera_sc_look_vector)
    dcs_look_vector = _swig_new_instance_method(_quaternion_camera.QuaternionCamera_dcs_look_vector)
    _v_fit_epsilon = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_fit_epsilon)

    @property
    def fit_epsilon(self):
        return self._v_fit_epsilon()

    @fit_epsilon.setter
    def fit_epsilon(self, value):
      self._v_fit_epsilon(value)

    _v_fit_beta = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_fit_beta)

    @property
    def fit_beta(self):
        return self._v_fit_beta()

    @fit_beta.setter
    def fit_beta(self, value):
      self._v_fit_beta(value)

    _v_fit_delta = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_fit_delta)

    @property
    def fit_delta(self):
        return self._v_fit_delta()

    @fit_delta.setter
    def fit_delta(self, value):
      self._v_fit_delta(value)

    _v_fit_line_pitch = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_fit_line_pitch)

    @property
    def fit_line_pitch(self):
        return self._v_fit_line_pitch()

    @fit_line_pitch.setter
    def fit_line_pitch(self, value):
      self._v_fit_line_pitch(value)

    _v_fit_sample_pitch = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_fit_sample_pitch)

    @property
    def fit_sample_pitch(self):
        return self._v_fit_sample_pitch()

    @fit_sample_pitch.setter
    def fit_sample_pitch(self, value):
      self._v_fit_sample_pitch(value)

    _v_fit_focal_length = _swig_new_instance_method(_quaternion_camera.QuaternionCamera__v_fit_focal_length)

    @property
    def fit_focal_length(self):
        return self._v_fit_focal_length()

    @fit_focal_length.setter
    def fit_focal_length(self, value):
      self._v_fit_focal_length(value)

    fit_principal_point_line = _swig_new_instance_method(_quaternion_camera.QuaternionCamera_fit_principal_point_line)
    fit_principal_point_sample = _swig_new_instance_method(_quaternion_camera.QuaternionCamera_fit_principal_point_sample)
    dcs_to_focal_plane = _swig_new_instance_method(_quaternion_camera.QuaternionCamera_dcs_to_focal_plane)
    focal_plane_to_dcs = _swig_new_instance_method(_quaternion_camera.QuaternionCamera_focal_plane_to_dcs)

    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)


    def __init__(self, *args):
        r"""

        GeoCal::QuaternionCamera::QuaternionCamera(boost::math::quaternion< double > Frame_to_sc_q, double Number_line,
        double Number_sample, double Line_pitch, double Sample_pitch, double
        Focal_length, const FrameCoordinate &Principal_point, FrameConvention
        Frame_convention=LINE_IS_X, FrameDirection
        Line_direction=INCREASE_IS_POSITIVE, FrameDirection
        Sample_direction=INCREASE_IS_POSITIVE)
        GeoCal::QuaternionCamera::QuaternionCamera
        Create a QuaternionCamera.
        The orientation of the camera to the spacecraft to given by the
        quaternion that takes frame coordinates to spacecraft coordinates. The
        size of the camera and the line pitch, sample pitch, and focal length
        are given. By convention, these are given in mm. Finally the
        Principal_point (coordinates at center) are given. 
        """
        _quaternion_camera.QuaternionCamera_swiginit(self, _quaternion_camera.new_QuaternionCamera(*args))
    __swig_destroy__ = _quaternion_camera.delete_QuaternionCamera

# Register QuaternionCamera in _quaternion_camera:
_quaternion_camera.QuaternionCamera_swigregister(QuaternionCamera)

__all__ = ["QuaternionCamera"]


