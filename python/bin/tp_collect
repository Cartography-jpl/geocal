#! /usr/bin/env python
#
# This collects tie points.

from geocal import *
from multiprocessing import Pool
import logging

version = "February 4, 2013"
usage="""Usage: 
  tp_collect [options] <igc> <output>
  tp_collect --gcp [options] <igc> <reference_image> <output>
  tp_collect -h | --help
  tp_collect -v | --version

This program is used to generate a collection of tie points or ground control
points (tie points with the addition of ground truth).

This creates a sqlite shelve object that holds an array of TiePoints. The
output should be in "file:key" format, e.g., "my_data.db:tp". The input is
the IgcCollection to use, also in the same format (which can be in the same
or a different input file).

If you supply a reference image, this should be a "file:key" object.

Options:
  -h --help         
       Print this message

  --add-tp
       The default behavior is to overwrite whatever "file:key" value is
       specified as the output. You can optionally add the TP/GCPs we 
       generate.

  --avg-level=n
       You can specify an averaging level to use. If supplied, we use
       a pyramid image matching scheme, starting at a resolution of 
       2^avg_level, and proceeding down factors of 2 until we fail image
       matching or get all the way down to full resolution data. Useful
       for difficult to match imagery. [default: 0]

  --base-image-index=n
       The image to consider the base image in matching. [default: 0]

  --gcp
       Create GCPs, which requires the additional arguments of a reference
       image.

  --map-info=f
       Use the supplied map information (either a MapInfo, or a RasterImage 
       with a MapInfo). This is used to project to the surface before matching, 
       useful for matching data that is from different enough angles or 
       resolution that matching the raw images will fail. See also 
       --project-surface that automatically finds the map info to use.

  --max-ground-sigma=d
       How far off the various matched points can miss when intersecting
       on the surface, in meters. This is used to filter out bad tie-points,
       but you want this large enough you aren't filtering out good points.
       [default: 20.0]

  --number-process=n 
       Number of processors to use. [default: 1]

  --number-x=n      
       Number of grid points in the X direction to try for [default: 100]

  --number-y=n      
       Number of grid points in the Y direction to try for [default: 100]

  --min-grid-size=n
       If we have a smaller image, then reduce the number x and y so the
       grid cell we examine isn't smaller than this size [default: 100]
 
  --reference-dem=shelve
       DEM to use with the reference image specified as file:key. 
       If not specified, we use the DEM from the first IGC.

  --project-surface
       This is used to project to the surface before matching, 
       useful for matching data that is from different enough angles or 
       resolution that matching the raw images will fail. We use a geographic
       projection that matches the resolution of the center pixel of the 
       base image. See also --map-info option.

  --use-intersection 
       This only applies to gcps. There is a trade off between getting
       the largest coverage (by taking a union of all the igc on the
       surface} and the strongest points (by looking at places seen by
       all the cameras). You may want to do both - so generate a set
       of GCPs using the largest coverage first and then the
       intersection second.

  --verbose
       Print more information as we run.

  -v --version      
       Print program version
"""

args = docopt_simple(usage, version=version)
if(args.verbose):
    logging.basicConfig(level = logging.INFO)
pool = None
if(args.number_process > 1):
    pool = Pool(args.number_process)

igc = read_shelve(args.igc)
if(args.map_info):
    m = read_shelve(args.map_info)
    if(isinstance(m, MapInfo)):
        mi = m
    else:
        mi = m.map_info
elif(args.project_surface):
    ig_base = igc.image_ground_connection(args.base_image_index)
    mibase = cib01_mapinfo(desired_resolution = ig_base.resolution_meter())
    mi = ig_base.cover(mibase)
else:
    mi = None

if(args.gcp):
    if(args.reference_dem):
        dem = read_shelve(args.reference_dem)
    else:
        dem = igc.dem(0)
    refimg = read_shelve(args.reference_image)
    tpcollect = GcpTiePointCollect(refimg, dem, igc, 
                                   avg_level = args.avg_level,
                                   use_intersection = args.use_intersection)
else:
    tpcollect = TiePointCollect(igc, avg_level = args.avg_level,
                                map_info = mi,
                                base_image_index = args.base_image_index,
                                max_ground_covariance = 
                                args.max_ground_sigma ** 2)
maxnumx = int(igc.image(0).number_line / args.min_grid_size)
maxnumy = int(igc.image(0).number_sample / args.min_grid_size)
numx = min(args.number_x, maxnumx)
numy = min(args.number_y, maxnumy)

tparr = tpcollect.tie_point_grid(numx, numy, pool = pool)

try:
    # Ok if this fails, it just means args.output doesn't exist yet
    if(args.add_tp):
        tparr.extend(read_shelve(args.output))
except KeyError:
    pass

write_shelve(args.output, tparr)


