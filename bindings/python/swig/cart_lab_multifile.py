# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _cart_lab_multifile.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_cart_lab_multifile')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_cart_lab_multifile')
    _cart_lab_multifile = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_cart_lab_multifile', [dirname(__file__)])
        except ImportError:
            import _cart_lab_multifile
            return _cart_lab_multifile
        try:
            _mod = imp.load_module('_cart_lab_multifile', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _cart_lab_multifile = swig_import_helper()
    del swig_import_helper
else:
    import _cart_lab_multifile
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _cart_lab_multifile.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_cart_lab_multifile.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_cart_lab_multifile.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_cart_lab_multifile.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_cart_lab_multifile.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_cart_lab_multifile.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_cart_lab_multifile.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_cart_lab_multifile.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_cart_lab_multifile.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_cart_lab_multifile.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_cart_lab_multifile.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_cart_lab_multifile.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_cart_lab_multifile.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_cart_lab_multifile.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_cart_lab_multifile.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_cart_lab_multifile.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_cart_lab_multifile.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _cart_lab_multifile.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _cart_lab_multifile.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.raster_multifile
import geocal_swig.raster_image_variable
import geocal_swig.raster_image
import geocal_swig.generic_object
class CartLabMultifile(geocal_swig.raster_multifile.RasterMultifile):
    """

    There are 2 kinds of multi-file databases that the cartlab produces.

    The first uses an IBIS file to describe the file structure, this is
    used by for example SrtmDem. This is handled by the class
    VicarMultiFile.

    The other uses a naming convention, with fixed size tiles in each
    file. Examples are the Landsat 7 data, or the USGS DEM. This class
    provides support for the common behavior of these types of databases.
    For right now we assume that the data needs to be read by GDAL (so the
    data is not VICAR format, but something like geotiff). We could relax
    that if needed.

    The file names are always of the form "n66e130_<extension>" or
    "s9w62_<extension>". The coordinates in the name give something
    close to the upper left corner of the tile covered by the at file. In
    general this won't be the exact upper left corner, there may be some
    offset or border added to the files (this varies from dataset to
    dataset). Derived classes should fill in a "reference map info",
    which is just the coordinates for a particular file (e.g., use
    gdalinfo to find the information). We then determine the map info for
    every other file by finding the offset relative to this reference map
    info. We do this by the naming convention rather than just reading
    each file and getting the map info metadata because it is much
    quicker. See for example UsgsDem for an example of filling in this
    information.

    Note that some databases have 0 padding in the file name (e.g, USGS
    DEM has files like "n47w087_10m.tif"). While others don't (e.g.,
    SRTM has file names like "n47w87_L2.hlf"). Either naming convention
    works with this file, we actually build up the files by reading the
    directory.

    C++ includes: cart_lab_multifile.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _v_create_subset_file(self, *args):
        """

        void CartLabMultifile::create_subset_file(const std::string &Oname, const std::string &Driver, const
        std::vector< boost::shared_ptr< GroundCoordinate > > &Pt, const
        boost::shared_ptr< MapInfo > &Desired_map_info=boost::shared_ptr<
        MapInfo >(), const std::string &Translate_arg="", const std::string
        &Options="", int boundary=0, bool Verbose=false) const
        Create a stand alone file that contains a subset of the full file.

        This handles whatever mosaicing/subsetting is needed for the
        underlying tile files. We use GDAL to generate this, so you pass in
        the driver to use like you do with a GdalRasterImage (e.g., "gtiff")
        and whatever options (e.g., "TILED=YES BLOCKXSIZE=16 BLOCKYSIZE=32
        COMPRESS=JPEG JPEG_QUALITY=90"). We cover the given set of points,
        along with whatever boundary you request (just like MapInfo cover
        function).

        This executes the command shell gdalbuildvrt, which must be in the
        path. Right now with GDAL the same functionality can't be done through
        C++, but there is talk of making VRTBuilder found in gdalbuildvrt
        available. For now though, we just use a system call.

        You can either supply a set of points to cover (which will use the
        native map_info() for this object), or you can supply an explicit
        Desired_map_info (e.g., you are matching an existing file in extent
        and resolution).

        You can optionally supply an argument string to use with
        gdal_translate on the gdalbuildvrt file before writing to the output.
        This can be useful to do things like change the output type or scale
        the data. See gdal_translate documentation for what these options
        should be (e.g., "-ot Int16 -outsize 50% 50% -r average" to convert
        to Int16 and 2x2 pixel averaging to make a coarser image). 
        """
        return _cart_lab_multifile.CartLabMultifile__v_create_subset_file(self, *args)


    def _v_directory_base(self):
        """

        const std::string& GeoCal::CartLabMultifile::directory_base() const
        Database base directory. 
        """
        return _cart_lab_multifile.CartLabMultifile__v_directory_base(self)


    @property
    def directory_base(self):
        return self._v_directory_base()


    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)


    def create_subset_file(self, Oname, Driver, Pt_list = [], Desired_map_info = None, Translate_arg = "", Options = "", Boundary = 0, Verbose = False):
      if(isinstance(Pt_list, geocal_swig.Vector_GroundCoordinate)):
          t = Pt_list
      else:
          t = geocal_swig.Vector_GroundCoordinate()
          for p in Pt_list:
              t.push_back(p)
      return self._v_create_subset_file(Oname, Driver, t, Desired_map_info, Translate_arg,Options, Boundary, Verbose)

    __swig_destroy__ = _cart_lab_multifile.delete_CartLabMultifile
CartLabMultifile._v_create_subset_file = new_instancemethod(_cart_lab_multifile.CartLabMultifile__v_create_subset_file, None, CartLabMultifile)
CartLabMultifile._v_directory_base = new_instancemethod(_cart_lab_multifile.CartLabMultifile__v_directory_base, None, CartLabMultifile)
CartLabMultifile_swigregister = _cart_lab_multifile.CartLabMultifile_swigregister
CartLabMultifile_swigregister(CartLabMultifile)

class GdalCartLabMultifile(CartLabMultifile):
    """

    This is a CartLabMultifile where we use GDAL to read each of the
    tiles, e.g., the tiles are geotiff files.

    C++ includes: cart_lab_multifile.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _cart_lab_multifile.delete_GdalCartLabMultifile
GdalCartLabMultifile_swigregister = _cart_lab_multifile.GdalCartLabMultifile_swigregister
GdalCartLabMultifile_swigregister(GdalCartLabMultifile)

class VicarCartLabMultifile(CartLabMultifile):
    """

    This is a CartLabMultifile where we use Vicar to read each of the
    tiles.

    If desired we can favor doing memory mapping when possible rather than
    using the VICAR RTL (i.e., we use VicarLiteRasterImage).

    The force_area_pixel_ forces the files to be treated as "pixel as
    area" rather than "pixel as point". This is really just meant as a
    work around for the SRTM data, which incorrectly labels the data as
    "point" rather than "area". Since this is a 15 meter difference,
    it matters for many applications. Most users should just ignore this
    value.

    C++ includes: cart_lab_multifile.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _cart_lab_multifile.delete_VicarCartLabMultifile
VicarCartLabMultifile_swigregister = _cart_lab_multifile.VicarCartLabMultifile_swigregister
VicarCartLabMultifile_swigregister(VicarCartLabMultifile)


__all__ = ["CartLabMultifile","GdalCartLabMultifile","VicarCartLabMultifile"]



