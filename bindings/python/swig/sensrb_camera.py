# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
from ._swig_wrap import _sensrb_camera

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _sensrb_camera.SWIG_PyInstanceMethod_New
_swig_new_static_method = _sensrb_camera.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_MODULE_ALREADY_DONE = _sensrb_camera.SWIG_MODULE_ALREADY_DONE
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sensrb_camera.delete_SwigPyIterator
    value = _swig_new_instance_method(_sensrb_camera.SwigPyIterator_value)
    incr = _swig_new_instance_method(_sensrb_camera.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_sensrb_camera.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_sensrb_camera.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_sensrb_camera.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_sensrb_camera.SwigPyIterator_copy)
    next = _swig_new_instance_method(_sensrb_camera.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_sensrb_camera.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_sensrb_camera.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_sensrb_camera.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_sensrb_camera.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_sensrb_camera.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_sensrb_camera.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_sensrb_camera.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_sensrb_camera.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_sensrb_camera.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _sensrb_camera:
_sensrb_camera.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _sensrb_camera.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_function.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_function.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.quaternion_camera
import geocal_swig.generic_object
import geocal_swig.observer
import geocal_swig.camera
import geocal_swig.with_parameter
class SensrbCamera(geocal_swig.quaternion_camera.QuaternionCamera):
    r"""

    This is a QuaternionCamera where the nonlinearity of the camera is
    described by a radial model.

    r^2 = x^2 + y^2 dr/r = k1 * r^2 + k2 * r^4 + k3 * r^3 x_corrected = x
    + (dr/r)*x + p1 * (r^2 + 2 x^2) + 2 p2 * x * y + b1 * x + b2 * y
    y_corrected = x + (dr/r)*x + p2 *(r^2 + 2 y^2) + 2 p1 * x * y

    Note this is similar to but not identical to the Brown-Conrady
    distortion model,
    seehttps://en.wikipedia.org/wiki/Distortion_(optics).

    Note, I think we need to have the various constants in mm rather than
    pixel - I think this is required by MSP library and normally we do
    this in x,y space - not line/sample space.

    This is the camera model used by the SENSRB TRE in NITF files.

    The convention used by SENSRB is that line is in the +y direction,
    sample is the -x direction (so different than the default for
    QuaternionCamera class). This is the "Camera" coordinates, there is
    another (and different) coordinate system called "Sensor". See
    "SENSRB Profile Frame Image-To-Ground Transformation Description" by
    Michael J. Lenihan.

    The coordinate system for the angles is "SENSOR_ANGLE_MODEL = 1"
    which actually has a bit of a odd orientation. It appears to be
    something like the pilot holding the camera in front of his face. This
    means that all angles 0 actually doesn't point the camera towards the
    ground (most of our models have had nadir pointing camera have an
    identity quaternion).

    There are other SENSOR_ANGLE_MODEL (2 and 3), but the MSP library
    doesn't support these. We could add support for these in the future if
    useful (e.g., change quaternion_to_sensor_angle to take the model
    number).

    The actual camera model just as a normal frame_to_sc() like other
    QuaternionCamera. We handle mapping this too and from the sensor
    angles used NITF through the various static functions (e.g.,
    quaternion_to_sensor_angle).

    C++ includes: sensrb_camera.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        GeoCal::SensrbCamera::SensrbCamera(const boost::math::quaternion< double > &Frame_to_sc_q, double K1,
        double K2, double K3, double P1, double P2, double B1, double B2,
        double Radial_distort_limit, int Number_line, int Number_sample,
        double Line_pitch, double Sample_pitch, double Focal_length, const
        FrameCoordinate &Principal_point, const std::string
        &Detection_type="VIS", const std::string
        &Calibration_date="20000101", QuaternionCamera::FrameConvention
        Frame_convention=QuaternionCamera::LINE_IS_Y,
        QuaternionCamera::FrameDirection
        Line_direction=QuaternionCamera::INCREASE_IS_POSITIVE,
        QuaternionCamera::FrameDirection
        Sample_direction=QuaternionCamera::INCREASE_IS_NEGATIVE)
        Create a QuaternionCamera with a radial distortion model given by
        kdistort.

        We currently limit kdistort.rows() <= 3, although we could relax that
        if it ends up being useful. 
        """
        _sensrb_camera.SensrbCamera_swiginit(self, _sensrb_camera.new_SensrbCamera(*args))
    _v_p_distort = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_p_distort)

    @property
    def p_distort(self):
        return self._v_p_distort()

    _v_k1 = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_k1)

    @property
    def k1(self):
        return self._v_k1()

    @k1.setter
    def k1(self, value):
      self._v_k1(value)

    _v_k2 = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_k2)

    @property
    def k2(self):
        return self._v_k2()

    @k2.setter
    def k2(self, value):
      self._v_k2(value)

    _v_k3 = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_k3)

    @property
    def k3(self):
        return self._v_k3()

    @k3.setter
    def k3(self, value):
      self._v_k3(value)

    _v_p1 = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_p1)

    @property
    def p1(self):
        return self._v_p1()

    @p1.setter
    def p1(self, value):
      self._v_p1(value)

    _v_p2 = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_p2)

    @property
    def p2(self):
        return self._v_p2()

    @p2.setter
    def p2(self, value):
      self._v_p2(value)

    _v_b1 = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_b1)

    @property
    def b1(self):
        return self._v_b1()

    @b1.setter
    def b1(self, value):
      self._v_b1(value)

    _v_b2 = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_b2)

    @property
    def b2(self):
        return self._v_b2()

    @b2.setter
    def b2(self, value):
      self._v_b2(value)

    _v_radial_distort_limit = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_radial_distort_limit)

    @property
    def radial_distort_limit(self):
        return self._v_radial_distort_limit()

    @radial_distort_limit.setter
    def radial_distort_limit(self, value):
      self._v_radial_distort_limit(value)

    _v_calibration_date = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_calibration_date)

    @property
    def calibration_date(self):
        return self._v_calibration_date()

    @calibration_date.setter
    def calibration_date(self, value):
      self._v_calibration_date(value)

    _v_detection_type = _swig_new_instance_method(_sensrb_camera.SensrbCamera__v_detection_type)

    @property
    def detection_type(self):
        return self._v_detection_type()

    @detection_type.setter
    def detection_type(self, value):
      self._v_detection_type(value)

    quaternion_to_sensor_angle = _swig_new_static_method(_sensrb_camera.SensrbCamera_quaternion_to_sensor_angle)
    sensor_angle_to_quaternion = _swig_new_static_method(_sensrb_camera.SensrbCamera_sensor_angle_to_quaternion)

    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)

    __swig_destroy__ = _sensrb_camera.delete_SensrbCamera

# Register SensrbCamera in _sensrb_camera:
_sensrb_camera.SensrbCamera_swigregister(SensrbCamera)

__all__ = ["SensrbCamera"]


