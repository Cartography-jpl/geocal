# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _cart_lab_multifile.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_cart_lab_multifile', [dirname(__file__)])
        except ImportError:
            import _cart_lab_multifile
            return _cart_lab_multifile
        if fp is not None:
            try:
                _mod = imp.load_module('_cart_lab_multifile', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _cart_lab_multifile = swig_import_helper()
    del swig_import_helper
else:
    import _cart_lab_multifile
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _cart_lab_multifile.SHARED_PTR_DISOWN
def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst
 
def _new_from_serialization(data):
    return geocal_swig.serialize_read_binary(data)

def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.raster_multifile
import geocal_swig.raster_image_variable
import geocal_swig.raster_image
import geocal_swig.generic_object
class CartLabMultifile(geocal_swig.raster_multifile.RasterMultifile):
    """
    There are 2 kinds of multi-file databases that the cartlab produces.

    The first uses an IBIS file to describe the file structure, this is
    used by for example SrtmDem. This is handled by the class
    VicarMultiFile.

    The other uses a naming convention, with fixed size tiles in each
    file. Examples are the Landsat 7 data, or the USGS DEM. This class
    provides support for the common behavior of these types of databases.
    For right now we assume that the data needs to be read by GDAL (so the
    data is not VICAR format, but something like geotiff). We could relax
    that if needed.

    The file names are always of the form "n66e130_<extension>" or
    "s9w62_<extension>". The coordinates in the name give something
    close to the upper left corner of the tile covered by the at file. In
    general this won't be the exact upper left corner, there may be some
    offset or border added to the files (this varies from dataset to
    dataset). Derived classes should fill in a "reference map info",
    which is just the coordinates for a particular file (e.g., use
    gdalinfo to find the information). We then determine the map info for
    every other file by finding the offset relative to this reference map
    info. We do this by the naming convention rather than just reading
    each file and getting the map info metadata because it is much
    quicker. See for example UsgsDem for an example of filling in this
    information.

    Note that some databases have 0 padding in the file name (e.g, USGS
    DEM has files like "n47w087_10m.tif"). While others don't (e.g.,
    SRTM has file names like "n47w87_L2.hlf"). Either naming convention
    works with this file, we actually build up the files by reading the
    directory.

    C++ includes: cart_lab_multifile.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def _v_directory_base(self):
        """
        const std::string& GeoCal::CartLabMultifile::directory_base() const
        Database base directory. 
        """
        return _cart_lab_multifile.CartLabMultifile__v_directory_base(self)

    @property
    def directory_base(self):
        return self._v_directory_base()

    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _cart_lab_multifile.delete_CartLabMultifile
CartLabMultifile._v_directory_base = new_instancemethod(_cart_lab_multifile.CartLabMultifile__v_directory_base,None,CartLabMultifile)
CartLabMultifile_swigregister = _cart_lab_multifile.CartLabMultifile_swigregister
CartLabMultifile_swigregister(CartLabMultifile)

class GdalCartLabMultifile(CartLabMultifile):
    """
    This is a CartLabMultifile where we use GDAL to read each of the
    tiles, e.g., the tiles are geotiff files.

    C++ includes: cart_lab_multifile.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _cart_lab_multifile.delete_GdalCartLabMultifile
GdalCartLabMultifile_swigregister = _cart_lab_multifile.GdalCartLabMultifile_swigregister
GdalCartLabMultifile_swigregister(GdalCartLabMultifile)



