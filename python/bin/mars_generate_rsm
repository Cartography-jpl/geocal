#! /usr/bin/env python
#
# This takes a unprojected PDS file, imports it to VICAR, and adds a
# RSM.

import geocal
import os
import subprocess
import struct

version = "Sept 11, 2019"
usage='''Usage:
  mars_generate_rsm [options] <pds_image> <output_base_name>
  mars_generate_rsm -h | --help
  mars_generate_rsm -v | --version

mars_generate_rsm takes an unprojected PDS image, imports it to VICAR, 
and adds a RSM.

We do not do any radiance correction (e.g., dark current subtraction),
we just pass through the DNs unchanged. However, for CTX camera the
data is at level 0 is normally SQRT encoded. We do expand that out to 
unencoded data.

Currently the specific forms of the RSM are hard coded based on the 
instrument type.

It is not clear what we should do with masked pixels (e.g., CTX), right 
now, we are just removing them.

We are not currently including camera nonlinearities (e.g., HRSC), this 
is something we could add in the future.

One of the required inputs is the various SPICE kernels need to calculate
ephemeris and attitude. There are two components to this - a fixed set of
kernels that is used for any run, and a set of kernels that are time based.
We get the fixed set of kernels from a parent kernel file (kernel files can
list other files to include), and we get the time based kernels from a JSON
file that describes a mapping from time to a the kernel to use. This JSON
file is created by a separate program that looks at all the kernels in
a directory, see the "create_kernel_json" file.

To simplify the input, we default to files in the directory pointed to
by the environment variable MARS_KERNEL. This is filled in with the normal
AFIDS setup_afids_env.sh script. The fixed kernel defaults to 
mro_kernel/mro.ker or mex_kernel/mex.ker depending on the instrument used
(mro.ker for CTX images, mex.ker for HRSC images).

You may have instances where you want to use different set of kernels, e.g.
you have newer improved versions of the kernels than in the standard
MARS_KERNEL directory, or you need to process times not found in the 
MARS_KERNEL directory. You can override the kernels used by using the
command line arguments --kernel-file and --kernel-json. There is also the
additional option --kernel-file-post for loading kernels after the others.
This is used by for example MEX where there is a CK/ATNM_RECONSTITUTED_00004.BC
file that fixes some of the data in the MEX kernels.

Example:
    mars_generate_rsm /raid26/tllogan/mars/mawrth_vallis/source/unmapped/P16_007388_2049_XI_24N020W.IMG ctx1
    rsm_project --grid-spacing=10 --map-info=ctx1_ref_img.xml --number-process=20 --verbose --process-number-line=1000 --process-number-sample=1000 ctx1.img ctx1_proj.img

Options:
  -h --help         
       Print this message

  --full-igc=f
       For diagnostic purposes, it can be useful to have the full IGC (i.e.,
       the one with the camera model, spice kernel, etc.). This is what we
       are approximating with the RSM.

  --kernel-file=f
       If supplied, override the kernel file used. If not specified we 
       use mro_kernel/mro.ker or mex_kernel/mex.ker in the directory given
       by the environment variable MARS_KERNEL.

  --kernel-file-post=f
       If supplied, override the kernel file to include after all the others.
       Defaults to "mex_kernel/mex_reconstituted.ker" for HRSC, none for
       CTX.

  --kernel-json=f
       If supplied, override the time based JSON file mapping to kernels.
       Defaults to "mro_kernel/kernel.json" or "mex_kernel/kernel.json".

  --min-height=d
       Minimum DEM height we create RSM for. Note this doesn't need to be
       super accurate, just a reasonable value that is lower than any height
       we will encounter over the area [default: -5000.0]

  --max-height=d
       Maximum DEM height we create RSM for. Note this doesn't need to be
       super accurate, just a reasonable value that is lower than any height
       we will encounter over the area [default: -1500.0]

  --plot-cross-section=f
       To evaluate the quality of the generated RSM, this takes a cross 
       section for all lines, and 5 equally spaced samples and plots the 
       difference between the calculated line and sample vs. what the
       full ImageGroundConnection calculation creates. Output is a PDF
       file.

  --subset=f
       Subset the image. This should be the start line, start sample, number
       line and number sample.
 
  -v --version      
       Print program version
'''

# Mapping between long name and shorter vicar name
long_name_to_vicar = { "pds_image" : "pdsimg",
                       "output_base_name" : "outbase",
                       "full_igc" : "fulligc",
                       "min_height" : "minh",
                       "max_height" : "maxh",
                       "subset" : "subset",
                       "plot_cross_section" : "plot",
                       "kernel_file" : "kfile",
                       "kernel_file_post": "kpfile",
                       "kernel_json" : "kjson"}

args = geocal.docopt_simple(usage, version=version,
                     long_name_to_vicar=long_name_to_vicar)

    
# Determine the image type
lbl = geocal.pds_label(args.pds_image)
subset = None
if args.subset:
    subset = eval(args.subset)
if(lbl['INSTRUMENT_NAME'] == 'CONTEXT CAMERA'):
    igc = geocal.igc_mro_context(args.pds_image, lbl=lbl, 
                                 kernel_file=args.kernel_file,
                                 kernel_file_post=args.kernel_file_post,
                                 kernel_json=args.kernel_json, subset=subset)
    r = geocal.rsm_context(igc)
elif(lbl['INSTRUMENT_NAME'] == 'HIGH RESOLUTION STEREO CAMERA'):
    igc = geocal.igc_mex_hrsc(args.pds_image, lbl=lbl, 
                              kernel_file=args.kernel_file,
                              kernel_file_post=args.kernel_file_post,
                              kernel_json=args.kernel_json, subset=subset)
    r, igc = geocal.rsm_hrsc(lbl,args.pds_image, subset)
else:
    raise RuntimeError("Not a recognized instrument name %s" %
                       lbl['INSTRUMENT_NAME'])

# For right now, output the igc so we have record of it
if(args.full_igc):
    geocal.write_shelve(args.full_igc, igc)
    
# Write out the PDS label, in case there is something we need from it
with open(args.output_base_name + ".lbl", "wb") as fh:
    fh.write(geocal.pds_label_text(args.pds_image))
f = geocal.VicarRasterImage(args.output_base_name + ".img", "HALF",
                     igc.number_line, igc.number_sample)
fin = geocal.GdalRasterImage(args.pds_image)
for k in fin.metadata_list():
    if(not fin[k] == "") :
        f[k] = fin[k]
geocal.copy_raster(igc.image, f, True)
f.close()
geocal.write_shelve(args.output_base_name + ".rsm.xml", r)
if(args.plot_cross_section):
    geocal.rsm_plot_diff(r, igc, args.plot_cross_section)
    

