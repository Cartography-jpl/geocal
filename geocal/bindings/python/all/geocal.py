# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _geocal.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_geocal', [dirname(__file__)])
        except ImportError:
            import _geocal
            return _geocal
        if fp is not None:
            try:
                _mod = imp.load_module('_geocal', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _geocal = swig_import_helper()
    del swig_import_helper
else:
    import _geocal
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _geocal.SHARED_PTR_DISOWN
import numpy as np

def _new_from_init(cls, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example ImageCoordinate'''
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _geocal.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_geocal.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_geocal.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_geocal.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_geocal.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_geocal.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_geocal.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_geocal.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_geocal.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_geocal.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_geocal.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_geocal.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_geocal.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_geocal.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_geocal.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_geocal.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_geocal.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _geocal.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class Vector_double(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_double_swiginit(self,_geocal.new_Vector_double(*args))
    __swig_destroy__ = _geocal.delete_Vector_double
Vector_double.iterator = new_instancemethod(_geocal.Vector_double_iterator,None,Vector_double)
Vector_double.__nonzero__ = new_instancemethod(_geocal.Vector_double___nonzero__,None,Vector_double)
Vector_double.__bool__ = new_instancemethod(_geocal.Vector_double___bool__,None,Vector_double)
Vector_double.__len__ = new_instancemethod(_geocal.Vector_double___len__,None,Vector_double)
Vector_double.pop = new_instancemethod(_geocal.Vector_double_pop,None,Vector_double)
Vector_double.__getslice__ = new_instancemethod(_geocal.Vector_double___getslice__,None,Vector_double)
Vector_double.__setslice__ = new_instancemethod(_geocal.Vector_double___setslice__,None,Vector_double)
Vector_double.__delslice__ = new_instancemethod(_geocal.Vector_double___delslice__,None,Vector_double)
Vector_double.__delitem__ = new_instancemethod(_geocal.Vector_double___delitem__,None,Vector_double)
Vector_double.__getitem__ = new_instancemethod(_geocal.Vector_double___getitem__,None,Vector_double)
Vector_double.__setitem__ = new_instancemethod(_geocal.Vector_double___setitem__,None,Vector_double)
Vector_double.append = new_instancemethod(_geocal.Vector_double_append,None,Vector_double)
Vector_double.empty = new_instancemethod(_geocal.Vector_double_empty,None,Vector_double)
Vector_double.size = new_instancemethod(_geocal.Vector_double_size,None,Vector_double)
Vector_double.clear = new_instancemethod(_geocal.Vector_double_clear,None,Vector_double)
Vector_double.swap = new_instancemethod(_geocal.Vector_double_swap,None,Vector_double)
Vector_double.get_allocator = new_instancemethod(_geocal.Vector_double_get_allocator,None,Vector_double)
Vector_double.begin = new_instancemethod(_geocal.Vector_double_begin,None,Vector_double)
Vector_double.end = new_instancemethod(_geocal.Vector_double_end,None,Vector_double)
Vector_double.rbegin = new_instancemethod(_geocal.Vector_double_rbegin,None,Vector_double)
Vector_double.rend = new_instancemethod(_geocal.Vector_double_rend,None,Vector_double)
Vector_double.pop_back = new_instancemethod(_geocal.Vector_double_pop_back,None,Vector_double)
Vector_double.erase = new_instancemethod(_geocal.Vector_double_erase,None,Vector_double)
Vector_double.push_back = new_instancemethod(_geocal.Vector_double_push_back,None,Vector_double)
Vector_double.front = new_instancemethod(_geocal.Vector_double_front,None,Vector_double)
Vector_double.back = new_instancemethod(_geocal.Vector_double_back,None,Vector_double)
Vector_double.assign = new_instancemethod(_geocal.Vector_double_assign,None,Vector_double)
Vector_double.resize = new_instancemethod(_geocal.Vector_double_resize,None,Vector_double)
Vector_double.insert = new_instancemethod(_geocal.Vector_double_insert,None,Vector_double)
Vector_double.reserve = new_instancemethod(_geocal.Vector_double_reserve,None,Vector_double)
Vector_double.capacity = new_instancemethod(_geocal.Vector_double_capacity,None,Vector_double)
Vector_double_swigregister = _geocal.Vector_double_swigregister
Vector_double_swigregister(Vector_double)

class Vector_string(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_string_swiginit(self,_geocal.new_Vector_string(*args))
    __swig_destroy__ = _geocal.delete_Vector_string
Vector_string.iterator = new_instancemethod(_geocal.Vector_string_iterator,None,Vector_string)
Vector_string.__nonzero__ = new_instancemethod(_geocal.Vector_string___nonzero__,None,Vector_string)
Vector_string.__bool__ = new_instancemethod(_geocal.Vector_string___bool__,None,Vector_string)
Vector_string.__len__ = new_instancemethod(_geocal.Vector_string___len__,None,Vector_string)
Vector_string.pop = new_instancemethod(_geocal.Vector_string_pop,None,Vector_string)
Vector_string.__getslice__ = new_instancemethod(_geocal.Vector_string___getslice__,None,Vector_string)
Vector_string.__setslice__ = new_instancemethod(_geocal.Vector_string___setslice__,None,Vector_string)
Vector_string.__delslice__ = new_instancemethod(_geocal.Vector_string___delslice__,None,Vector_string)
Vector_string.__delitem__ = new_instancemethod(_geocal.Vector_string___delitem__,None,Vector_string)
Vector_string.__getitem__ = new_instancemethod(_geocal.Vector_string___getitem__,None,Vector_string)
Vector_string.__setitem__ = new_instancemethod(_geocal.Vector_string___setitem__,None,Vector_string)
Vector_string.append = new_instancemethod(_geocal.Vector_string_append,None,Vector_string)
Vector_string.empty = new_instancemethod(_geocal.Vector_string_empty,None,Vector_string)
Vector_string.size = new_instancemethod(_geocal.Vector_string_size,None,Vector_string)
Vector_string.clear = new_instancemethod(_geocal.Vector_string_clear,None,Vector_string)
Vector_string.swap = new_instancemethod(_geocal.Vector_string_swap,None,Vector_string)
Vector_string.get_allocator = new_instancemethod(_geocal.Vector_string_get_allocator,None,Vector_string)
Vector_string.begin = new_instancemethod(_geocal.Vector_string_begin,None,Vector_string)
Vector_string.end = new_instancemethod(_geocal.Vector_string_end,None,Vector_string)
Vector_string.rbegin = new_instancemethod(_geocal.Vector_string_rbegin,None,Vector_string)
Vector_string.rend = new_instancemethod(_geocal.Vector_string_rend,None,Vector_string)
Vector_string.pop_back = new_instancemethod(_geocal.Vector_string_pop_back,None,Vector_string)
Vector_string.erase = new_instancemethod(_geocal.Vector_string_erase,None,Vector_string)
Vector_string.push_back = new_instancemethod(_geocal.Vector_string_push_back,None,Vector_string)
Vector_string.front = new_instancemethod(_geocal.Vector_string_front,None,Vector_string)
Vector_string.back = new_instancemethod(_geocal.Vector_string_back,None,Vector_string)
Vector_string.assign = new_instancemethod(_geocal.Vector_string_assign,None,Vector_string)
Vector_string.resize = new_instancemethod(_geocal.Vector_string_resize,None,Vector_string)
Vector_string.insert = new_instancemethod(_geocal.Vector_string_insert,None,Vector_string)
Vector_string.reserve = new_instancemethod(_geocal.Vector_string_reserve,None,Vector_string)
Vector_string.capacity = new_instancemethod(_geocal.Vector_string_capacity,None,Vector_string)
Vector_string_swigregister = _geocal.Vector_string_swigregister
Vector_string_swigregister(Vector_string)

class Vector_unsigned_char(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_unsigned_char_swiginit(self,_geocal.new_Vector_unsigned_char(*args))
    __swig_destroy__ = _geocal.delete_Vector_unsigned_char
Vector_unsigned_char.iterator = new_instancemethod(_geocal.Vector_unsigned_char_iterator,None,Vector_unsigned_char)
Vector_unsigned_char.__nonzero__ = new_instancemethod(_geocal.Vector_unsigned_char___nonzero__,None,Vector_unsigned_char)
Vector_unsigned_char.__bool__ = new_instancemethod(_geocal.Vector_unsigned_char___bool__,None,Vector_unsigned_char)
Vector_unsigned_char.__len__ = new_instancemethod(_geocal.Vector_unsigned_char___len__,None,Vector_unsigned_char)
Vector_unsigned_char.pop = new_instancemethod(_geocal.Vector_unsigned_char_pop,None,Vector_unsigned_char)
Vector_unsigned_char.__getslice__ = new_instancemethod(_geocal.Vector_unsigned_char___getslice__,None,Vector_unsigned_char)
Vector_unsigned_char.__setslice__ = new_instancemethod(_geocal.Vector_unsigned_char___setslice__,None,Vector_unsigned_char)
Vector_unsigned_char.__delslice__ = new_instancemethod(_geocal.Vector_unsigned_char___delslice__,None,Vector_unsigned_char)
Vector_unsigned_char.__delitem__ = new_instancemethod(_geocal.Vector_unsigned_char___delitem__,None,Vector_unsigned_char)
Vector_unsigned_char.__getitem__ = new_instancemethod(_geocal.Vector_unsigned_char___getitem__,None,Vector_unsigned_char)
Vector_unsigned_char.__setitem__ = new_instancemethod(_geocal.Vector_unsigned_char___setitem__,None,Vector_unsigned_char)
Vector_unsigned_char.append = new_instancemethod(_geocal.Vector_unsigned_char_append,None,Vector_unsigned_char)
Vector_unsigned_char.empty = new_instancemethod(_geocal.Vector_unsigned_char_empty,None,Vector_unsigned_char)
Vector_unsigned_char.size = new_instancemethod(_geocal.Vector_unsigned_char_size,None,Vector_unsigned_char)
Vector_unsigned_char.clear = new_instancemethod(_geocal.Vector_unsigned_char_clear,None,Vector_unsigned_char)
Vector_unsigned_char.swap = new_instancemethod(_geocal.Vector_unsigned_char_swap,None,Vector_unsigned_char)
Vector_unsigned_char.get_allocator = new_instancemethod(_geocal.Vector_unsigned_char_get_allocator,None,Vector_unsigned_char)
Vector_unsigned_char.begin = new_instancemethod(_geocal.Vector_unsigned_char_begin,None,Vector_unsigned_char)
Vector_unsigned_char.end = new_instancemethod(_geocal.Vector_unsigned_char_end,None,Vector_unsigned_char)
Vector_unsigned_char.rbegin = new_instancemethod(_geocal.Vector_unsigned_char_rbegin,None,Vector_unsigned_char)
Vector_unsigned_char.rend = new_instancemethod(_geocal.Vector_unsigned_char_rend,None,Vector_unsigned_char)
Vector_unsigned_char.pop_back = new_instancemethod(_geocal.Vector_unsigned_char_pop_back,None,Vector_unsigned_char)
Vector_unsigned_char.erase = new_instancemethod(_geocal.Vector_unsigned_char_erase,None,Vector_unsigned_char)
Vector_unsigned_char.push_back = new_instancemethod(_geocal.Vector_unsigned_char_push_back,None,Vector_unsigned_char)
Vector_unsigned_char.front = new_instancemethod(_geocal.Vector_unsigned_char_front,None,Vector_unsigned_char)
Vector_unsigned_char.back = new_instancemethod(_geocal.Vector_unsigned_char_back,None,Vector_unsigned_char)
Vector_unsigned_char.assign = new_instancemethod(_geocal.Vector_unsigned_char_assign,None,Vector_unsigned_char)
Vector_unsigned_char.resize = new_instancemethod(_geocal.Vector_unsigned_char_resize,None,Vector_unsigned_char)
Vector_unsigned_char.insert = new_instancemethod(_geocal.Vector_unsigned_char_insert,None,Vector_unsigned_char)
Vector_unsigned_char.reserve = new_instancemethod(_geocal.Vector_unsigned_char_reserve,None,Vector_unsigned_char)
Vector_unsigned_char.capacity = new_instancemethod(_geocal.Vector_unsigned_char_capacity,None,Vector_unsigned_char)
Vector_unsigned_char_swigregister = _geocal.Vector_unsigned_char_swigregister
Vector_unsigned_char_swigregister(Vector_unsigned_char)

class Vector_short_int(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_short_int_swiginit(self,_geocal.new_Vector_short_int(*args))
    __swig_destroy__ = _geocal.delete_Vector_short_int
Vector_short_int.iterator = new_instancemethod(_geocal.Vector_short_int_iterator,None,Vector_short_int)
Vector_short_int.__nonzero__ = new_instancemethod(_geocal.Vector_short_int___nonzero__,None,Vector_short_int)
Vector_short_int.__bool__ = new_instancemethod(_geocal.Vector_short_int___bool__,None,Vector_short_int)
Vector_short_int.__len__ = new_instancemethod(_geocal.Vector_short_int___len__,None,Vector_short_int)
Vector_short_int.pop = new_instancemethod(_geocal.Vector_short_int_pop,None,Vector_short_int)
Vector_short_int.__getslice__ = new_instancemethod(_geocal.Vector_short_int___getslice__,None,Vector_short_int)
Vector_short_int.__setslice__ = new_instancemethod(_geocal.Vector_short_int___setslice__,None,Vector_short_int)
Vector_short_int.__delslice__ = new_instancemethod(_geocal.Vector_short_int___delslice__,None,Vector_short_int)
Vector_short_int.__delitem__ = new_instancemethod(_geocal.Vector_short_int___delitem__,None,Vector_short_int)
Vector_short_int.__getitem__ = new_instancemethod(_geocal.Vector_short_int___getitem__,None,Vector_short_int)
Vector_short_int.__setitem__ = new_instancemethod(_geocal.Vector_short_int___setitem__,None,Vector_short_int)
Vector_short_int.append = new_instancemethod(_geocal.Vector_short_int_append,None,Vector_short_int)
Vector_short_int.empty = new_instancemethod(_geocal.Vector_short_int_empty,None,Vector_short_int)
Vector_short_int.size = new_instancemethod(_geocal.Vector_short_int_size,None,Vector_short_int)
Vector_short_int.clear = new_instancemethod(_geocal.Vector_short_int_clear,None,Vector_short_int)
Vector_short_int.swap = new_instancemethod(_geocal.Vector_short_int_swap,None,Vector_short_int)
Vector_short_int.get_allocator = new_instancemethod(_geocal.Vector_short_int_get_allocator,None,Vector_short_int)
Vector_short_int.begin = new_instancemethod(_geocal.Vector_short_int_begin,None,Vector_short_int)
Vector_short_int.end = new_instancemethod(_geocal.Vector_short_int_end,None,Vector_short_int)
Vector_short_int.rbegin = new_instancemethod(_geocal.Vector_short_int_rbegin,None,Vector_short_int)
Vector_short_int.rend = new_instancemethod(_geocal.Vector_short_int_rend,None,Vector_short_int)
Vector_short_int.pop_back = new_instancemethod(_geocal.Vector_short_int_pop_back,None,Vector_short_int)
Vector_short_int.erase = new_instancemethod(_geocal.Vector_short_int_erase,None,Vector_short_int)
Vector_short_int.push_back = new_instancemethod(_geocal.Vector_short_int_push_back,None,Vector_short_int)
Vector_short_int.front = new_instancemethod(_geocal.Vector_short_int_front,None,Vector_short_int)
Vector_short_int.back = new_instancemethod(_geocal.Vector_short_int_back,None,Vector_short_int)
Vector_short_int.assign = new_instancemethod(_geocal.Vector_short_int_assign,None,Vector_short_int)
Vector_short_int.resize = new_instancemethod(_geocal.Vector_short_int_resize,None,Vector_short_int)
Vector_short_int.insert = new_instancemethod(_geocal.Vector_short_int_insert,None,Vector_short_int)
Vector_short_int.reserve = new_instancemethod(_geocal.Vector_short_int_reserve,None,Vector_short_int)
Vector_short_int.capacity = new_instancemethod(_geocal.Vector_short_int_capacity,None,Vector_short_int)
Vector_short_int_swigregister = _geocal.Vector_short_int_swigregister
Vector_short_int_swigregister(Vector_short_int)

class Vector_int(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_int_swiginit(self,_geocal.new_Vector_int(*args))
    __swig_destroy__ = _geocal.delete_Vector_int
Vector_int.iterator = new_instancemethod(_geocal.Vector_int_iterator,None,Vector_int)
Vector_int.__nonzero__ = new_instancemethod(_geocal.Vector_int___nonzero__,None,Vector_int)
Vector_int.__bool__ = new_instancemethod(_geocal.Vector_int___bool__,None,Vector_int)
Vector_int.__len__ = new_instancemethod(_geocal.Vector_int___len__,None,Vector_int)
Vector_int.pop = new_instancemethod(_geocal.Vector_int_pop,None,Vector_int)
Vector_int.__getslice__ = new_instancemethod(_geocal.Vector_int___getslice__,None,Vector_int)
Vector_int.__setslice__ = new_instancemethod(_geocal.Vector_int___setslice__,None,Vector_int)
Vector_int.__delslice__ = new_instancemethod(_geocal.Vector_int___delslice__,None,Vector_int)
Vector_int.__delitem__ = new_instancemethod(_geocal.Vector_int___delitem__,None,Vector_int)
Vector_int.__getitem__ = new_instancemethod(_geocal.Vector_int___getitem__,None,Vector_int)
Vector_int.__setitem__ = new_instancemethod(_geocal.Vector_int___setitem__,None,Vector_int)
Vector_int.append = new_instancemethod(_geocal.Vector_int_append,None,Vector_int)
Vector_int.empty = new_instancemethod(_geocal.Vector_int_empty,None,Vector_int)
Vector_int.size = new_instancemethod(_geocal.Vector_int_size,None,Vector_int)
Vector_int.clear = new_instancemethod(_geocal.Vector_int_clear,None,Vector_int)
Vector_int.swap = new_instancemethod(_geocal.Vector_int_swap,None,Vector_int)
Vector_int.get_allocator = new_instancemethod(_geocal.Vector_int_get_allocator,None,Vector_int)
Vector_int.begin = new_instancemethod(_geocal.Vector_int_begin,None,Vector_int)
Vector_int.end = new_instancemethod(_geocal.Vector_int_end,None,Vector_int)
Vector_int.rbegin = new_instancemethod(_geocal.Vector_int_rbegin,None,Vector_int)
Vector_int.rend = new_instancemethod(_geocal.Vector_int_rend,None,Vector_int)
Vector_int.pop_back = new_instancemethod(_geocal.Vector_int_pop_back,None,Vector_int)
Vector_int.erase = new_instancemethod(_geocal.Vector_int_erase,None,Vector_int)
Vector_int.push_back = new_instancemethod(_geocal.Vector_int_push_back,None,Vector_int)
Vector_int.front = new_instancemethod(_geocal.Vector_int_front,None,Vector_int)
Vector_int.back = new_instancemethod(_geocal.Vector_int_back,None,Vector_int)
Vector_int.assign = new_instancemethod(_geocal.Vector_int_assign,None,Vector_int)
Vector_int.resize = new_instancemethod(_geocal.Vector_int_resize,None,Vector_int)
Vector_int.insert = new_instancemethod(_geocal.Vector_int_insert,None,Vector_int)
Vector_int.reserve = new_instancemethod(_geocal.Vector_int_reserve,None,Vector_int)
Vector_int.capacity = new_instancemethod(_geocal.Vector_int_capacity,None,Vector_int)
Vector_int_swigregister = _geocal.Vector_int_swigregister
Vector_int_swigregister(Vector_int)

class Vector_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_float_swiginit(self,_geocal.new_Vector_float(*args))
    __swig_destroy__ = _geocal.delete_Vector_float
Vector_float.iterator = new_instancemethod(_geocal.Vector_float_iterator,None,Vector_float)
Vector_float.__nonzero__ = new_instancemethod(_geocal.Vector_float___nonzero__,None,Vector_float)
Vector_float.__bool__ = new_instancemethod(_geocal.Vector_float___bool__,None,Vector_float)
Vector_float.__len__ = new_instancemethod(_geocal.Vector_float___len__,None,Vector_float)
Vector_float.pop = new_instancemethod(_geocal.Vector_float_pop,None,Vector_float)
Vector_float.__getslice__ = new_instancemethod(_geocal.Vector_float___getslice__,None,Vector_float)
Vector_float.__setslice__ = new_instancemethod(_geocal.Vector_float___setslice__,None,Vector_float)
Vector_float.__delslice__ = new_instancemethod(_geocal.Vector_float___delslice__,None,Vector_float)
Vector_float.__delitem__ = new_instancemethod(_geocal.Vector_float___delitem__,None,Vector_float)
Vector_float.__getitem__ = new_instancemethod(_geocal.Vector_float___getitem__,None,Vector_float)
Vector_float.__setitem__ = new_instancemethod(_geocal.Vector_float___setitem__,None,Vector_float)
Vector_float.append = new_instancemethod(_geocal.Vector_float_append,None,Vector_float)
Vector_float.empty = new_instancemethod(_geocal.Vector_float_empty,None,Vector_float)
Vector_float.size = new_instancemethod(_geocal.Vector_float_size,None,Vector_float)
Vector_float.clear = new_instancemethod(_geocal.Vector_float_clear,None,Vector_float)
Vector_float.swap = new_instancemethod(_geocal.Vector_float_swap,None,Vector_float)
Vector_float.get_allocator = new_instancemethod(_geocal.Vector_float_get_allocator,None,Vector_float)
Vector_float.begin = new_instancemethod(_geocal.Vector_float_begin,None,Vector_float)
Vector_float.end = new_instancemethod(_geocal.Vector_float_end,None,Vector_float)
Vector_float.rbegin = new_instancemethod(_geocal.Vector_float_rbegin,None,Vector_float)
Vector_float.rend = new_instancemethod(_geocal.Vector_float_rend,None,Vector_float)
Vector_float.pop_back = new_instancemethod(_geocal.Vector_float_pop_back,None,Vector_float)
Vector_float.erase = new_instancemethod(_geocal.Vector_float_erase,None,Vector_float)
Vector_float.push_back = new_instancemethod(_geocal.Vector_float_push_back,None,Vector_float)
Vector_float.front = new_instancemethod(_geocal.Vector_float_front,None,Vector_float)
Vector_float.back = new_instancemethod(_geocal.Vector_float_back,None,Vector_float)
Vector_float.assign = new_instancemethod(_geocal.Vector_float_assign,None,Vector_float)
Vector_float.resize = new_instancemethod(_geocal.Vector_float_resize,None,Vector_float)
Vector_float.insert = new_instancemethod(_geocal.Vector_float_insert,None,Vector_float)
Vector_float.reserve = new_instancemethod(_geocal.Vector_float_reserve,None,Vector_float)
Vector_float.capacity = new_instancemethod(_geocal.Vector_float_capacity,None,Vector_float)
Vector_float_swigregister = _geocal.Vector_float_swigregister
Vector_float_swigregister(Vector_float)


def cdata(*args):
  return _geocal.cdata(*args)
cdata = _geocal.cdata

def memmove(*args):
  return _geocal.memmove(*args)
memmove = _geocal.memmove
fromStart = _geocal.fromStart
toEnd = _geocal.toEnd
class Range(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.Range_swiginit(self,_geocal.new_Range(*args))
    all = staticmethod(_geocal.Range_all)
    __swig_destroy__ = _geocal.delete_Range
Range.first = new_instancemethod(_geocal.Range_first,None,Range)
Range.last = new_instancemethod(_geocal.Range_last,None,Range)
Range.length = new_instancemethod(_geocal.Range_length,None,Range)
Range.stride = new_instancemethod(_geocal.Range_stride,None,Range)
Range.isAscendingContiguous = new_instancemethod(_geocal.Range_isAscendingContiguous,None,Range)
Range.setRange = new_instancemethod(_geocal.Range_setRange,None,Range)
Range.isUnitStride = new_instancemethod(_geocal.Range_isUnitStride,None,Range)
Range_swigregister = _geocal.Range_swigregister
Range_swigregister(Range)

def Range_all():
  return _geocal.Range_all()
Range_all = _geocal.Range_all

class BlitzArray_double_1(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_double_1_swiginit(self,_geocal.new_BlitzArray_double_1(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_double_1
BlitzArray_double_1.data = new_instancemethod(_geocal.BlitzArray_double_1_data,None,BlitzArray_double_1)
BlitzArray_double_1.size = new_instancemethod(_geocal.BlitzArray_double_1_size,None,BlitzArray_double_1)
BlitzArray_double_1.read = new_instancemethod(_geocal.BlitzArray_double_1_read,None,BlitzArray_double_1)
BlitzArray_double_1.write = new_instancemethod(_geocal.BlitzArray_double_1_write,None,BlitzArray_double_1)
BlitzArray_double_1.datav = new_instancemethod(_geocal.BlitzArray_double_1_datav,None,BlitzArray_double_1)
BlitzArray_double_1.shape0 = new_instancemethod(_geocal.BlitzArray_double_1_shape0,None,BlitzArray_double_1)
BlitzArray_double_1.shape1 = new_instancemethod(_geocal.BlitzArray_double_1_shape1,None,BlitzArray_double_1)
BlitzArray_double_1.shape2 = new_instancemethod(_geocal.BlitzArray_double_1_shape2,None,BlitzArray_double_1)
BlitzArray_double_1.shape3 = new_instancemethod(_geocal.BlitzArray_double_1_shape3,None,BlitzArray_double_1)
BlitzArray_double_1_swigregister = _geocal.BlitzArray_double_1_swigregister
BlitzArray_double_1_swigregister(BlitzArray_double_1)

class BlitzArray_double_2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_double_2_swiginit(self,_geocal.new_BlitzArray_double_2(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_double_2
BlitzArray_double_2.data = new_instancemethod(_geocal.BlitzArray_double_2_data,None,BlitzArray_double_2)
BlitzArray_double_2.size = new_instancemethod(_geocal.BlitzArray_double_2_size,None,BlitzArray_double_2)
BlitzArray_double_2.read = new_instancemethod(_geocal.BlitzArray_double_2_read,None,BlitzArray_double_2)
BlitzArray_double_2.write = new_instancemethod(_geocal.BlitzArray_double_2_write,None,BlitzArray_double_2)
BlitzArray_double_2.datav = new_instancemethod(_geocal.BlitzArray_double_2_datav,None,BlitzArray_double_2)
BlitzArray_double_2.shape0 = new_instancemethod(_geocal.BlitzArray_double_2_shape0,None,BlitzArray_double_2)
BlitzArray_double_2.shape1 = new_instancemethod(_geocal.BlitzArray_double_2_shape1,None,BlitzArray_double_2)
BlitzArray_double_2.shape2 = new_instancemethod(_geocal.BlitzArray_double_2_shape2,None,BlitzArray_double_2)
BlitzArray_double_2.shape3 = new_instancemethod(_geocal.BlitzArray_double_2_shape3,None,BlitzArray_double_2)
BlitzArray_double_2_swigregister = _geocal.BlitzArray_double_2_swigregister
BlitzArray_double_2_swigregister(BlitzArray_double_2)

class BlitzArray_double_3(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_double_3_swiginit(self,_geocal.new_BlitzArray_double_3(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_double_3
BlitzArray_double_3.data = new_instancemethod(_geocal.BlitzArray_double_3_data,None,BlitzArray_double_3)
BlitzArray_double_3.size = new_instancemethod(_geocal.BlitzArray_double_3_size,None,BlitzArray_double_3)
BlitzArray_double_3.read = new_instancemethod(_geocal.BlitzArray_double_3_read,None,BlitzArray_double_3)
BlitzArray_double_3.write = new_instancemethod(_geocal.BlitzArray_double_3_write,None,BlitzArray_double_3)
BlitzArray_double_3.datav = new_instancemethod(_geocal.BlitzArray_double_3_datav,None,BlitzArray_double_3)
BlitzArray_double_3.shape0 = new_instancemethod(_geocal.BlitzArray_double_3_shape0,None,BlitzArray_double_3)
BlitzArray_double_3.shape1 = new_instancemethod(_geocal.BlitzArray_double_3_shape1,None,BlitzArray_double_3)
BlitzArray_double_3.shape2 = new_instancemethod(_geocal.BlitzArray_double_3_shape2,None,BlitzArray_double_3)
BlitzArray_double_3.shape3 = new_instancemethod(_geocal.BlitzArray_double_3_shape3,None,BlitzArray_double_3)
BlitzArray_double_3_swigregister = _geocal.BlitzArray_double_3_swigregister
BlitzArray_double_3_swigregister(BlitzArray_double_3)

class BlitzArray_double_4(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_double_4_swiginit(self,_geocal.new_BlitzArray_double_4(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_double_4
BlitzArray_double_4.data = new_instancemethod(_geocal.BlitzArray_double_4_data,None,BlitzArray_double_4)
BlitzArray_double_4.size = new_instancemethod(_geocal.BlitzArray_double_4_size,None,BlitzArray_double_4)
BlitzArray_double_4.read = new_instancemethod(_geocal.BlitzArray_double_4_read,None,BlitzArray_double_4)
BlitzArray_double_4.write = new_instancemethod(_geocal.BlitzArray_double_4_write,None,BlitzArray_double_4)
BlitzArray_double_4.datav = new_instancemethod(_geocal.BlitzArray_double_4_datav,None,BlitzArray_double_4)
BlitzArray_double_4.shape0 = new_instancemethod(_geocal.BlitzArray_double_4_shape0,None,BlitzArray_double_4)
BlitzArray_double_4.shape1 = new_instancemethod(_geocal.BlitzArray_double_4_shape1,None,BlitzArray_double_4)
BlitzArray_double_4.shape2 = new_instancemethod(_geocal.BlitzArray_double_4_shape2,None,BlitzArray_double_4)
BlitzArray_double_4.shape3 = new_instancemethod(_geocal.BlitzArray_double_4_shape3,None,BlitzArray_double_4)
BlitzArray_double_4_swigregister = _geocal.BlitzArray_double_4_swigregister
BlitzArray_double_4_swigregister(BlitzArray_double_4)

class BlitzArray_bool_1(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_bool_1_swiginit(self,_geocal.new_BlitzArray_bool_1(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_bool_1
BlitzArray_bool_1.data = new_instancemethod(_geocal.BlitzArray_bool_1_data,None,BlitzArray_bool_1)
BlitzArray_bool_1.size = new_instancemethod(_geocal.BlitzArray_bool_1_size,None,BlitzArray_bool_1)
BlitzArray_bool_1.read = new_instancemethod(_geocal.BlitzArray_bool_1_read,None,BlitzArray_bool_1)
BlitzArray_bool_1.write = new_instancemethod(_geocal.BlitzArray_bool_1_write,None,BlitzArray_bool_1)
BlitzArray_bool_1.datav = new_instancemethod(_geocal.BlitzArray_bool_1_datav,None,BlitzArray_bool_1)
BlitzArray_bool_1.shape0 = new_instancemethod(_geocal.BlitzArray_bool_1_shape0,None,BlitzArray_bool_1)
BlitzArray_bool_1.shape1 = new_instancemethod(_geocal.BlitzArray_bool_1_shape1,None,BlitzArray_bool_1)
BlitzArray_bool_1.shape2 = new_instancemethod(_geocal.BlitzArray_bool_1_shape2,None,BlitzArray_bool_1)
BlitzArray_bool_1.shape3 = new_instancemethod(_geocal.BlitzArray_bool_1_shape3,None,BlitzArray_bool_1)
BlitzArray_bool_1_swigregister = _geocal.BlitzArray_bool_1_swigregister
BlitzArray_bool_1_swigregister(BlitzArray_bool_1)

class BlitzArray_bool_2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_bool_2_swiginit(self,_geocal.new_BlitzArray_bool_2(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_bool_2
BlitzArray_bool_2.data = new_instancemethod(_geocal.BlitzArray_bool_2_data,None,BlitzArray_bool_2)
BlitzArray_bool_2.size = new_instancemethod(_geocal.BlitzArray_bool_2_size,None,BlitzArray_bool_2)
BlitzArray_bool_2.read = new_instancemethod(_geocal.BlitzArray_bool_2_read,None,BlitzArray_bool_2)
BlitzArray_bool_2.write = new_instancemethod(_geocal.BlitzArray_bool_2_write,None,BlitzArray_bool_2)
BlitzArray_bool_2.datav = new_instancemethod(_geocal.BlitzArray_bool_2_datav,None,BlitzArray_bool_2)
BlitzArray_bool_2.shape0 = new_instancemethod(_geocal.BlitzArray_bool_2_shape0,None,BlitzArray_bool_2)
BlitzArray_bool_2.shape1 = new_instancemethod(_geocal.BlitzArray_bool_2_shape1,None,BlitzArray_bool_2)
BlitzArray_bool_2.shape2 = new_instancemethod(_geocal.BlitzArray_bool_2_shape2,None,BlitzArray_bool_2)
BlitzArray_bool_2.shape3 = new_instancemethod(_geocal.BlitzArray_bool_2_shape3,None,BlitzArray_bool_2)
BlitzArray_bool_2_swigregister = _geocal.BlitzArray_bool_2_swigregister
BlitzArray_bool_2_swigregister(BlitzArray_bool_2)

class BlitzArray_bool_3(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_bool_3_swiginit(self,_geocal.new_BlitzArray_bool_3(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_bool_3
BlitzArray_bool_3.data = new_instancemethod(_geocal.BlitzArray_bool_3_data,None,BlitzArray_bool_3)
BlitzArray_bool_3.size = new_instancemethod(_geocal.BlitzArray_bool_3_size,None,BlitzArray_bool_3)
BlitzArray_bool_3.read = new_instancemethod(_geocal.BlitzArray_bool_3_read,None,BlitzArray_bool_3)
BlitzArray_bool_3.write = new_instancemethod(_geocal.BlitzArray_bool_3_write,None,BlitzArray_bool_3)
BlitzArray_bool_3.datav = new_instancemethod(_geocal.BlitzArray_bool_3_datav,None,BlitzArray_bool_3)
BlitzArray_bool_3.shape0 = new_instancemethod(_geocal.BlitzArray_bool_3_shape0,None,BlitzArray_bool_3)
BlitzArray_bool_3.shape1 = new_instancemethod(_geocal.BlitzArray_bool_3_shape1,None,BlitzArray_bool_3)
BlitzArray_bool_3.shape2 = new_instancemethod(_geocal.BlitzArray_bool_3_shape2,None,BlitzArray_bool_3)
BlitzArray_bool_3.shape3 = new_instancemethod(_geocal.BlitzArray_bool_3_shape3,None,BlitzArray_bool_3)
BlitzArray_bool_3_swigregister = _geocal.BlitzArray_bool_3_swigregister
BlitzArray_bool_3_swigregister(BlitzArray_bool_3)

class BlitzArray_bool_4(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_bool_4_swiginit(self,_geocal.new_BlitzArray_bool_4(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_bool_4
BlitzArray_bool_4.data = new_instancemethod(_geocal.BlitzArray_bool_4_data,None,BlitzArray_bool_4)
BlitzArray_bool_4.size = new_instancemethod(_geocal.BlitzArray_bool_4_size,None,BlitzArray_bool_4)
BlitzArray_bool_4.read = new_instancemethod(_geocal.BlitzArray_bool_4_read,None,BlitzArray_bool_4)
BlitzArray_bool_4.write = new_instancemethod(_geocal.BlitzArray_bool_4_write,None,BlitzArray_bool_4)
BlitzArray_bool_4.datav = new_instancemethod(_geocal.BlitzArray_bool_4_datav,None,BlitzArray_bool_4)
BlitzArray_bool_4.shape0 = new_instancemethod(_geocal.BlitzArray_bool_4_shape0,None,BlitzArray_bool_4)
BlitzArray_bool_4.shape1 = new_instancemethod(_geocal.BlitzArray_bool_4_shape1,None,BlitzArray_bool_4)
BlitzArray_bool_4.shape2 = new_instancemethod(_geocal.BlitzArray_bool_4_shape2,None,BlitzArray_bool_4)
BlitzArray_bool_4.shape3 = new_instancemethod(_geocal.BlitzArray_bool_4_shape3,None,BlitzArray_bool_4)
BlitzArray_bool_4_swigregister = _geocal.BlitzArray_bool_4_swigregister
BlitzArray_bool_4_swigregister(BlitzArray_bool_4)

class BlitzArray_float_1(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_float_1_swiginit(self,_geocal.new_BlitzArray_float_1(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_float_1
BlitzArray_float_1.data = new_instancemethod(_geocal.BlitzArray_float_1_data,None,BlitzArray_float_1)
BlitzArray_float_1.size = new_instancemethod(_geocal.BlitzArray_float_1_size,None,BlitzArray_float_1)
BlitzArray_float_1.read = new_instancemethod(_geocal.BlitzArray_float_1_read,None,BlitzArray_float_1)
BlitzArray_float_1.write = new_instancemethod(_geocal.BlitzArray_float_1_write,None,BlitzArray_float_1)
BlitzArray_float_1.datav = new_instancemethod(_geocal.BlitzArray_float_1_datav,None,BlitzArray_float_1)
BlitzArray_float_1.shape0 = new_instancemethod(_geocal.BlitzArray_float_1_shape0,None,BlitzArray_float_1)
BlitzArray_float_1.shape1 = new_instancemethod(_geocal.BlitzArray_float_1_shape1,None,BlitzArray_float_1)
BlitzArray_float_1.shape2 = new_instancemethod(_geocal.BlitzArray_float_1_shape2,None,BlitzArray_float_1)
BlitzArray_float_1.shape3 = new_instancemethod(_geocal.BlitzArray_float_1_shape3,None,BlitzArray_float_1)
BlitzArray_float_1_swigregister = _geocal.BlitzArray_float_1_swigregister
BlitzArray_float_1_swigregister(BlitzArray_float_1)

class BlitzArray_float_2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_float_2_swiginit(self,_geocal.new_BlitzArray_float_2(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_float_2
BlitzArray_float_2.data = new_instancemethod(_geocal.BlitzArray_float_2_data,None,BlitzArray_float_2)
BlitzArray_float_2.size = new_instancemethod(_geocal.BlitzArray_float_2_size,None,BlitzArray_float_2)
BlitzArray_float_2.read = new_instancemethod(_geocal.BlitzArray_float_2_read,None,BlitzArray_float_2)
BlitzArray_float_2.write = new_instancemethod(_geocal.BlitzArray_float_2_write,None,BlitzArray_float_2)
BlitzArray_float_2.datav = new_instancemethod(_geocal.BlitzArray_float_2_datav,None,BlitzArray_float_2)
BlitzArray_float_2.shape0 = new_instancemethod(_geocal.BlitzArray_float_2_shape0,None,BlitzArray_float_2)
BlitzArray_float_2.shape1 = new_instancemethod(_geocal.BlitzArray_float_2_shape1,None,BlitzArray_float_2)
BlitzArray_float_2.shape2 = new_instancemethod(_geocal.BlitzArray_float_2_shape2,None,BlitzArray_float_2)
BlitzArray_float_2.shape3 = new_instancemethod(_geocal.BlitzArray_float_2_shape3,None,BlitzArray_float_2)
BlitzArray_float_2_swigregister = _geocal.BlitzArray_float_2_swigregister
BlitzArray_float_2_swigregister(BlitzArray_float_2)

class BlitzArray_float_3(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_float_3_swiginit(self,_geocal.new_BlitzArray_float_3(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_float_3
BlitzArray_float_3.data = new_instancemethod(_geocal.BlitzArray_float_3_data,None,BlitzArray_float_3)
BlitzArray_float_3.size = new_instancemethod(_geocal.BlitzArray_float_3_size,None,BlitzArray_float_3)
BlitzArray_float_3.read = new_instancemethod(_geocal.BlitzArray_float_3_read,None,BlitzArray_float_3)
BlitzArray_float_3.write = new_instancemethod(_geocal.BlitzArray_float_3_write,None,BlitzArray_float_3)
BlitzArray_float_3.datav = new_instancemethod(_geocal.BlitzArray_float_3_datav,None,BlitzArray_float_3)
BlitzArray_float_3.shape0 = new_instancemethod(_geocal.BlitzArray_float_3_shape0,None,BlitzArray_float_3)
BlitzArray_float_3.shape1 = new_instancemethod(_geocal.BlitzArray_float_3_shape1,None,BlitzArray_float_3)
BlitzArray_float_3.shape2 = new_instancemethod(_geocal.BlitzArray_float_3_shape2,None,BlitzArray_float_3)
BlitzArray_float_3.shape3 = new_instancemethod(_geocal.BlitzArray_float_3_shape3,None,BlitzArray_float_3)
BlitzArray_float_3_swigregister = _geocal.BlitzArray_float_3_swigregister
BlitzArray_float_3_swigregister(BlitzArray_float_3)

class BlitzArray_float_4(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_float_4_swiginit(self,_geocal.new_BlitzArray_float_4(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_float_4
BlitzArray_float_4.data = new_instancemethod(_geocal.BlitzArray_float_4_data,None,BlitzArray_float_4)
BlitzArray_float_4.size = new_instancemethod(_geocal.BlitzArray_float_4_size,None,BlitzArray_float_4)
BlitzArray_float_4.read = new_instancemethod(_geocal.BlitzArray_float_4_read,None,BlitzArray_float_4)
BlitzArray_float_4.write = new_instancemethod(_geocal.BlitzArray_float_4_write,None,BlitzArray_float_4)
BlitzArray_float_4.datav = new_instancemethod(_geocal.BlitzArray_float_4_datav,None,BlitzArray_float_4)
BlitzArray_float_4.shape0 = new_instancemethod(_geocal.BlitzArray_float_4_shape0,None,BlitzArray_float_4)
BlitzArray_float_4.shape1 = new_instancemethod(_geocal.BlitzArray_float_4_shape1,None,BlitzArray_float_4)
BlitzArray_float_4.shape2 = new_instancemethod(_geocal.BlitzArray_float_4_shape2,None,BlitzArray_float_4)
BlitzArray_float_4.shape3 = new_instancemethod(_geocal.BlitzArray_float_4_shape3,None,BlitzArray_float_4)
BlitzArray_float_4_swigregister = _geocal.BlitzArray_float_4_swigregister
BlitzArray_float_4_swigregister(BlitzArray_float_4)

class BlitzArray_int_1(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_int_1_swiginit(self,_geocal.new_BlitzArray_int_1(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_int_1
BlitzArray_int_1.data = new_instancemethod(_geocal.BlitzArray_int_1_data,None,BlitzArray_int_1)
BlitzArray_int_1.size = new_instancemethod(_geocal.BlitzArray_int_1_size,None,BlitzArray_int_1)
BlitzArray_int_1.read = new_instancemethod(_geocal.BlitzArray_int_1_read,None,BlitzArray_int_1)
BlitzArray_int_1.write = new_instancemethod(_geocal.BlitzArray_int_1_write,None,BlitzArray_int_1)
BlitzArray_int_1.datav = new_instancemethod(_geocal.BlitzArray_int_1_datav,None,BlitzArray_int_1)
BlitzArray_int_1.shape0 = new_instancemethod(_geocal.BlitzArray_int_1_shape0,None,BlitzArray_int_1)
BlitzArray_int_1.shape1 = new_instancemethod(_geocal.BlitzArray_int_1_shape1,None,BlitzArray_int_1)
BlitzArray_int_1.shape2 = new_instancemethod(_geocal.BlitzArray_int_1_shape2,None,BlitzArray_int_1)
BlitzArray_int_1.shape3 = new_instancemethod(_geocal.BlitzArray_int_1_shape3,None,BlitzArray_int_1)
BlitzArray_int_1_swigregister = _geocal.BlitzArray_int_1_swigregister
BlitzArray_int_1_swigregister(BlitzArray_int_1)

class BlitzArray_int_2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_int_2_swiginit(self,_geocal.new_BlitzArray_int_2(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_int_2
BlitzArray_int_2.data = new_instancemethod(_geocal.BlitzArray_int_2_data,None,BlitzArray_int_2)
BlitzArray_int_2.size = new_instancemethod(_geocal.BlitzArray_int_2_size,None,BlitzArray_int_2)
BlitzArray_int_2.read = new_instancemethod(_geocal.BlitzArray_int_2_read,None,BlitzArray_int_2)
BlitzArray_int_2.write = new_instancemethod(_geocal.BlitzArray_int_2_write,None,BlitzArray_int_2)
BlitzArray_int_2.datav = new_instancemethod(_geocal.BlitzArray_int_2_datav,None,BlitzArray_int_2)
BlitzArray_int_2.shape0 = new_instancemethod(_geocal.BlitzArray_int_2_shape0,None,BlitzArray_int_2)
BlitzArray_int_2.shape1 = new_instancemethod(_geocal.BlitzArray_int_2_shape1,None,BlitzArray_int_2)
BlitzArray_int_2.shape2 = new_instancemethod(_geocal.BlitzArray_int_2_shape2,None,BlitzArray_int_2)
BlitzArray_int_2.shape3 = new_instancemethod(_geocal.BlitzArray_int_2_shape3,None,BlitzArray_int_2)
BlitzArray_int_2_swigregister = _geocal.BlitzArray_int_2_swigregister
BlitzArray_int_2_swigregister(BlitzArray_int_2)

class BlitzArray_int_3(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_int_3_swiginit(self,_geocal.new_BlitzArray_int_3(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_int_3
BlitzArray_int_3.data = new_instancemethod(_geocal.BlitzArray_int_3_data,None,BlitzArray_int_3)
BlitzArray_int_3.size = new_instancemethod(_geocal.BlitzArray_int_3_size,None,BlitzArray_int_3)
BlitzArray_int_3.read = new_instancemethod(_geocal.BlitzArray_int_3_read,None,BlitzArray_int_3)
BlitzArray_int_3.write = new_instancemethod(_geocal.BlitzArray_int_3_write,None,BlitzArray_int_3)
BlitzArray_int_3.datav = new_instancemethod(_geocal.BlitzArray_int_3_datav,None,BlitzArray_int_3)
BlitzArray_int_3.shape0 = new_instancemethod(_geocal.BlitzArray_int_3_shape0,None,BlitzArray_int_3)
BlitzArray_int_3.shape1 = new_instancemethod(_geocal.BlitzArray_int_3_shape1,None,BlitzArray_int_3)
BlitzArray_int_3.shape2 = new_instancemethod(_geocal.BlitzArray_int_3_shape2,None,BlitzArray_int_3)
BlitzArray_int_3.shape3 = new_instancemethod(_geocal.BlitzArray_int_3_shape3,None,BlitzArray_int_3)
BlitzArray_int_3_swigregister = _geocal.BlitzArray_int_3_swigregister
BlitzArray_int_3_swigregister(BlitzArray_int_3)

class BlitzArray_int_4(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_int_4_swiginit(self,_geocal.new_BlitzArray_int_4(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_int_4
BlitzArray_int_4.data = new_instancemethod(_geocal.BlitzArray_int_4_data,None,BlitzArray_int_4)
BlitzArray_int_4.size = new_instancemethod(_geocal.BlitzArray_int_4_size,None,BlitzArray_int_4)
BlitzArray_int_4.read = new_instancemethod(_geocal.BlitzArray_int_4_read,None,BlitzArray_int_4)
BlitzArray_int_4.write = new_instancemethod(_geocal.BlitzArray_int_4_write,None,BlitzArray_int_4)
BlitzArray_int_4.datav = new_instancemethod(_geocal.BlitzArray_int_4_datav,None,BlitzArray_int_4)
BlitzArray_int_4.shape0 = new_instancemethod(_geocal.BlitzArray_int_4_shape0,None,BlitzArray_int_4)
BlitzArray_int_4.shape1 = new_instancemethod(_geocal.BlitzArray_int_4_shape1,None,BlitzArray_int_4)
BlitzArray_int_4.shape2 = new_instancemethod(_geocal.BlitzArray_int_4_shape2,None,BlitzArray_int_4)
BlitzArray_int_4.shape3 = new_instancemethod(_geocal.BlitzArray_int_4_shape3,None,BlitzArray_int_4)
BlitzArray_int_4_swigregister = _geocal.BlitzArray_int_4_swigregister
BlitzArray_int_4_swigregister(BlitzArray_int_4)

class BlitzArray_short_1(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_short_1_swiginit(self,_geocal.new_BlitzArray_short_1(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_short_1
BlitzArray_short_1.data = new_instancemethod(_geocal.BlitzArray_short_1_data,None,BlitzArray_short_1)
BlitzArray_short_1.size = new_instancemethod(_geocal.BlitzArray_short_1_size,None,BlitzArray_short_1)
BlitzArray_short_1.read = new_instancemethod(_geocal.BlitzArray_short_1_read,None,BlitzArray_short_1)
BlitzArray_short_1.write = new_instancemethod(_geocal.BlitzArray_short_1_write,None,BlitzArray_short_1)
BlitzArray_short_1.datav = new_instancemethod(_geocal.BlitzArray_short_1_datav,None,BlitzArray_short_1)
BlitzArray_short_1.shape0 = new_instancemethod(_geocal.BlitzArray_short_1_shape0,None,BlitzArray_short_1)
BlitzArray_short_1.shape1 = new_instancemethod(_geocal.BlitzArray_short_1_shape1,None,BlitzArray_short_1)
BlitzArray_short_1.shape2 = new_instancemethod(_geocal.BlitzArray_short_1_shape2,None,BlitzArray_short_1)
BlitzArray_short_1.shape3 = new_instancemethod(_geocal.BlitzArray_short_1_shape3,None,BlitzArray_short_1)
BlitzArray_short_1_swigregister = _geocal.BlitzArray_short_1_swigregister
BlitzArray_short_1_swigregister(BlitzArray_short_1)

class BlitzArray_short_2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_short_2_swiginit(self,_geocal.new_BlitzArray_short_2(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_short_2
BlitzArray_short_2.data = new_instancemethod(_geocal.BlitzArray_short_2_data,None,BlitzArray_short_2)
BlitzArray_short_2.size = new_instancemethod(_geocal.BlitzArray_short_2_size,None,BlitzArray_short_2)
BlitzArray_short_2.read = new_instancemethod(_geocal.BlitzArray_short_2_read,None,BlitzArray_short_2)
BlitzArray_short_2.write = new_instancemethod(_geocal.BlitzArray_short_2_write,None,BlitzArray_short_2)
BlitzArray_short_2.datav = new_instancemethod(_geocal.BlitzArray_short_2_datav,None,BlitzArray_short_2)
BlitzArray_short_2.shape0 = new_instancemethod(_geocal.BlitzArray_short_2_shape0,None,BlitzArray_short_2)
BlitzArray_short_2.shape1 = new_instancemethod(_geocal.BlitzArray_short_2_shape1,None,BlitzArray_short_2)
BlitzArray_short_2.shape2 = new_instancemethod(_geocal.BlitzArray_short_2_shape2,None,BlitzArray_short_2)
BlitzArray_short_2.shape3 = new_instancemethod(_geocal.BlitzArray_short_2_shape3,None,BlitzArray_short_2)
BlitzArray_short_2_swigregister = _geocal.BlitzArray_short_2_swigregister
BlitzArray_short_2_swigregister(BlitzArray_short_2)

class BlitzArray_short_3(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_short_3_swiginit(self,_geocal.new_BlitzArray_short_3(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_short_3
BlitzArray_short_3.data = new_instancemethod(_geocal.BlitzArray_short_3_data,None,BlitzArray_short_3)
BlitzArray_short_3.size = new_instancemethod(_geocal.BlitzArray_short_3_size,None,BlitzArray_short_3)
BlitzArray_short_3.read = new_instancemethod(_geocal.BlitzArray_short_3_read,None,BlitzArray_short_3)
BlitzArray_short_3.write = new_instancemethod(_geocal.BlitzArray_short_3_write,None,BlitzArray_short_3)
BlitzArray_short_3.datav = new_instancemethod(_geocal.BlitzArray_short_3_datav,None,BlitzArray_short_3)
BlitzArray_short_3.shape0 = new_instancemethod(_geocal.BlitzArray_short_3_shape0,None,BlitzArray_short_3)
BlitzArray_short_3.shape1 = new_instancemethod(_geocal.BlitzArray_short_3_shape1,None,BlitzArray_short_3)
BlitzArray_short_3.shape2 = new_instancemethod(_geocal.BlitzArray_short_3_shape2,None,BlitzArray_short_3)
BlitzArray_short_3.shape3 = new_instancemethod(_geocal.BlitzArray_short_3_shape3,None,BlitzArray_short_3)
BlitzArray_short_3_swigregister = _geocal.BlitzArray_short_3_swigregister
BlitzArray_short_3_swigregister(BlitzArray_short_3)

class BlitzArray_short_4(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.BlitzArray_short_4_swiginit(self,_geocal.new_BlitzArray_short_4(*args))
    __swig_destroy__ = _geocal.delete_BlitzArray_short_4
BlitzArray_short_4.data = new_instancemethod(_geocal.BlitzArray_short_4_data,None,BlitzArray_short_4)
BlitzArray_short_4.size = new_instancemethod(_geocal.BlitzArray_short_4_size,None,BlitzArray_short_4)
BlitzArray_short_4.read = new_instancemethod(_geocal.BlitzArray_short_4_read,None,BlitzArray_short_4)
BlitzArray_short_4.write = new_instancemethod(_geocal.BlitzArray_short_4_write,None,BlitzArray_short_4)
BlitzArray_short_4.datav = new_instancemethod(_geocal.BlitzArray_short_4_datav,None,BlitzArray_short_4)
BlitzArray_short_4.shape0 = new_instancemethod(_geocal.BlitzArray_short_4_shape0,None,BlitzArray_short_4)
BlitzArray_short_4.shape1 = new_instancemethod(_geocal.BlitzArray_short_4_shape1,None,BlitzArray_short_4)
BlitzArray_short_4.shape2 = new_instancemethod(_geocal.BlitzArray_short_4_shape2,None,BlitzArray_short_4)
BlitzArray_short_4.shape3 = new_instancemethod(_geocal.BlitzArray_short_4_shape3,None,BlitzArray_short_4)
BlitzArray_short_4_swigregister = _geocal.BlitzArray_short_4_swigregister
BlitzArray_short_4_swigregister(BlitzArray_short_4)

class MultiArray_short_2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        _geocal.MultiArray_short_2_swiginit(self,_geocal.new_MultiArray_short_2())
    __swig_destroy__ = _geocal.delete_MultiArray_short_2
MultiArray_short_2.data = new_instancemethod(_geocal.MultiArray_short_2_data,None,MultiArray_short_2)
MultiArray_short_2.num_elements = new_instancemethod(_geocal.MultiArray_short_2_num_elements,None,MultiArray_short_2)
MultiArray_short_2.shape0 = new_instancemethod(_geocal.MultiArray_short_2_shape0,None,MultiArray_short_2)
MultiArray_short_2.shape1 = new_instancemethod(_geocal.MultiArray_short_2_shape1,None,MultiArray_short_2)
MultiArray_short_2.shape2 = new_instancemethod(_geocal.MultiArray_short_2_shape2,None,MultiArray_short_2)
MultiArray_short_2.shape3 = new_instancemethod(_geocal.MultiArray_short_2_shape3,None,MultiArray_short_2)
MultiArray_short_2_swigregister = _geocal.MultiArray_short_2_swigregister
MultiArray_short_2_swigregister(MultiArray_short_2)

class MultiArray_char_2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        _geocal.MultiArray_char_2_swiginit(self,_geocal.new_MultiArray_char_2())
    __swig_destroy__ = _geocal.delete_MultiArray_char_2
MultiArray_char_2.data = new_instancemethod(_geocal.MultiArray_char_2_data,None,MultiArray_char_2)
MultiArray_char_2.num_elements = new_instancemethod(_geocal.MultiArray_char_2_num_elements,None,MultiArray_char_2)
MultiArray_char_2.shape0 = new_instancemethod(_geocal.MultiArray_char_2_shape0,None,MultiArray_char_2)
MultiArray_char_2.shape1 = new_instancemethod(_geocal.MultiArray_char_2_shape1,None,MultiArray_char_2)
MultiArray_char_2.shape2 = new_instancemethod(_geocal.MultiArray_char_2_shape2,None,MultiArray_char_2)
MultiArray_char_2.shape3 = new_instancemethod(_geocal.MultiArray_char_2_shape3,None,MultiArray_char_2)
MultiArray_char_2_swigregister = _geocal.MultiArray_char_2_swigregister
MultiArray_char_2_swigregister(MultiArray_char_2)

class MultiArray_int_2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        _geocal.MultiArray_int_2_swiginit(self,_geocal.new_MultiArray_int_2())
    __swig_destroy__ = _geocal.delete_MultiArray_int_2
MultiArray_int_2.data = new_instancemethod(_geocal.MultiArray_int_2_data,None,MultiArray_int_2)
MultiArray_int_2.num_elements = new_instancemethod(_geocal.MultiArray_int_2_num_elements,None,MultiArray_int_2)
MultiArray_int_2.shape0 = new_instancemethod(_geocal.MultiArray_int_2_shape0,None,MultiArray_int_2)
MultiArray_int_2.shape1 = new_instancemethod(_geocal.MultiArray_int_2_shape1,None,MultiArray_int_2)
MultiArray_int_2.to_short = new_instancemethod(_geocal.MultiArray_int_2_to_short,None,MultiArray_int_2)
MultiArray_int_2.to_char = new_instancemethod(_geocal.MultiArray_int_2_to_char,None,MultiArray_int_2)
MultiArray_int_2_swigregister = _geocal.MultiArray_int_2_swigregister
MultiArray_int_2_swigregister(MultiArray_int_2)


def cdata_int(*args):
  return _geocal.cdata_int(*args)
cdata_int = _geocal.cdata_int

def cdata_double(*args):
  return _geocal.cdata_double(*args)
cdata_double = _geocal.cdata_double

def cdata_float(*args):
  return _geocal.cdata_float(*args)
cdata_float = _geocal.cdata_float

def cdata_short(*args):
  return _geocal.cdata_short(*args)
cdata_short = _geocal.cdata_short

def cdata_char(*args):
  return _geocal.cdata_char(*args)
cdata_char = _geocal.cdata_char
class Array_double_20(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    @property
    def size(self):
       return self._size()

    def set(self, v):
       '''Set the value to the given value. The value should be a container
       that we can enumerate over to fill in the value of the array'''
       for i, t in enumerate(v):
          if(i >= self.size):
              raise RuntimeError("Value must be exactly %d in size" % self.size)
          self[i] = t
       if(i != self.size - 1):
           raise RuntimeError("Value must be exactly %d in size" % self.size)

    def __iter__(self):
       for i in range(self.size):
           yield self[i]

    def __reduce__(self):
       return _new_from_set, (self.__class__, list(self))

    def __init__(self): 
        _geocal.Array_double_20_swiginit(self,_geocal.new_Array_double_20())
    __swig_destroy__ = _geocal.delete_Array_double_20
Array_double_20._size = new_instancemethod(_geocal.Array_double_20__size,None,Array_double_20)
Array_double_20.__getitem__ = new_instancemethod(_geocal.Array_double_20___getitem__,None,Array_double_20)
Array_double_20.__setitem__ = new_instancemethod(_geocal.Array_double_20___setitem__,None,Array_double_20)
Array_double_20.__str__ = new_instancemethod(_geocal.Array_double_20___str__,None,Array_double_20)
Array_double_20_swigregister = _geocal.Array_double_20_swigregister
Array_double_20_swigregister(Array_double_20)

class Array_double_12(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    @property
    def size(self):
       return self._size()

    def set(self, v):
       '''Set the value to the given value. The value should be a container
       that we can enumerate over to fill in the value of the array'''
       for i, t in enumerate(v):
          if(i >= self.size):
              raise RuntimeError("Value must be exactly %d in size" % self.size)
          self[i] = t
       if(i != self.size - 1):
           raise RuntimeError("Value must be exactly %d in size" % self.size)

    def __iter__(self):
       for i in range(self.size):
           yield self[i]

    def __reduce__(self):
       return _new_from_set, (self.__class__, list(self))

    def __init__(self): 
        _geocal.Array_double_12_swiginit(self,_geocal.new_Array_double_12())
    __swig_destroy__ = _geocal.delete_Array_double_12
Array_double_12._size = new_instancemethod(_geocal.Array_double_12__size,None,Array_double_12)
Array_double_12.__getitem__ = new_instancemethod(_geocal.Array_double_12___getitem__,None,Array_double_12)
Array_double_12.__setitem__ = new_instancemethod(_geocal.Array_double_12___setitem__,None,Array_double_12)
Array_double_12.__str__ = new_instancemethod(_geocal.Array_double_12___str__,None,Array_double_12)
Array_double_12_swigregister = _geocal.Array_double_12_swigregister
Array_double_12_swigregister(Array_double_12)

class Array_double_14(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    @property
    def size(self):
       return self._size()

    def set(self, v):
       '''Set the value to the given value. The value should be a container
       that we can enumerate over to fill in the value of the array'''
       for i, t in enumerate(v):
          if(i >= self.size):
              raise RuntimeError("Value must be exactly %d in size" % self.size)
          self[i] = t
       if(i != self.size - 1):
           raise RuntimeError("Value must be exactly %d in size" % self.size)

    def __iter__(self):
       for i in range(self.size):
           yield self[i]

    def __reduce__(self):
       return _new_from_set, (self.__class__, list(self))

    def __init__(self): 
        _geocal.Array_double_14_swiginit(self,_geocal.new_Array_double_14())
    __swig_destroy__ = _geocal.delete_Array_double_14
Array_double_14._size = new_instancemethod(_geocal.Array_double_14__size,None,Array_double_14)
Array_double_14.__getitem__ = new_instancemethod(_geocal.Array_double_14___getitem__,None,Array_double_14)
Array_double_14.__setitem__ = new_instancemethod(_geocal.Array_double_14___setitem__,None,Array_double_14)
Array_double_14.__str__ = new_instancemethod(_geocal.Array_double_14___str__,None,Array_double_14)
Array_double_14_swigregister = _geocal.Array_double_14_swigregister
Array_double_14_swigregister(Array_double_14)

class Array_double_3(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    @property
    def size(self):
       return self._size()

    def set(self, v):
       '''Set the value to the given value. The value should be a container
       that we can enumerate over to fill in the value of the array'''
       for i, t in enumerate(v):
          if(i >= self.size):
              raise RuntimeError("Value must be exactly %d in size" % self.size)
          self[i] = t
       if(i != self.size - 1):
           raise RuntimeError("Value must be exactly %d in size" % self.size)

    def __iter__(self):
       for i in range(self.size):
           yield self[i]

    def __reduce__(self):
       return _new_from_set, (self.__class__, list(self))

    def __init__(self): 
        _geocal.Array_double_3_swiginit(self,_geocal.new_Array_double_3())
    __swig_destroy__ = _geocal.delete_Array_double_3
Array_double_3._size = new_instancemethod(_geocal.Array_double_3__size,None,Array_double_3)
Array_double_3.__getitem__ = new_instancemethod(_geocal.Array_double_3___getitem__,None,Array_double_3)
Array_double_3.__setitem__ = new_instancemethod(_geocal.Array_double_3___setitem__,None,Array_double_3)
Array_double_3.__str__ = new_instancemethod(_geocal.Array_double_3___str__,None,Array_double_3)
Array_double_3_swigregister = _geocal.Array_double_3_swigregister
Array_double_3_swigregister(Array_double_3)

class Array_bool_20(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    @property
    def size(self):
       return self._size()

    def set(self, v):
       '''Set the value to the given value. The value should be a container
       that we can enumerate over to fill in the value of the array'''
       for i, t in enumerate(v):
          if(i >= self.size):
              raise RuntimeError("Value must be exactly %d in size" % self.size)
          self[i] = t
       if(i != self.size - 1):
           raise RuntimeError("Value must be exactly %d in size" % self.size)

    def __iter__(self):
       for i in range(self.size):
           yield self[i]

    def __reduce__(self):
       return _new_from_set, (self.__class__, list(self))

    def __init__(self): 
        _geocal.Array_bool_20_swiginit(self,_geocal.new_Array_bool_20())
    __swig_destroy__ = _geocal.delete_Array_bool_20
Array_bool_20._size = new_instancemethod(_geocal.Array_bool_20__size,None,Array_bool_20)
Array_bool_20.__getitem__ = new_instancemethod(_geocal.Array_bool_20___getitem__,None,Array_bool_20)
Array_bool_20.__setitem__ = new_instancemethod(_geocal.Array_bool_20___setitem__,None,Array_bool_20)
Array_bool_20.__str__ = new_instancemethod(_geocal.Array_bool_20___str__,None,Array_bool_20)
Array_bool_20_swigregister = _geocal.Array_bool_20_swigregister
Array_bool_20_swigregister(Array_bool_20)

class Vector_Array_double_12(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_Array_double_12_swiginit(self,_geocal.new_Vector_Array_double_12(*args))
    __swig_destroy__ = _geocal.delete_Vector_Array_double_12
Vector_Array_double_12.iterator = new_instancemethod(_geocal.Vector_Array_double_12_iterator,None,Vector_Array_double_12)
Vector_Array_double_12.__nonzero__ = new_instancemethod(_geocal.Vector_Array_double_12___nonzero__,None,Vector_Array_double_12)
Vector_Array_double_12.__bool__ = new_instancemethod(_geocal.Vector_Array_double_12___bool__,None,Vector_Array_double_12)
Vector_Array_double_12.__len__ = new_instancemethod(_geocal.Vector_Array_double_12___len__,None,Vector_Array_double_12)
Vector_Array_double_12.pop = new_instancemethod(_geocal.Vector_Array_double_12_pop,None,Vector_Array_double_12)
Vector_Array_double_12.__getslice__ = new_instancemethod(_geocal.Vector_Array_double_12___getslice__,None,Vector_Array_double_12)
Vector_Array_double_12.__setslice__ = new_instancemethod(_geocal.Vector_Array_double_12___setslice__,None,Vector_Array_double_12)
Vector_Array_double_12.__delslice__ = new_instancemethod(_geocal.Vector_Array_double_12___delslice__,None,Vector_Array_double_12)
Vector_Array_double_12.__delitem__ = new_instancemethod(_geocal.Vector_Array_double_12___delitem__,None,Vector_Array_double_12)
Vector_Array_double_12.__getitem__ = new_instancemethod(_geocal.Vector_Array_double_12___getitem__,None,Vector_Array_double_12)
Vector_Array_double_12.__setitem__ = new_instancemethod(_geocal.Vector_Array_double_12___setitem__,None,Vector_Array_double_12)
Vector_Array_double_12.append = new_instancemethod(_geocal.Vector_Array_double_12_append,None,Vector_Array_double_12)
Vector_Array_double_12.empty = new_instancemethod(_geocal.Vector_Array_double_12_empty,None,Vector_Array_double_12)
Vector_Array_double_12.size = new_instancemethod(_geocal.Vector_Array_double_12_size,None,Vector_Array_double_12)
Vector_Array_double_12.clear = new_instancemethod(_geocal.Vector_Array_double_12_clear,None,Vector_Array_double_12)
Vector_Array_double_12.swap = new_instancemethod(_geocal.Vector_Array_double_12_swap,None,Vector_Array_double_12)
Vector_Array_double_12.get_allocator = new_instancemethod(_geocal.Vector_Array_double_12_get_allocator,None,Vector_Array_double_12)
Vector_Array_double_12.begin = new_instancemethod(_geocal.Vector_Array_double_12_begin,None,Vector_Array_double_12)
Vector_Array_double_12.end = new_instancemethod(_geocal.Vector_Array_double_12_end,None,Vector_Array_double_12)
Vector_Array_double_12.rbegin = new_instancemethod(_geocal.Vector_Array_double_12_rbegin,None,Vector_Array_double_12)
Vector_Array_double_12.rend = new_instancemethod(_geocal.Vector_Array_double_12_rend,None,Vector_Array_double_12)
Vector_Array_double_12.pop_back = new_instancemethod(_geocal.Vector_Array_double_12_pop_back,None,Vector_Array_double_12)
Vector_Array_double_12.erase = new_instancemethod(_geocal.Vector_Array_double_12_erase,None,Vector_Array_double_12)
Vector_Array_double_12.push_back = new_instancemethod(_geocal.Vector_Array_double_12_push_back,None,Vector_Array_double_12)
Vector_Array_double_12.front = new_instancemethod(_geocal.Vector_Array_double_12_front,None,Vector_Array_double_12)
Vector_Array_double_12.back = new_instancemethod(_geocal.Vector_Array_double_12_back,None,Vector_Array_double_12)
Vector_Array_double_12.assign = new_instancemethod(_geocal.Vector_Array_double_12_assign,None,Vector_Array_double_12)
Vector_Array_double_12.resize = new_instancemethod(_geocal.Vector_Array_double_12_resize,None,Vector_Array_double_12)
Vector_Array_double_12.insert = new_instancemethod(_geocal.Vector_Array_double_12_insert,None,Vector_Array_double_12)
Vector_Array_double_12.reserve = new_instancemethod(_geocal.Vector_Array_double_12_reserve,None,Vector_Array_double_12)
Vector_Array_double_12.capacity = new_instancemethod(_geocal.Vector_Array_double_12_capacity,None,Vector_Array_double_12)
Vector_Array_double_12_swigregister = _geocal.Vector_Array_double_12_swigregister
Vector_Array_double_12_swigregister(Vector_Array_double_12)

class Vector_Array_double_14(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_Array_double_14_swiginit(self,_geocal.new_Vector_Array_double_14(*args))
    __swig_destroy__ = _geocal.delete_Vector_Array_double_14
Vector_Array_double_14.iterator = new_instancemethod(_geocal.Vector_Array_double_14_iterator,None,Vector_Array_double_14)
Vector_Array_double_14.__nonzero__ = new_instancemethod(_geocal.Vector_Array_double_14___nonzero__,None,Vector_Array_double_14)
Vector_Array_double_14.__bool__ = new_instancemethod(_geocal.Vector_Array_double_14___bool__,None,Vector_Array_double_14)
Vector_Array_double_14.__len__ = new_instancemethod(_geocal.Vector_Array_double_14___len__,None,Vector_Array_double_14)
Vector_Array_double_14.pop = new_instancemethod(_geocal.Vector_Array_double_14_pop,None,Vector_Array_double_14)
Vector_Array_double_14.__getslice__ = new_instancemethod(_geocal.Vector_Array_double_14___getslice__,None,Vector_Array_double_14)
Vector_Array_double_14.__setslice__ = new_instancemethod(_geocal.Vector_Array_double_14___setslice__,None,Vector_Array_double_14)
Vector_Array_double_14.__delslice__ = new_instancemethod(_geocal.Vector_Array_double_14___delslice__,None,Vector_Array_double_14)
Vector_Array_double_14.__delitem__ = new_instancemethod(_geocal.Vector_Array_double_14___delitem__,None,Vector_Array_double_14)
Vector_Array_double_14.__getitem__ = new_instancemethod(_geocal.Vector_Array_double_14___getitem__,None,Vector_Array_double_14)
Vector_Array_double_14.__setitem__ = new_instancemethod(_geocal.Vector_Array_double_14___setitem__,None,Vector_Array_double_14)
Vector_Array_double_14.append = new_instancemethod(_geocal.Vector_Array_double_14_append,None,Vector_Array_double_14)
Vector_Array_double_14.empty = new_instancemethod(_geocal.Vector_Array_double_14_empty,None,Vector_Array_double_14)
Vector_Array_double_14.size = new_instancemethod(_geocal.Vector_Array_double_14_size,None,Vector_Array_double_14)
Vector_Array_double_14.clear = new_instancemethod(_geocal.Vector_Array_double_14_clear,None,Vector_Array_double_14)
Vector_Array_double_14.swap = new_instancemethod(_geocal.Vector_Array_double_14_swap,None,Vector_Array_double_14)
Vector_Array_double_14.get_allocator = new_instancemethod(_geocal.Vector_Array_double_14_get_allocator,None,Vector_Array_double_14)
Vector_Array_double_14.begin = new_instancemethod(_geocal.Vector_Array_double_14_begin,None,Vector_Array_double_14)
Vector_Array_double_14.end = new_instancemethod(_geocal.Vector_Array_double_14_end,None,Vector_Array_double_14)
Vector_Array_double_14.rbegin = new_instancemethod(_geocal.Vector_Array_double_14_rbegin,None,Vector_Array_double_14)
Vector_Array_double_14.rend = new_instancemethod(_geocal.Vector_Array_double_14_rend,None,Vector_Array_double_14)
Vector_Array_double_14.pop_back = new_instancemethod(_geocal.Vector_Array_double_14_pop_back,None,Vector_Array_double_14)
Vector_Array_double_14.erase = new_instancemethod(_geocal.Vector_Array_double_14_erase,None,Vector_Array_double_14)
Vector_Array_double_14.push_back = new_instancemethod(_geocal.Vector_Array_double_14_push_back,None,Vector_Array_double_14)
Vector_Array_double_14.front = new_instancemethod(_geocal.Vector_Array_double_14_front,None,Vector_Array_double_14)
Vector_Array_double_14.back = new_instancemethod(_geocal.Vector_Array_double_14_back,None,Vector_Array_double_14)
Vector_Array_double_14.assign = new_instancemethod(_geocal.Vector_Array_double_14_assign,None,Vector_Array_double_14)
Vector_Array_double_14.resize = new_instancemethod(_geocal.Vector_Array_double_14_resize,None,Vector_Array_double_14)
Vector_Array_double_14.insert = new_instancemethod(_geocal.Vector_Array_double_14_insert,None,Vector_Array_double_14)
Vector_Array_double_14.reserve = new_instancemethod(_geocal.Vector_Array_double_14_reserve,None,Vector_Array_double_14)
Vector_Array_double_14.capacity = new_instancemethod(_geocal.Vector_Array_double_14_capacity,None,Vector_Array_double_14)
Vector_Array_double_14_swigregister = _geocal.Vector_Array_double_14_swigregister
Vector_Array_double_14_swigregister(Vector_Array_double_14)

class Quaternion_double(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _geocal.Quaternion_double_swiginit(self,_geocal.new_Quaternion_double(*args))
    from_matrix = staticmethod(_geocal.Quaternion_double_from_matrix)
    def __reduce__(self):
      return _new_from_init, (self.__class__, self.R_component_1(),
    			  self.R_component_2(), self.R_component_3(),
    			  self.R_component_4())

          
    __swig_destroy__ = _geocal.delete_Quaternion_double
Quaternion_double.R_component_1 = new_instancemethod(_geocal.Quaternion_double_R_component_1,None,Quaternion_double)
Quaternion_double.R_component_2 = new_instancemethod(_geocal.Quaternion_double_R_component_2,None,Quaternion_double)
Quaternion_double.R_component_3 = new_instancemethod(_geocal.Quaternion_double_R_component_3,None,Quaternion_double)
Quaternion_double.R_component_4 = new_instancemethod(_geocal.Quaternion_double_R_component_4,None,Quaternion_double)
Quaternion_double.__add__ = new_instancemethod(_geocal.Quaternion_double___add__,None,Quaternion_double)
Quaternion_double.__sub__ = new_instancemethod(_geocal.Quaternion_double___sub__,None,Quaternion_double)
Quaternion_double.__mul__ = new_instancemethod(_geocal.Quaternion_double___mul__,None,Quaternion_double)
Quaternion_double.__div__ = new_instancemethod(_geocal.Quaternion_double___div__,None,Quaternion_double)
Quaternion_double.conj = new_instancemethod(_geocal.Quaternion_double_conj,None,Quaternion_double)
Quaternion_double.to_matrix = new_instancemethod(_geocal.Quaternion_double_to_matrix,None,Quaternion_double)
Quaternion_double.__str__ = new_instancemethod(_geocal.Quaternion_double___str__,None,Quaternion_double)
Quaternion_double_swigregister = _geocal.Quaternion_double_swigregister
Quaternion_double_swigregister(Quaternion_double)

def Quaternion_double_from_matrix(*args):
  return _geocal.Quaternion_double_from_matrix(*args)
Quaternion_double_from_matrix = _geocal.Quaternion_double_from_matrix

class Covariance(object):
    """
    This calculates simple statistics on a pair of numbers.

    It does this by keeping running sums, so we don't need all the numbers
    to be available at once.

    C++ includes: covariance.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        """
        GeoCal::Covariance::Covariance()
        Constructor. 
        """
        _geocal.Covariance_swiginit(self,_geocal.new_Covariance())
    def add(self, *args):
        """
        void GeoCal::Covariance::add(double x1, double x2)
        Add another pair to the running total. 
        """
        return _geocal.Covariance_add(self, *args)

    def _count(self):
        """
        int GeoCal::Covariance::count() const
        Return number of pairs that have been added. 
        """
        return _geocal.Covariance__count(self)

    @property
    def count(self):
        return self._count()

    def _mean1(self):
        """
        double GeoCal::Covariance::mean1() const
        Return mean of first number. Returns 0 if count < 1. 
        """
        return _geocal.Covariance__mean1(self)

    @property
    def mean1(self):
        return self._mean1()

    def _mean2(self):
        """
        double GeoCal::Covariance::mean2() const
        Return mean of second number. Returns 0 if count < 1. 
        """
        return _geocal.Covariance__mean2(self)

    @property
    def mean2(self):
        return self._mean2()

    def _covariance(self):
        """
        double GeoCal::Covariance::covariance() const
        Return covariance between numbers. Returns 0 if count < 2. 
        """
        return _geocal.Covariance__covariance(self)

    @property
    def covariance(self):
        return self._covariance()

    def __str__(self):
        """
        std::string GeoCal::Printable< Covariance  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Covariance___str__(self)

    __swig_destroy__ = _geocal.delete_Covariance
Covariance.add = new_instancemethod(_geocal.Covariance_add,None,Covariance)
Covariance._count = new_instancemethod(_geocal.Covariance__count,None,Covariance)
Covariance._mean1 = new_instancemethod(_geocal.Covariance__mean1,None,Covariance)
Covariance._mean2 = new_instancemethod(_geocal.Covariance__mean2,None,Covariance)
Covariance._covariance = new_instancemethod(_geocal.Covariance__covariance,None,Covariance)
Covariance.__str__ = new_instancemethod(_geocal.Covariance___str__,None,Covariance)
Covariance_swigregister = _geocal.Covariance_swigregister
Covariance_swigregister(Covariance)
cvar = _geocal.cvar
pi = cvar.pi
deg_to_rad = cvar.deg_to_rad
rad_to_deg = cvar.rad_to_deg
arcsecond_to_rad = cvar.arcsecond_to_rad
rad_to_arcsecond = cvar.rad_to_arcsecond
speed_of_light = cvar.speed_of_light

class Exception(object):
    """
    This is the base of the exception hierarchy for GeoCal code.

    This can be written to like a stream to contain information about the
    exception. This is derived from the standard library std::exception

    C++ includes: geocal_exception.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::Exception::Exception(const Exception &E)
        Copy constructor. 
        """
        _geocal.Exception_swiginit(self,_geocal.new_Exception(*args))
    def what(self):
        """
        virtual const char* GeoCal::Exception::what() const
         throw ()
        Description of what the error is.

        """
        return _geocal.Exception_what(self)

    __swig_destroy__ = _geocal.delete_Exception
Exception.what = new_instancemethod(_geocal.Exception_what,None,Exception)
Exception_swigregister = _geocal.Exception_swigregister
Exception_swigregister(Exception)
wgs84_a = cvar.wgs84_a
wgs84_b = cvar.wgs84_b
wgs84_esq = cvar.wgs84_esq

class ConvergenceFailure(Exception):
    """
    Exception thrown if Math routine fails to converge.

    C++ includes: geocal_exception.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::ConvergenceFailure::ConvergenceFailure(const std::string &W="")
        Default constructor.

        Can give an optional string describing the error. 
        """
        _geocal.ConvergenceFailure_swiginit(self,_geocal.new_ConvergenceFailure(*args))
    __swig_destroy__ = _geocal.delete_ConvergenceFailure
ConvergenceFailure_swigregister = _geocal.ConvergenceFailure_swigregister
ConvergenceFailure_swigregister(ConvergenceFailure)

class NoCoverage(Exception):
    """
    Exception thrown if no coverage.

    C++ includes: geocal_exception.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, W=""): 
        """
        GeoCal::NoCoverage::NoCoverage(const std::string &W="")
        Default constructor.

        Can give an optional string describing the error. 
        """
        _geocal.NoCoverage_swiginit(self,_geocal.new_NoCoverage(W))
    __swig_destroy__ = _geocal.delete_NoCoverage
NoCoverage_swigregister = _geocal.NoCoverage_swigregister
NoCoverage_swigregister(NoCoverage)

class MetadataMissing(Exception):
    """
    Exception thrown if Metadata is missing.

    C++ includes: geocal_exception.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::MetadataMissing::MetadataMissing(const std::string &W="")
        Default constructor.

        Can give an optional string describing the error. 
        """
        _geocal.MetadataMissing_swiginit(self,_geocal.new_MetadataMissing(*args))
    __swig_destroy__ = _geocal.delete_MetadataMissing
MetadataMissing_swigregister = _geocal.MetadataMissing_swigregister
MetadataMissing_swigregister(MetadataMissing)

class VicarException(Exception):
    """
    Exception thrown if Vicar call fails.

    C++ includes: geocal_exception.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::VicarException::VicarException(int status, const std::string &W="")
        Default constructor.

        Can give an optional string describing the error. 
        """
        _geocal.VicarException_swiginit(self,_geocal.new_VicarException(*args))
    __swig_destroy__ = _geocal.delete_VicarException
VicarException_swigregister = _geocal.VicarException_swigregister
VicarException_swigregister(VicarException)

class DFunctor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _geocal.delete_DFunctor
DFunctor.__call__ = new_instancemethod(_geocal.DFunctor___call__,None,DFunctor)
DFunctor_swigregister = _geocal.DFunctor_swigregister
DFunctor_swigregister(DFunctor)

class VFunctor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _geocal.delete_VFunctor
VFunctor.__call__ = new_instancemethod(_geocal.VFunctor___call__,None,VFunctor)
VFunctor_swigregister = _geocal.VFunctor_swigregister
VFunctor_swigregister(VFunctor)

class VFunctorWithDerivative(VFunctor):
    """
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def df(self, *args):
        """
        virtual blitz::Array<double, 2> GeoCal::VFunctorWithDerivative::df(const blitz::Array< double, 1 > &X) const =0
        Return jacobian. J_ij = Df_i / dx_j. 
        """
        return _geocal.VFunctorWithDerivative_df(self, *args)

    def f_and_df(self, *args):
        """
        virtual void GeoCal::VFunctorWithDerivative::f_and_df(const blitz::Array< double, 1 > &X, blitz::Array< double, 1 > &F,
        blitz::Array< double, 2 > &Df) const
        Return both the value of the function and the Jacobian.

        Often this can be calculated more quickly. The default implementation
        here just calls opererator() and df separately. 
        """
        return _geocal.VFunctorWithDerivative_f_and_df(self, *args)

    __swig_destroy__ = _geocal.delete_VFunctorWithDerivative
VFunctorWithDerivative.df = new_instancemethod(_geocal.VFunctorWithDerivative_df,None,VFunctorWithDerivative)
VFunctorWithDerivative.f_and_df = new_instancemethod(_geocal.VFunctorWithDerivative_f_and_df,None,VFunctorWithDerivative)
VFunctorWithDerivative_swigregister = _geocal.VFunctorWithDerivative_swigregister
VFunctorWithDerivative_swigregister(VFunctorWithDerivative)

class Statistic(object):
    """
    This calculates basic statistics.

    C++ includes: statistic.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        """
        GeoCal::Statistic::Statistic()
        Constructor. 
        """
        _geocal.Statistic_swiginit(self,_geocal.new_Statistic())
    def add(self, *args):
        """
        void Statistic::add(double x)
        Add a new data point. 
        """
        return _geocal.Statistic_add(self, *args)

    def _min(self):
        """
        double GeoCal::Statistic::min() const
        Minimum value encountered. 
        """
        return _geocal.Statistic__min(self)

    @property
    def min(self):
        return self._min()

    def _max(self):
        """
        double GeoCal::Statistic::max() const
        Maximum value encountered. 
        """
        return _geocal.Statistic__max(self)

    @property
    def max(self):
        return self._max()

    def _mean(self):
        """
        double GeoCal::Statistic::mean() const
        Mean value. 
        """
        return _geocal.Statistic__mean(self)

    @property
    def mean(self):
        return self._mean()

    def _sigma(self):
        """
        double GeoCal::Statistic::sigma() const
        Standard deviation. 
        """
        return _geocal.Statistic__sigma(self)

    @property
    def sigma(self):
        return self._sigma()

    def _mean_abs(self):
        """
        double GeoCal::Statistic::mean_abs() const
        Mean of the absolute value. 
        """
        return _geocal.Statistic__mean_abs(self)

    @property
    def mean_abs(self):
        return self._mean_abs()

    def _min_index(self):
        """
        int GeoCal::Statistic::min_index() const
        Index number of minimum point, where the first point added is index 0,
        second is 1 and so on. 
        """
        return _geocal.Statistic__min_index(self)

    @property
    def min_index(self):
        return self._min_index()

    def _max_index(self):
        """
        int GeoCal::Statistic::max_index() const
        Index number of maximum point, where the first point added is index 0,
        second is 1 and so on. 
        """
        return _geocal.Statistic__max_index(self)

    @property
    def max_index(self):
        return self._max_index()

    def _count(self):
        """
        int GeoCal::Statistic::count() const
        Number of points added. 
        """
        return _geocal.Statistic__count(self)

    @property
    def count(self):
        return self._count()

    def __str__(self):
        """
        std::string GeoCal::Printable< Statistic  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Statistic___str__(self)

    __swig_destroy__ = _geocal.delete_Statistic
Statistic.add = new_instancemethod(_geocal.Statistic_add,None,Statistic)
Statistic.__iadd__ = new_instancemethod(_geocal.Statistic___iadd__,None,Statistic)
Statistic._min = new_instancemethod(_geocal.Statistic__min,None,Statistic)
Statistic._max = new_instancemethod(_geocal.Statistic__max,None,Statistic)
Statistic._mean = new_instancemethod(_geocal.Statistic__mean,None,Statistic)
Statistic._sigma = new_instancemethod(_geocal.Statistic__sigma,None,Statistic)
Statistic._mean_abs = new_instancemethod(_geocal.Statistic__mean_abs,None,Statistic)
Statistic._min_index = new_instancemethod(_geocal.Statistic__min_index,None,Statistic)
Statistic._max_index = new_instancemethod(_geocal.Statistic__max_index,None,Statistic)
Statistic._count = new_instancemethod(_geocal.Statistic__count,None,Statistic)
Statistic.__str__ = new_instancemethod(_geocal.Statistic___str__,None,Statistic)
Statistic_swigregister = _geocal.Statistic_swigregister
Statistic_swigregister(Statistic)


def gsl_fit(*args):
  return _geocal.gsl_fit(*args)
gsl_fit = _geocal.gsl_fit

def gsl_root(*args):
  return _geocal.gsl_root(*args)
gsl_root = _geocal.gsl_root

def root_list(*args):
  return _geocal.root_list(*args)
root_list = _geocal.root_list
import datetime
import time

def _new_time(pgs):
  return Time.time_pgs(pgs)

class Time(object):
    """
    There are a few reasonable choices for expressing time information.

    We could use TAI, GPS, the PGS toolkit. Each of these time system can
    be related to the other by a constant, since the only difference is
    the Epoch that time is measure against.

    Note that for accurate work we do not want to use something like Unix
    time, because this does not account for leapseconds (POSIX unix time
    is the number of seconds since January 1, 1970 not including
    leapseconds).

    Most code doesn't care what the underlying time representation is, we
    just need to be able to do functions such as comparing two times to
    determine what is later, adding or subtracting a given number of
    seconds to a time, or give the duration between two times.

    This class abstracts out the representation we use for time. We supply
    conversions to the specific time systems for use in the cases that a
    specific system is needed (e.g., calling a PGS toolkit routine).

    We also supply methods for converting to and from a string
    representation of the time. The supported formats of the string
    parsing depends on the underlying toolkit used, but all of them
    support CCSDS format (e.g., "1996-07-03T04:13:57.987654Z").

    If either SPICE or SDP is available, then that toolkit is the one used
    for the conversion. If both are available, we default to SPICE. In
    each case, you can change the default by updating the variable
    Time::toolkit_time_interface.

    If we don't have either SPICE or SDP, then we default to using unix
    time (through the boost date_time library). This isn't ideal, but it
    is better than not supporting time at all. For a number of purposes
    the unix time is fine (e.g., indexing data in a orbit file).

    As an implementation detail, we use PGS time, which has an epoch of
    1993-01-01.

    Note there is a subtle difference between time used for Terrestrial
    uses (such as UTC) and for planetary use. There are two ways used for
    measuring time - International atomic time (TAI) and Barycentric
    Dynamic Time (TDB). The first is the time measured by an atomic clock
    on the earth vs. the second which measures time at the barycenter of
    the solar system. Due to relativistic effects, the two clocks vary by
    something close to a periodic function with a size of about 1 ms over
    the coarse of a year. We measure time durations (e.g., the difference
    between 2 times) in TAI. For most purposes, you can ignore the
    difference between the two systems.

    When calling SPICE routines, we internally convert to and from TAI
    time as needed. This is a bit less efficient than simply keeping
    everything in TDB time, but it gives a cleaner interface. We can
    revisit this if the computer time it takes to do the conversions start
    becoming prohibitive.

    C++ includes: geocal_time.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def time_et(*args):
        """
        Time Time::time_et(double et)
        Return time from given SPICE ET time. 
        """
        return _geocal.Time_time_et(*args)

    time_et = staticmethod(time_et)
    def time_pgs(*args):
        """
        static Time GeoCal::Time::time_pgs(double pgs)
        Return time from given PGS toolkit time (epoch of 1993-01-01). 
        """
        return _geocal.Time_time_pgs(*args)

    time_pgs = staticmethod(time_pgs)
    def time_j2000(*args):
        """
        static Time GeoCal::Time::time_j2000(double j2000)
        Return time from given J2000 time (epoch of 2000-01-01 12:00:00 TT).

        Note that TT is different than UTC noon by about 64.184 seconds 
        """
        return _geocal.Time_time_j2000(*args)

    time_j2000 = staticmethod(time_j2000)
    def time_gps(*args):
        """
        static Time GeoCal::Time::time_gps(double gps)
        Return time from given GPS time (epoch of 1980-01-06). 
        """
        return _geocal.Time_time_gps(*args)

    time_gps = staticmethod(time_gps)
    def time_unix(*args):
        """
        static Time GeoCal::Time::time_unix(double unix_time)
        Return time from given Unix time (epoch of 1970-01-01). 
        """
        return _geocal.Time_time_unix(*args)

    time_unix = staticmethod(time_unix)
    def time_acs(*args):
        """
        Time Time::time_acs(double acs_time)
        Return time from ACS time.

        ACS time is an odd time system. It is measured in UTC seconds from a
        particular epoch. The choice of UTC seconds means that this cannot
        correctly handle times that occur during a leapsecond, by definition
        the UTC time before and after a leapsecond is the same. The epoch is
        noon January, 1 2000 in UTC. Note that this is 64.184 seconds
        different from terrestrial time J2000. 
        """
        return _geocal.Time_time_acs(*args)

    time_acs = staticmethod(time_acs)
    def _acs(self):
        """
        double Time::acs() const
        Give ACS time. 
        """
        return _geocal.Time__acs(self)

    @property
    def acs(self):
        return self._acs()

    def _pgs(self):
        """
        double GeoCal::Time::pgs() const
        Give time in PGS toolkit time (epoch 1993-01-01). 
        """
        return _geocal.Time__pgs(self)

    @property
    def pgs(self):
        return self._pgs()

    def _gps(self):
        """
        double GeoCal::Time::gps() const
        Give time in GPS. 
        """
        return _geocal.Time__gps(self)

    @property
    def gps(self):
        return self._gps()

    def _j2000(self):
        """
        double GeoCal::Time::j2000() const
        Give time in j2000. 
        """
        return _geocal.Time__j2000(self)

    @property
    def j2000(self):
        return self._j2000()

    def _et(self):
        """
        double Time::et() const
        Give time as SPICE ET time. 
        """
        return _geocal.Time__et(self)

    @property
    def et(self):
        return self._et()

    def parse_time(*args):
        """
        static Time GeoCal::Time::parse_time(const std::string Time_string)
        Parse string to get a Time.

        Uses interface supplied by toolkit_time_interface. 
        """
        return _geocal.Time_parse_time(*args)

    parse_time = staticmethod(parse_time)
    def __str__(self):
        """
        std::string GeoCal::Printable< Time  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Time___str__(self)

    def unix_time(self):
        """
        std::time_t GeoCal::Time::unix_time() const
        Give time in unix time.

        Note that this is only accurate to the nearest second. 
        """
        return _geocal.Time_unix_time(self)

    def __reduce__(self):
      return _new_time, (self.pgs,)

      
    def __init__(self): 
        _geocal.Time_swiginit(self,_geocal.new_Time())
    __swig_destroy__ = _geocal.delete_Time
Time._acs = new_instancemethod(_geocal.Time__acs,None,Time)
Time._pgs = new_instancemethod(_geocal.Time__pgs,None,Time)
Time._gps = new_instancemethod(_geocal.Time__gps,None,Time)
Time._j2000 = new_instancemethod(_geocal.Time__j2000,None,Time)
Time._et = new_instancemethod(_geocal.Time__et,None,Time)
Time.__str__ = new_instancemethod(_geocal.Time___str__,None,Time)
Time.__cmp__ = new_instancemethod(_geocal.Time___cmp__,None,Time)
Time.__add__ = new_instancemethod(_geocal.Time___add__,None,Time)
Time.__radd__ = new_instancemethod(_geocal.Time___radd__,None,Time)
Time.__sub__ = new_instancemethod(_geocal.Time___sub__,None,Time)
Time.unix_time = new_instancemethod(_geocal.Time_unix_time,None,Time)
Time_swigregister = _geocal.Time_swigregister
Time_swigregister(Time)

def Time_time_et(*args):
  """
    Time Time::time_et(double et)
    Return time from given SPICE ET time. 
    """
  return _geocal.Time_time_et(*args)

def Time_time_pgs(*args):
  """
    static Time GeoCal::Time::time_pgs(double pgs)
    Return time from given PGS toolkit time (epoch of 1993-01-01). 
    """
  return _geocal.Time_time_pgs(*args)

def Time_time_j2000(*args):
  """
    static Time GeoCal::Time::time_j2000(double j2000)
    Return time from given J2000 time (epoch of 2000-01-01 12:00:00 TT).

    Note that TT is different than UTC noon by about 64.184 seconds 
    """
  return _geocal.Time_time_j2000(*args)

def Time_time_gps(*args):
  """
    static Time GeoCal::Time::time_gps(double gps)
    Return time from given GPS time (epoch of 1980-01-06). 
    """
  return _geocal.Time_time_gps(*args)

def Time_time_unix(*args):
  """
    static Time GeoCal::Time::time_unix(double unix_time)
    Return time from given Unix time (epoch of 1970-01-01). 
    """
  return _geocal.Time_time_unix(*args)

def Time_time_acs(*args):
  """
    Time Time::time_acs(double acs_time)
    Return time from ACS time.

    ACS time is an odd time system. It is measured in UTC seconds from a
    particular epoch. The choice of UTC seconds means that this cannot
    correctly handle times that occur during a leapsecond, by definition
    the UTC time before and after a leapsecond is the same. The epoch is
    noon January, 1 2000 in UTC. Note that this is 64.184 seconds
    different from terrestrial time J2000. 
    """
  return _geocal.Time_time_acs(*args)

def Time_parse_time(*args):
  """
    static Time GeoCal::Time::parse_time(const std::string Time_string)
    Parse string to get a Time.

    Uses interface supplied by toolkit_time_interface. 
    """
  return _geocal.Time_parse_time(*args)
Time.min_valid_time = _geocal.cvar.Time_min_valid_time
Time.max_valid_time = _geocal.cvar.Time_max_valid_time

class Vector_Time(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_Time_swiginit(self,_geocal.new_Vector_Time(*args))
    __swig_destroy__ = _geocal.delete_Vector_Time
Vector_Time.iterator = new_instancemethod(_geocal.Vector_Time_iterator,None,Vector_Time)
Vector_Time.__nonzero__ = new_instancemethod(_geocal.Vector_Time___nonzero__,None,Vector_Time)
Vector_Time.__bool__ = new_instancemethod(_geocal.Vector_Time___bool__,None,Vector_Time)
Vector_Time.__len__ = new_instancemethod(_geocal.Vector_Time___len__,None,Vector_Time)
Vector_Time.pop = new_instancemethod(_geocal.Vector_Time_pop,None,Vector_Time)
Vector_Time.__getslice__ = new_instancemethod(_geocal.Vector_Time___getslice__,None,Vector_Time)
Vector_Time.__setslice__ = new_instancemethod(_geocal.Vector_Time___setslice__,None,Vector_Time)
Vector_Time.__delslice__ = new_instancemethod(_geocal.Vector_Time___delslice__,None,Vector_Time)
Vector_Time.__delitem__ = new_instancemethod(_geocal.Vector_Time___delitem__,None,Vector_Time)
Vector_Time.__getitem__ = new_instancemethod(_geocal.Vector_Time___getitem__,None,Vector_Time)
Vector_Time.__setitem__ = new_instancemethod(_geocal.Vector_Time___setitem__,None,Vector_Time)
Vector_Time.append = new_instancemethod(_geocal.Vector_Time_append,None,Vector_Time)
Vector_Time.empty = new_instancemethod(_geocal.Vector_Time_empty,None,Vector_Time)
Vector_Time.size = new_instancemethod(_geocal.Vector_Time_size,None,Vector_Time)
Vector_Time.clear = new_instancemethod(_geocal.Vector_Time_clear,None,Vector_Time)
Vector_Time.swap = new_instancemethod(_geocal.Vector_Time_swap,None,Vector_Time)
Vector_Time.get_allocator = new_instancemethod(_geocal.Vector_Time_get_allocator,None,Vector_Time)
Vector_Time.begin = new_instancemethod(_geocal.Vector_Time_begin,None,Vector_Time)
Vector_Time.end = new_instancemethod(_geocal.Vector_Time_end,None,Vector_Time)
Vector_Time.rbegin = new_instancemethod(_geocal.Vector_Time_rbegin,None,Vector_Time)
Vector_Time.rend = new_instancemethod(_geocal.Vector_Time_rend,None,Vector_Time)
Vector_Time.pop_back = new_instancemethod(_geocal.Vector_Time_pop_back,None,Vector_Time)
Vector_Time.erase = new_instancemethod(_geocal.Vector_Time_erase,None,Vector_Time)
Vector_Time.push_back = new_instancemethod(_geocal.Vector_Time_push_back,None,Vector_Time)
Vector_Time.front = new_instancemethod(_geocal.Vector_Time_front,None,Vector_Time)
Vector_Time.back = new_instancemethod(_geocal.Vector_Time_back,None,Vector_Time)
Vector_Time.assign = new_instancemethod(_geocal.Vector_Time_assign,None,Vector_Time)
Vector_Time.resize = new_instancemethod(_geocal.Vector_Time_resize,None,Vector_Time)
Vector_Time.insert = new_instancemethod(_geocal.Vector_Time_insert,None,Vector_Time)
Vector_Time.reserve = new_instancemethod(_geocal.Vector_Time_reserve,None,Vector_Time)
Vector_Time.capacity = new_instancemethod(_geocal.Vector_Time_capacity,None,Vector_Time)
Vector_Time_swigregister = _geocal.Vector_Time_swigregister
Vector_Time_swigregister(Vector_Time)

class TiledFileBase_2(object):
    """
    This class is the base class of TiledFile<T, D>.

    It turns out to be useful to factor out the part of TiledFile that
    doesn't depend on the type T. For most purposes though, you can ignore
    this class and use TiledFile<T, D> directly.

    For use with some classes, it is useful to be able to change a generic
    type T to some common type. For instance, RasterImage converts the
    types to and from int, and Dem converts to double. We supply
    conversion routines in this base class for a few common types, as
    get_int, put_double, read_int etc.

    C++ includes: tiled_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def _number_swap(self):
        """
        unsigned int GeoCal::TiledFileBase< D >::number_swap() const
        Number of times we have swapped a tile since reset_number_swap called.

        """
        return _geocal.TiledFileBase_2__number_swap(self)

    @property
    def number_swap(self):
        return self._number_swap()

    def reset_number_swap(self):
        """
        void GeoCal::TiledFileBase< D >::reset_number_swap()
        Reset number of swap counter to 0. 
        """
        return _geocal.TiledFileBase_2_reset_number_swap(self)

    def _size(self):
        """
        const boost::array<index, D>& GeoCal::TiledFileBase< D >::size() const
        File size. 
        """
        return _geocal.TiledFileBase_2__size(self)

    @property
    def size(self):
        return self._size()

    def _tile_size(self):
        """
        const boost::array<index, D>& GeoCal::TiledFileBase< D >::tile_size() const
        Tile size. 
        """
        return _geocal.TiledFileBase_2__tile_size(self)

    @property
    def tile_size(self):
        return self._tile_size()

    def get_int(self, *args):
        """
        virtual int GeoCal::TiledFileBase< D >::get_int(const boost::array< index, D > &Index) const =0
        Get data an convert to integer. 
        """
        return _geocal.TiledFileBase_2_get_int(self, *args)

    def get_double(self, *args):
        """
        virtual double GeoCal::TiledFileBase< D >::get_double(const boost::array< index, D > &Index) const =0
        Get data an convert to double. 
        """
        return _geocal.TiledFileBase_2_get_double(self, *args)

    def read_int(self, *args):
        """
        virtual void GeoCal::TiledFileBase< D >::read_int(const boost::array< index, D > &Min_index, const boost::array< index,
        D > &Max_index, int *Res) const =0
        Read a subset of the data, and convert to int. 
        """
        return _geocal.TiledFileBase_2_read_int(self, *args)

    def read_double(self, *args):
        """
        virtual void GeoCal::TiledFileBase< D >::read_double(const boost::array< index, D > &Min_index, const boost::array< index,
        D > &Max_index, double *Res) const =0
        Read a subset of the data, and convert to double. 
        """
        return _geocal.TiledFileBase_2_read_double(self, *args)

    def write_int(self, *args):
        """
        virtual void GeoCal::TiledFileBase< D >::write_int(const boost::array< index, D > &Index, int Val)=0
        Convert an int to type T, and write to file. 
        """
        return _geocal.TiledFileBase_2_write_int(self, *args)

    def write_double(self, *args):
        """
        virtual void GeoCal::TiledFileBase< D >::write_double(const boost::array< index, D > &Index, double Val)=0
        Convert a double to type T, and write to file. 
        """
        return _geocal.TiledFileBase_2_write_double(self, *args)

    __swig_destroy__ = _geocal.delete_TiledFileBase_2
TiledFileBase_2._number_swap = new_instancemethod(_geocal.TiledFileBase_2__number_swap,None,TiledFileBase_2)
TiledFileBase_2.reset_number_swap = new_instancemethod(_geocal.TiledFileBase_2_reset_number_swap,None,TiledFileBase_2)
TiledFileBase_2._size = new_instancemethod(_geocal.TiledFileBase_2__size,None,TiledFileBase_2)
TiledFileBase_2._tile_size = new_instancemethod(_geocal.TiledFileBase_2__tile_size,None,TiledFileBase_2)
TiledFileBase_2.get_int = new_instancemethod(_geocal.TiledFileBase_2_get_int,None,TiledFileBase_2)
TiledFileBase_2.get_double = new_instancemethod(_geocal.TiledFileBase_2_get_double,None,TiledFileBase_2)
TiledFileBase_2.read_int = new_instancemethod(_geocal.TiledFileBase_2_read_int,None,TiledFileBase_2)
TiledFileBase_2.read_double = new_instancemethod(_geocal.TiledFileBase_2_read_double,None,TiledFileBase_2)
TiledFileBase_2.write_int = new_instancemethod(_geocal.TiledFileBase_2_write_int,None,TiledFileBase_2)
TiledFileBase_2.write_double = new_instancemethod(_geocal.TiledFileBase_2_write_double,None,TiledFileBase_2)
TiledFileBase_2_swigregister = _geocal.TiledFileBase_2_swigregister
TiledFileBase_2_swigregister(TiledFileBase_2)

class HdfFile(object):
    """
    This class reads a HDF5 file.

    Note that this is just a thin layer on top of the HDF 5 libraries to
    make the file operations we need to do in GeoCal easier. There are
    many other things that can be done with a HDF 5 than what this class
    exposes.

    Right now, we don't support writing. This is just because I don't
    happen to need this. We can add this if we ever want to write files.

    C++ includes: hdf_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __str__(self):
        """
        std::string GeoCal::Printable< HdfFile  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.HdfFile___str__(self)

    READ = _geocal.HdfFile_READ
    CREATE = _geocal.HdfFile_CREATE
    READ_WRITE = _geocal.HdfFile_READ_WRITE
    def __init__(self, *args): 
        """
        HdfFile::HdfFile(const std::string &Fname, Mode M=READ)
        Open the given file with the given mode. 
        """
        _geocal.HdfFile_swiginit(self,_geocal.new_HdfFile(*args))
    def close(self):
        """
        void GeoCal::HdfFile::close()
        Close the underlying file.

        This is automatically done by the destructor, so you only need to call
        this if you want to force a close (e.g., for a unit test) 
        """
        return _geocal.HdfFile_close(self)

    def _file_name(self):
        """
        const std::string& GeoCal::HdfFile::file_name() const
        File name. 
        """
        return _geocal.HdfFile__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def is_hdf(*args):
        """
        static bool GeoCal::HdfFile::is_hdf(const std::string &Fname)
        Return true if the given file is an HDF file. 
        """
        return _geocal.HdfFile_is_hdf(*args)

    is_hdf = staticmethod(is_hdf)
    __swig_destroy__ = _geocal.delete_HdfFile
HdfFile.__str__ = new_instancemethod(_geocal.HdfFile___str__,None,HdfFile)
HdfFile.close = new_instancemethod(_geocal.HdfFile_close,None,HdfFile)
HdfFile._file_name = new_instancemethod(_geocal.HdfFile__file_name,None,HdfFile)
HdfFile.read_double_1d = new_instancemethod(_geocal.HdfFile_read_double_1d,None,HdfFile)
HdfFile.read_double_2d = new_instancemethod(_geocal.HdfFile_read_double_2d,None,HdfFile)
HdfFile.read_double_3d = new_instancemethod(_geocal.HdfFile_read_double_3d,None,HdfFile)
HdfFile.read_double_4d = new_instancemethod(_geocal.HdfFile_read_double_4d,None,HdfFile)
HdfFile.read_int_1d = new_instancemethod(_geocal.HdfFile_read_int_1d,None,HdfFile)
HdfFile.read_int_2d = new_instancemethod(_geocal.HdfFile_read_int_2d,None,HdfFile)
HdfFile.read_int_3d = new_instancemethod(_geocal.HdfFile_read_int_3d,None,HdfFile)
HdfFile.read_int_4d = new_instancemethod(_geocal.HdfFile_read_int_4d,None,HdfFile)
HdfFile_swigregister = _geocal.HdfFile_swigregister
HdfFile_swigregister(HdfFile)

def HdfFile_is_hdf(*args):
  """
    static bool GeoCal::HdfFile::is_hdf(const std::string &Fname)
    Return true if the given file is an HDF file. 
    """
  return _geocal.HdfFile_is_hdf(*args)

class ImageCoordinate(object):
    """
    This describes an image coordinate.

    We also define the print operator <<, and equality operator ==. Two
    image coordinates are considers equal if they are within 0.01 in the
    line and sample.

    The convention used throughout GeoCal is that an integer value of the
    ImageCoordinate line or sample refers to the center of a pixel. This
    means the upper left corner of the bounding box of an image is at
    (-0.5, -0.5).

    C++ includes: image_coordinate.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::ImageCoordinate::ImageCoordinate()
        Default constructor, line and sample aren't initialized. 
        """
        _geocal.ImageCoordinate_swiginit(self,_geocal.new_ImageCoordinate(*args))
    line = _swig_property(_geocal.ImageCoordinate_line_get, _geocal.ImageCoordinate_line_set)
    sample = _swig_property(_geocal.ImageCoordinate_sample_get, _geocal.ImageCoordinate_sample_set)
    def __str__(self):
        """
        std::string GeoCal::Printable< ImageCoordinate  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.ImageCoordinate___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.line,self.sample)

    __swig_destroy__ = _geocal.delete_ImageCoordinate
ImageCoordinate.__str__ = new_instancemethod(_geocal.ImageCoordinate___str__,None,ImageCoordinate)
ImageCoordinate_swigregister = _geocal.ImageCoordinate_swigregister
ImageCoordinate_swigregister(ImageCoordinate)

class VicarImageCoordinate(object):
    """
    VICAR programs use a different convention than our ImageCoordinate.

    Instead of the upper left hand corner of the bounding box being
    (-0.5,-0.5), VICAR uses a 1-based convention where the upper left
    corner is (0.5, 0.5). This is just a difference of 1-pixel. To avoid
    any confusion, we define a VicarImageCoordinate class, and allow
    conversions to and from ImageCoordinate.

    C++ includes: image_coordinate.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::VicarImageCoordinate::VicarImageCoordinate()
        Default constructor, line and sample aren't initialized. 
        """
        _geocal.VicarImageCoordinate_swiginit(self,_geocal.new_VicarImageCoordinate(*args))
    line = _swig_property(_geocal.VicarImageCoordinate_line_get, _geocal.VicarImageCoordinate_line_set)
    sample = _swig_property(_geocal.VicarImageCoordinate_sample_get, _geocal.VicarImageCoordinate_sample_set)
    def __str__(self):
        """
        std::string GeoCal::Printable< VicarImageCoordinate  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.VicarImageCoordinate___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.line,self.sample)

    __swig_destroy__ = _geocal.delete_VicarImageCoordinate
VicarImageCoordinate.__str__ = new_instancemethod(_geocal.VicarImageCoordinate___str__,None,VicarImageCoordinate)
VicarImageCoordinate_swigregister = _geocal.VicarImageCoordinate_swigregister
VicarImageCoordinate_swigregister(VicarImageCoordinate)

class Vector_ImageCoordinate(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_ImageCoordinate_swiginit(self,_geocal.new_Vector_ImageCoordinate(*args))
    __swig_destroy__ = _geocal.delete_Vector_ImageCoordinate
Vector_ImageCoordinate.iterator = new_instancemethod(_geocal.Vector_ImageCoordinate_iterator,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.__nonzero__ = new_instancemethod(_geocal.Vector_ImageCoordinate___nonzero__,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.__bool__ = new_instancemethod(_geocal.Vector_ImageCoordinate___bool__,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.__len__ = new_instancemethod(_geocal.Vector_ImageCoordinate___len__,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.pop = new_instancemethod(_geocal.Vector_ImageCoordinate_pop,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.__getslice__ = new_instancemethod(_geocal.Vector_ImageCoordinate___getslice__,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.__setslice__ = new_instancemethod(_geocal.Vector_ImageCoordinate___setslice__,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.__delslice__ = new_instancemethod(_geocal.Vector_ImageCoordinate___delslice__,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.__delitem__ = new_instancemethod(_geocal.Vector_ImageCoordinate___delitem__,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.__getitem__ = new_instancemethod(_geocal.Vector_ImageCoordinate___getitem__,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.__setitem__ = new_instancemethod(_geocal.Vector_ImageCoordinate___setitem__,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.append = new_instancemethod(_geocal.Vector_ImageCoordinate_append,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.empty = new_instancemethod(_geocal.Vector_ImageCoordinate_empty,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.size = new_instancemethod(_geocal.Vector_ImageCoordinate_size,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.clear = new_instancemethod(_geocal.Vector_ImageCoordinate_clear,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.swap = new_instancemethod(_geocal.Vector_ImageCoordinate_swap,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.get_allocator = new_instancemethod(_geocal.Vector_ImageCoordinate_get_allocator,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.begin = new_instancemethod(_geocal.Vector_ImageCoordinate_begin,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.end = new_instancemethod(_geocal.Vector_ImageCoordinate_end,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.rbegin = new_instancemethod(_geocal.Vector_ImageCoordinate_rbegin,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.rend = new_instancemethod(_geocal.Vector_ImageCoordinate_rend,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.pop_back = new_instancemethod(_geocal.Vector_ImageCoordinate_pop_back,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.erase = new_instancemethod(_geocal.Vector_ImageCoordinate_erase,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.push_back = new_instancemethod(_geocal.Vector_ImageCoordinate_push_back,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.front = new_instancemethod(_geocal.Vector_ImageCoordinate_front,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.back = new_instancemethod(_geocal.Vector_ImageCoordinate_back,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.assign = new_instancemethod(_geocal.Vector_ImageCoordinate_assign,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.resize = new_instancemethod(_geocal.Vector_ImageCoordinate_resize,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.insert = new_instancemethod(_geocal.Vector_ImageCoordinate_insert,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.reserve = new_instancemethod(_geocal.Vector_ImageCoordinate_reserve,None,Vector_ImageCoordinate)
Vector_ImageCoordinate.capacity = new_instancemethod(_geocal.Vector_ImageCoordinate_capacity,None,Vector_ImageCoordinate)
Vector_ImageCoordinate_swigregister = _geocal.Vector_ImageCoordinate_swigregister
Vector_ImageCoordinate_swigregister(Vector_ImageCoordinate)

class Vector_ImageCoordinatePtr(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_ImageCoordinatePtr_swiginit(self,_geocal.new_Vector_ImageCoordinatePtr(*args))
    __swig_destroy__ = _geocal.delete_Vector_ImageCoordinatePtr
Vector_ImageCoordinatePtr.iterator = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_iterator,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.__nonzero__ = new_instancemethod(_geocal.Vector_ImageCoordinatePtr___nonzero__,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.__bool__ = new_instancemethod(_geocal.Vector_ImageCoordinatePtr___bool__,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.__len__ = new_instancemethod(_geocal.Vector_ImageCoordinatePtr___len__,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.pop = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_pop,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.__getslice__ = new_instancemethod(_geocal.Vector_ImageCoordinatePtr___getslice__,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.__setslice__ = new_instancemethod(_geocal.Vector_ImageCoordinatePtr___setslice__,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.__delslice__ = new_instancemethod(_geocal.Vector_ImageCoordinatePtr___delslice__,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.__delitem__ = new_instancemethod(_geocal.Vector_ImageCoordinatePtr___delitem__,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.__getitem__ = new_instancemethod(_geocal.Vector_ImageCoordinatePtr___getitem__,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.__setitem__ = new_instancemethod(_geocal.Vector_ImageCoordinatePtr___setitem__,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.append = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_append,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.empty = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_empty,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.size = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_size,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.clear = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_clear,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.swap = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_swap,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.get_allocator = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_get_allocator,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.begin = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_begin,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.end = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_end,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.rbegin = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_rbegin,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.rend = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_rend,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.pop_back = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_pop_back,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.erase = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_erase,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.push_back = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_push_back,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.front = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_front,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.back = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_back,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.assign = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_assign,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.resize = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_resize,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.insert = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_insert,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.reserve = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_reserve,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr.capacity = new_instancemethod(_geocal.Vector_ImageCoordinatePtr_capacity,None,Vector_ImageCoordinatePtr)
Vector_ImageCoordinatePtr_swigregister = _geocal.Vector_ImageCoordinatePtr_swigregister
Vector_ImageCoordinatePtr_swigregister(Vector_ImageCoordinatePtr)

class LookVector(object):
    """
    This is a look vector in an unspecified coordinate system.

    Derived classes specify the coordinate system.

    C++ includes: look_vector.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    look_vector = _swig_property(_geocal.LookVector_look_vector_get, _geocal.LookVector_look_vector_set)
    def _direction(self):
        """
        boost::array< double, 3 > LookVector::direction() const
        This is the direction, as a unit vector. 
        """
        return _geocal.LookVector__direction(self)

    @property
    def direction(self):
        return self._direction()

    def _length(self):
        """
        double LookVector::length() const

        """
        return _geocal.LookVector__length(self)

    @property
    def length(self):
        return self._length()

    def __str__(self):
        """
        std::string GeoCal::Printable< LookVector  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.LookVector___str__(self)

    __swig_destroy__ = _geocal.delete_LookVector
LookVector._direction = new_instancemethod(_geocal.LookVector__direction,None,LookVector)
LookVector._length = new_instancemethod(_geocal.LookVector__length,None,LookVector)
LookVector.__str__ = new_instancemethod(_geocal.LookVector___str__,None,LookVector)
LookVector_swigregister = _geocal.LookVector_swigregister
LookVector_swigregister(LookVector)

class ScLookVector(LookVector):
    """
    This is a look vector in an spacecraft coordinates.

    C++ includes: look_vector.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::ScLookVector::ScLookVector(double x, double y, double z)
        Constructor. 
        """
        _geocal.ScLookVector_swiginit(self,_geocal.new_ScLookVector(*args))
    def __str__(self):
        """
        std::string GeoCal::Printable< LookVector  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.ScLookVector___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.look_vector[0],self.look_vector[1],self.look_vector[2])

    __swig_destroy__ = _geocal.delete_ScLookVector
ScLookVector.__str__ = new_instancemethod(_geocal.ScLookVector___str__,None,ScLookVector)
ScLookVector_swigregister = _geocal.ScLookVector_swigregister
ScLookVector_swigregister(ScLookVector)

class CartesianInertialLookVector(LookVector):
    """
    This is a look vector in CartesianInertial coordinates.

    C++ includes: look_vector.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::CartesianInertialLookVector::CartesianInertialLookVector(double x, double y, double z)
        Constructor. 
        """
        _geocal.CartesianInertialLookVector_swiginit(self,_geocal.new_CartesianInertialLookVector(*args))
    def __str__(self):
        """
        std::string GeoCal::Printable< LookVector  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.CartesianInertialLookVector___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.look_vector[0],self.look_vector[1],self.look_vector[2])

    __swig_destroy__ = _geocal.delete_CartesianInertialLookVector
CartesianInertialLookVector.__str__ = new_instancemethod(_geocal.CartesianInertialLookVector___str__,None,CartesianInertialLookVector)
CartesianInertialLookVector_swigregister = _geocal.CartesianInertialLookVector_swigregister
CartesianInertialLookVector_swigregister(CartesianInertialLookVector)

class CartesianFixedLookVector(LookVector):
    """
    This is a look vector in CartesianFixed coordinates.

    C++ includes: look_vector.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::CartesianFixedLookVector::CartesianFixedLookVector(double x, double y, double z)
        Constructor. 
        """
        _geocal.CartesianFixedLookVector_swiginit(self,_geocal.new_CartesianFixedLookVector(*args))
    def __str__(self):
        """
        std::string GeoCal::Printable< LookVector  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.CartesianFixedLookVector___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.look_vector[0],self.look_vector[1],self.look_vector[2])

    __swig_destroy__ = _geocal.delete_CartesianFixedLookVector
CartesianFixedLookVector.__str__ = new_instancemethod(_geocal.CartesianFixedLookVector___str__,None,CartesianFixedLookVector)
CartesianFixedLookVector_swigregister = _geocal.CartesianFixedLookVector_swigregister
CartesianFixedLookVector_swigregister(CartesianFixedLookVector)

class GroundCoordinate(object):
    """
    This represents a location on the ground.

    It is a base class, each of the derived classes represent different
    coordinate systems that can be used to express the ground location.
    Any ground coordinate can be converted to CartesianFixed coordinates.

    Because it is commonly needed, we also can convert to latitude,
    longitude and height_reference_surface. The default is just convert
    first to CartesianFixed, and then convert to latitude, longitude or
    height_reference_surface, but derived classes can supply more
    efficient versions of this if desired.

    C++ includes: ground_coordinate.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def _latitude(self):
        """
        double GeoCal::GroundCoordinate::latitude() const
        Return latitude in degrees.

        By default we just convert to CartesianFixed and then to latitude, but
        derived classes can supply more efficient versions of these if needed.
        Latitude is -90 to 90. 
        """
        return _geocal.GroundCoordinate__latitude(self)

    @property
    def latitude(self):
        return self._latitude()

    def _longitude(self):
        """
        double GeoCal::GroundCoordinate::longitude() const
        Return longitude in degrees.

        By default we just convert to CartesianFixed and then to longitude,
        but derived classes can supply more efficient versions of these if
        needed. Longitude is -180 to 180. 
        """
        return _geocal.GroundCoordinate__longitude(self)

    @property
    def longitude(self):
        return self._longitude()

    def _height_reference_surface(self):
        """
        double GeoCal::GroundCoordinate::height_reference_surface() const
        Return height in meters above reference surface (e.g., WGS-84 for the
        earth).

        By default we just convert to CartesianFixed and then to height, but
        derived classes can supply more efficient versions of these if needed.

        """
        return _geocal.GroundCoordinate__height_reference_surface(self)

    @property
    def height_reference_surface(self):
        return self._height_reference_surface()

    def convert_to_cf(self):
        """
        virtual boost::shared_ptr<CartesianFixed> GeoCal::GroundCoordinate::convert_to_cf() const =0
        Convert to CartesianFixed. 
        """
        return _geocal.GroundCoordinate_convert_to_cf(self)

    def __str__(self):
        """
        std::string GeoCal::Printable< GroundCoordinate  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.GroundCoordinate___str__(self)

    __swig_destroy__ = _geocal.delete_GroundCoordinate
GroundCoordinate._latitude = new_instancemethod(_geocal.GroundCoordinate__latitude,None,GroundCoordinate)
GroundCoordinate._longitude = new_instancemethod(_geocal.GroundCoordinate__longitude,None,GroundCoordinate)
GroundCoordinate._height_reference_surface = new_instancemethod(_geocal.GroundCoordinate__height_reference_surface,None,GroundCoordinate)
GroundCoordinate.convert_to_cf = new_instancemethod(_geocal.GroundCoordinate_convert_to_cf,None,GroundCoordinate)
GroundCoordinate.__str__ = new_instancemethod(_geocal.GroundCoordinate___str__,None,GroundCoordinate)
GroundCoordinate_swigregister = _geocal.GroundCoordinate_swigregister
GroundCoordinate_swigregister(GroundCoordinate)

class CartesianInertial(object):
    """
    This gives the location in a Cartesian inertial coordinate system
    (.e.g., ECI).

    See CartesianFixed for a discussion on converting to and from
    CartesianFixed.

    C++ includes: ground_coordinate.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def convert_to_cf(self, *args):
        """
        virtual boost::shared_ptr<CartesianFixed> GeoCal::CartesianInertial::convert_to_cf(const Time &T) const =0
        Convert to a CartesianFixed. 
        """
        return _geocal.CartesianInertial_convert_to_cf(self, *args)

    def ci_to_cf(self, *args):
        """
        virtual void GeoCal::CartesianInertial::ci_to_cf(const Time &T, double Ci_to_cf[3][3]) const =0
        Calculate matrix that can be used to convert CartesianFixed to
        CartesianInertial at the given Time.

        The matrix for going from CartesianInertial to CartesianFixed is the
        transpose of this matrix. 
        """
        return _geocal.CartesianInertial_ci_to_cf(self, *args)

    def ci_to_cf_quat(self, *args):
        """
        boost::math::quaternion<double> GeoCal::CartesianInertial::ci_to_cf_quat(const Time &T) const
        Calculate quaternion that can be used to convert CartesianFixed to
        CartesianInertial at the given Time. 
        """
        return _geocal.CartesianInertial_ci_to_cf_quat(self, *args)

    def create(self, *args):
        """
        virtual boost::shared_ptr<CartesianInertial> GeoCal::CartesianInertial::create(boost::array< double, 3 > P) const =0
        Create an instance of whatever type of CartesianInertial this is. 
        """
        return _geocal.CartesianInertial_create(self, *args)

    def reference_surface_intersect_approximate(self, *args):
        """
        virtual boost::shared_ptr<CartesianInertial> GeoCal::CartesianInertial::reference_surface_intersect_approximate(const CartesianInertialLookVector &Cl, double
        Height_reference_surface=0) const =0
        Find the intersection with the surface at the given height starting at
        this point and looking in the given direction.

        The intersection is done in an approximate but quicker manner, see the
        derived classes for the approximation used. 
        """
        return _geocal.CartesianInertial_reference_surface_intersect_approximate(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< CartesianInertial  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.CartesianInertial___str__(self)

    position = _swig_property(_geocal.CartesianInertial_position_get, _geocal.CartesianInertial_position_set)
    __swig_destroy__ = _geocal.delete_CartesianInertial
CartesianInertial.convert_to_cf = new_instancemethod(_geocal.CartesianInertial_convert_to_cf,None,CartesianInertial)
CartesianInertial.ci_to_cf = new_instancemethod(_geocal.CartesianInertial_ci_to_cf,None,CartesianInertial)
CartesianInertial.ci_to_cf_quat = new_instancemethod(_geocal.CartesianInertial_ci_to_cf_quat,None,CartesianInertial)
CartesianInertial.create = new_instancemethod(_geocal.CartesianInertial_create,None,CartesianInertial)
CartesianInertial.reference_surface_intersect_approximate = new_instancemethod(_geocal.CartesianInertial_reference_surface_intersect_approximate,None,CartesianInertial)
CartesianInertial.__str__ = new_instancemethod(_geocal.CartesianInertial___str__,None,CartesianInertial)
CartesianInertial_swigregister = _geocal.CartesianInertial_swigregister
CartesianInertial_swigregister(CartesianInertial)

class CartesianFixed(GroundCoordinate):
    """
    This gives the fixed Cartesian Coordinates for a ground coordinate.

    This is an abstract base class, there are CartesianFixed for the Earth
    ( Ecr), Mars (MarsFixed), etc.

    We want to be able to convert to and from CartesianInertial
    coordinates. However, we want to abstract out the toolkit used to do
    this. We use the toolkit pointed to by
    CartesianFixed::toolkit_coordinate_interface. If either SPICE or SDP
    is available, then that toolkit is the one used for the conversion. If
    we have both available, then we default to SPICE. You can change the
    choice by updating the variable
    CartesianFixed::toolkit_coordinate_interface.

    C++ includes: ground_coordinate.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def convert_to_ci(self, *args):
        """
        virtual boost::shared_ptr<CartesianInertial> GeoCal::CartesianFixed::convert_to_ci(const Time &T) const =0
        Convert to CartesianInertial. 
        """
        return _geocal.CartesianFixed_convert_to_ci(self, *args)

    def create(self, *args):
        """
        virtual boost::shared_ptr<CartesianFixed> GeoCal::CartesianFixed::create(boost::array< double, 3 > P) const =0
        Create an instance of whatever type of CartesianFixed this is. 
        """
        return _geocal.CartesianFixed_create(self, *args)

    def ci_to_cf(self, *args):
        """
        virtual void GeoCal::CartesianFixed::ci_to_cf(const Time &T, double Ci_to_cf[3][3]) const =0
        Calculate matrix that can be used to convert CartesianFixed to
        CartesianInertial at the given Time.

        The matrix for going from CartesianInertial to CartesianFixed is the
        transpose of this matrix. 
        """
        return _geocal.CartesianFixed_ci_to_cf(self, *args)

    def ci_to_cf_quat(self, *args):
        """
        boost::math::quaternion<double> GeoCal::CartesianFixed::ci_to_cf_quat(const Time &T) const
        Calculate quaternion that can be used to convert CartesianFixed to
        CartesianInertial at the given Time. 
        """
        return _geocal.CartesianFixed_ci_to_cf_quat(self, *args)

    def reference_surface_intersect_approximate(self, *args):
        """
        virtual boost::shared_ptr<CartesianFixed> GeoCal::CartesianFixed::reference_surface_intersect_approximate(const CartesianFixedLookVector &Cl, double
        Height_reference_surface=0) const =0
        Find the intersection with the surface at the given height starting at
        this point and looking in the given direction.

        The intersection is done in an approximate but quicker manner, see the
        derived classes for the approximation used. 
        """
        return _geocal.CartesianFixed_reference_surface_intersect_approximate(self, *args)

    def _min_radius_reference_surface(self):
        """
        virtual double GeoCal::CartesianFixed::min_radius_reference_surface() const =0
        This is the radius of the largest sphere that fits completely into the
        reference surface (e.g., radius for a reference sphere, minimum of a
        and b for a ellipsoid). 
        """
        return _geocal.CartesianFixed__min_radius_reference_surface(self)

    @property
    def min_radius_reference_surface(self):
        return self._min_radius_reference_surface()

    position = _swig_property(_geocal.CartesianFixed_position_get, _geocal.CartesianFixed_position_set)
    __swig_destroy__ = _geocal.delete_CartesianFixed
CartesianFixed.convert_to_ci = new_instancemethod(_geocal.CartesianFixed_convert_to_ci,None,CartesianFixed)
CartesianFixed.create = new_instancemethod(_geocal.CartesianFixed_create,None,CartesianFixed)
CartesianFixed.ci_to_cf = new_instancemethod(_geocal.CartesianFixed_ci_to_cf,None,CartesianFixed)
CartesianFixed.ci_to_cf_quat = new_instancemethod(_geocal.CartesianFixed_ci_to_cf_quat,None,CartesianFixed)
CartesianFixed.reference_surface_intersect_approximate = new_instancemethod(_geocal.CartesianFixed_reference_surface_intersect_approximate,None,CartesianFixed)
CartesianFixed._min_radius_reference_surface = new_instancemethod(_geocal.CartesianFixed__min_radius_reference_surface,None,CartesianFixed)
CartesianFixed_swigregister = _geocal.CartesianFixed_swigregister
CartesianFixed_swigregister(CartesianFixed)


def distance(*args):
  return _geocal.distance(*args)
distance = _geocal.distance
class Vector_GroundCoordinate(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_GroundCoordinate_swiginit(self,_geocal.new_Vector_GroundCoordinate(*args))
    __swig_destroy__ = _geocal.delete_Vector_GroundCoordinate
Vector_GroundCoordinate.iterator = new_instancemethod(_geocal.Vector_GroundCoordinate_iterator,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.__nonzero__ = new_instancemethod(_geocal.Vector_GroundCoordinate___nonzero__,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.__bool__ = new_instancemethod(_geocal.Vector_GroundCoordinate___bool__,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.__len__ = new_instancemethod(_geocal.Vector_GroundCoordinate___len__,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.pop = new_instancemethod(_geocal.Vector_GroundCoordinate_pop,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.__getslice__ = new_instancemethod(_geocal.Vector_GroundCoordinate___getslice__,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.__setslice__ = new_instancemethod(_geocal.Vector_GroundCoordinate___setslice__,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.__delslice__ = new_instancemethod(_geocal.Vector_GroundCoordinate___delslice__,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.__delitem__ = new_instancemethod(_geocal.Vector_GroundCoordinate___delitem__,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.__getitem__ = new_instancemethod(_geocal.Vector_GroundCoordinate___getitem__,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.__setitem__ = new_instancemethod(_geocal.Vector_GroundCoordinate___setitem__,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.append = new_instancemethod(_geocal.Vector_GroundCoordinate_append,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.empty = new_instancemethod(_geocal.Vector_GroundCoordinate_empty,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.size = new_instancemethod(_geocal.Vector_GroundCoordinate_size,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.clear = new_instancemethod(_geocal.Vector_GroundCoordinate_clear,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.swap = new_instancemethod(_geocal.Vector_GroundCoordinate_swap,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.get_allocator = new_instancemethod(_geocal.Vector_GroundCoordinate_get_allocator,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.begin = new_instancemethod(_geocal.Vector_GroundCoordinate_begin,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.end = new_instancemethod(_geocal.Vector_GroundCoordinate_end,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.rbegin = new_instancemethod(_geocal.Vector_GroundCoordinate_rbegin,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.rend = new_instancemethod(_geocal.Vector_GroundCoordinate_rend,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.pop_back = new_instancemethod(_geocal.Vector_GroundCoordinate_pop_back,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.erase = new_instancemethod(_geocal.Vector_GroundCoordinate_erase,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.push_back = new_instancemethod(_geocal.Vector_GroundCoordinate_push_back,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.front = new_instancemethod(_geocal.Vector_GroundCoordinate_front,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.back = new_instancemethod(_geocal.Vector_GroundCoordinate_back,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.assign = new_instancemethod(_geocal.Vector_GroundCoordinate_assign,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.resize = new_instancemethod(_geocal.Vector_GroundCoordinate_resize,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.insert = new_instancemethod(_geocal.Vector_GroundCoordinate_insert,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.reserve = new_instancemethod(_geocal.Vector_GroundCoordinate_reserve,None,Vector_GroundCoordinate)
Vector_GroundCoordinate.capacity = new_instancemethod(_geocal.Vector_GroundCoordinate_capacity,None,Vector_GroundCoordinate)
Vector_GroundCoordinate_swigregister = _geocal.Vector_GroundCoordinate_swigregister
Vector_GroundCoordinate_swigregister(Vector_GroundCoordinate)

class CoordinateConverter(object):
    """
    This class is used to convert from and to a particular coordinate
    system.

    There are some functions that can work equal well with any map
    coordinate system, and where we want the decision of what coordinate
    system to be made outside of the function (e.g., the program
    map_project, where the user selects the coordinate system to map
    project to).

    The solution we use here is to make use of the Strategy pattern (see
    "Design Patterns" by Erich Gamma et. al.). This class is the base
    class defining the interface to a general coordinate convertor.

    This class allows conversion to and from whatever coordinate system
    has been selected. The meaning of the X, Y, and Height value passed in
    and out of the functions depends on what concrete specialization of
    this class is used. For uses where the ambiguity isn't acceptable, it
    is not appropriate to use this class (i.e., the various Strategies of
    coordinate conversions aren't really exchangeable then).

    C++ includes: coordinate_converter.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def convert_from_coordinate(self, *args):
        """
        virtual boost::shared_ptr<GroundCoordinate> GeoCal::CoordinateConverter::convert_from_coordinate(double X, double Y, double Height=0) const =0
        This converts from a particular coordinate system, returning a ground
        coordinate for the given coordinates.

        The specific meaning and units of X, Y, and height depend on which
        coordinates system is used by a specialization of this class. 
        """
        return _geocal.CoordinateConverter_convert_from_coordinate(self, *args)

    def convert_to_coordinate(self, *args):
        """
        virtual void GeoCal::CoordinateConverter::convert_to_coordinate(const GroundCoordinate &Gc, double &X, double &Y, double &Height)
        const =0
        This converts from a ground coordinate to a particular coordinate
        system.

        The specific meaning and units of X, Y, and height depend on which
        coordinates system is used by a specialization of this class. 
        """
        return _geocal.CoordinateConverter_convert_to_coordinate(self, *args)

    def is_same(self, *args):
        """
        virtual bool GeoCal::CoordinateConverter::is_same(const CoordinateConverter &Conv) const =0
        Test if two CoordinateConverters are the same coordinate system. 
        """
        return _geocal.CoordinateConverter_is_same(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< CoordinateConverter  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.CoordinateConverter___str__(self)

    __swig_destroy__ = _geocal.delete_CoordinateConverter
CoordinateConverter.convert_from_coordinate = new_instancemethod(_geocal.CoordinateConverter_convert_from_coordinate,None,CoordinateConverter)
CoordinateConverter.convert_to_coordinate = new_instancemethod(_geocal.CoordinateConverter_convert_to_coordinate,None,CoordinateConverter)
CoordinateConverter.is_same = new_instancemethod(_geocal.CoordinateConverter_is_same,None,CoordinateConverter)
CoordinateConverter.__str__ = new_instancemethod(_geocal.CoordinateConverter___str__,None,CoordinateConverter)
CoordinateConverter_swigregister = _geocal.CoordinateConverter_swigregister
CoordinateConverter_swigregister(CoordinateConverter)

class GeodeticConverter(CoordinateConverter):
    """
    CoordinateConverter that goes to and from Geodetic coordinates.

    C++ includes: coordinate_converter.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def convert_from_coordinate(self, *args):
        """
        virtual boost::shared_ptr<GroundCoordinate> GeoCal::GeodeticConverter::convert_from_coordinate(double X, double Y, double Height=0) const
        Convert to geodetic.

        X and Y are longitude and latitude in degrees, and height is in
        meters. 
        """
        return _geocal.GeodeticConverter_convert_from_coordinate(self, *args)

    def __reduce__(self):
      return _new_from_init, (self.__class__,)
      
    def __init__(self): 
        _geocal.GeodeticConverter_swiginit(self,_geocal.new_GeodeticConverter())
    __swig_destroy__ = _geocal.delete_GeodeticConverter
GeodeticConverter.convert_from_coordinate = new_instancemethod(_geocal.GeodeticConverter_convert_from_coordinate,None,GeodeticConverter)
GeodeticConverter_swigregister = _geocal.GeodeticConverter_swigregister
GeodeticConverter_swigregister(GeodeticConverter)

class Ecr(CartesianFixed):
    """
    This is a ground coordinate, represented in ECR coordinates.

    C++ includes: ecr.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::Ecr::Ecr()
        Default constructor. 
        """
        _geocal.Ecr_swiginit(self,_geocal.new_Ecr(*args))
    def convert_to_geodetic(self):
        """
        Geodetic Ecr::convert_to_geodetic() const
        Convert to Geodetic coordinates. 
        """
        return _geocal.Ecr_convert_to_geodetic(self)

    def reference_surface_intersect_approximate(self, *args):
        """
        boost::shared_ptr< CartesianFixed > Ecr::reference_surface_intersect_approximate(const CartesianFixedLookVector &Cl, double
        Height_reference_surface=0) const
        Find the intersection with the surface at the given height starting at
        this point and looking in the given direction.

        The intersection is done in an approximate but quicker manner.

        We find the intersection with the ellipsoid that has the given height
        added to the equatorial and polar axis. This is not the same as the
        figure with a height h above the ellipsoid (which isn't an ellipsoid),
        but for many purposes this is close enough. 
        """
        return _geocal.Ecr_reference_surface_intersect_approximate(self, *args)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.position[0],self.position[1],self.position[2])

    __swig_destroy__ = _geocal.delete_Ecr
Ecr.convert_to_geodetic = new_instancemethod(_geocal.Ecr_convert_to_geodetic,None,Ecr)
Ecr.reference_surface_intersect_approximate = new_instancemethod(_geocal.Ecr_reference_surface_intersect_approximate,None,Ecr)
Ecr_swigregister = _geocal.Ecr_swigregister
Ecr_swigregister(Ecr)

class Eci(CartesianInertial):
    """
    This is a ECI coordinate (J2000)

    C++ includes: eci.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::Eci::Eci(const boost::array< double, 3 > &Pos)
        Create an Eci with the given position in meters. 
        """
        _geocal.Eci_swiginit(self,_geocal.new_Eci(*args))
    def reference_surface_intersect_approximate(self, *args):
        """
        boost::shared_ptr< CartesianInertial > Eci::reference_surface_intersect_approximate(const CartesianInertialLookVector &Cl, double
        Height_reference_surface=0) const
        Find the intersection with the surface at the given height starting at
        this point and looking in the given direction.

        The intersection is done in an approximate but quicker manner.

        We find the intersection with the ellipsoid that has the given height
        added to the equatorial and polar axis. This is not the same as the
        figure with a height h above the ellipsoid (which isn't an ellipsoid),
        but for many purposes this is close enough. 
        """
        return _geocal.Eci_reference_surface_intersect_approximate(self, *args)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.position[0],self.position[1],self.position[2])

    __swig_destroy__ = _geocal.delete_Eci
Eci.reference_surface_intersect_approximate = new_instancemethod(_geocal.Eci_reference_surface_intersect_approximate,None,Eci)
Eci_swigregister = _geocal.Eci_swigregister
Eci_swigregister(Eci)

class Geodetic(GroundCoordinate):
    """
    This is a ground coordinate, represented in Geodetic coordinates.

    C++ includes: geodetic.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::Geodetic::Geodetic()
        Default constructor. 
        """
        _geocal.Geodetic_swiginit(self,_geocal.new_Geodetic(*args))
    def __reduce__(self):
      return _new_from_init, (self.__class__, self.latitude,self.longitude,self.height_reference_surface)

    __swig_destroy__ = _geocal.delete_Geodetic
Geodetic_swigregister = _geocal.Geodetic_swigregister
Geodetic_swigregister(Geodetic)

class Geocentric(GroundCoordinate):
    """
    This is a ground coordinate, represented in Geocentric coordinates.

    C++ includes: geodetic.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::Geocentric::Geocentric()
        Default constructor. 
        """
        _geocal.Geocentric_swiginit(self,_geocal.new_Geocentric(*args))
    def __reduce__(self):
      return _new_from_init, (self.__class__, self.latitude,self.longitude,self.height_reference_surface)

    __swig_destroy__ = _geocal.delete_Geocentric
Geocentric_swigregister = _geocal.Geocentric_swigregister
Geocentric_swigregister(Geocentric)

class Dem(object):
    """
    This class gives an interface to a digital elevation model (DEM).

    C++ includes: dem.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def distance_to_surface(self, *args):
        """
        virtual double GeoCal::Dem::distance_to_surface(const GroundCoordinate &Gp) const =0
        Return distance to surface directly above/below the given point.

        Distance is in meters. Positive means Gp is above the surface,
        negative means below. 
        """
        return _geocal.Dem_distance_to_surface(self, *args)

    def height_reference_surface(self, *args):
        """
        virtual double GeoCal::Dem::height_reference_surface(const GroundCoordinate &Gp) const =0
        Return height of surface above/below the reference surface (e.g.,
        WGS-84 for the earth).

        Positive means above, negative below. This is in meters. 
        """
        return _geocal.Dem_height_reference_surface(self, *args)

    def intersect(self, *args):
        """
        boost::shared_ptr< CartesianFixed > Dem::intersect(const CartesianFixed &Cf, const CartesianFixedLookVector &Lv, double
        Resolution, double Max_height=9000) const
        Determine the intersection along a look vector from a starting
        position with the Dem (e.g., what point on the ground does a satellite
        see).

        This is brute force, so it won't mistakenly pick a plain behind a
        mountain.

        Resolution is the desired resolution in meters. Max_height is the
        maximum height we will encounter in the Dem - the default of 9 km is
        higher than the highest point in the world. 
        """
        return _geocal.Dem_intersect(self, *args)

    def surface_point(self, *args):
        """
        virtual boost::shared_ptr<GroundCoordinate> GeoCal::Dem::surface_point(const GroundCoordinate &Gp) const =0
        Return a GroundCoordinate on the surface directly above or below the
        given point. 
        """
        return _geocal.Dem_surface_point(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< Dem  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Dem___str__(self)

    __swig_destroy__ = _geocal.delete_Dem
Dem.distance_to_surface = new_instancemethod(_geocal.Dem_distance_to_surface,None,Dem)
Dem.height_reference_surface = new_instancemethod(_geocal.Dem_height_reference_surface,None,Dem)
Dem.intersect = new_instancemethod(_geocal.Dem_intersect,None,Dem)
Dem.surface_point = new_instancemethod(_geocal.Dem_surface_point,None,Dem)
Dem.__str__ = new_instancemethod(_geocal.Dem___str__,None,Dem)
Dem_swigregister = _geocal.Dem_swigregister
Dem_swigregister(Dem)

class MapInfo(object):
    """
    This contains information describing a map.

    This class is used to treat map projection information the same,
    regardless of the specific map projection used. However, the pixels of
    the map are required to be equally spaced in the X and Y coordinates
    of the underlying map projection.

    Note that the various coordinates (e.g., lrc_x()) are for the bounding
    box, not for the center of the lrc or ulc pixel.

    The parameters used in MapInfo are the affine parameters, see for
    example GeoTiff. Note though that by convention we use the middle of
    the ulc pixel is at (0,0), and the upper left corner of the pixel is
    at (-0.5, -0.5). The parameters on the other hand have the center of
    the ulc pixel at (0.5, 0.5) and the upper left corner of the pixel at
    (0, 0). This class handles this difference, but we mention this in
    this comment so you can understand where the various "0.5" terms
    come in.

    C++ includes: map_info.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        MapInfo::MapInfo(const boost::shared_ptr< CoordinateConverter > &Conv, const
        blitz::Array< double, 1 > &Param, int Number_x_pixel, int
        Number_y_pixel)
        Constructor that takes the affine parameters.

        Note that the parameters should be such that the ulc is at coordinates
        -0.5, 0.5. This is the same as "area based pixels", if you are using
        Geotiff. 
        """
        _geocal.MapInfo_swiginit(self,_geocal.new_MapInfo(*args))
    def _coordinate_converter(self):
        """
        const boost::shared_ptr<CoordinateConverter>& GeoCal::MapInfo::coordinate_converter_ptr() const
        Pointer to Coordinate converter used by map projection. 
        """
        return _geocal.MapInfo__coordinate_converter(self)

    @property
    def coordinate_converter(self):
        return self._coordinate_converter()

    def coordinate(self, *args):
        """
        void MapInfo::coordinate(const GroundCoordinate &Gc, double &Pixel_x_index, double
        &Pixel_y_index) const
        Determine pixel coordinates for the given ground coordinates.

        Note that this routine can be called with ground coordiantes outside
        of the bounding box of the map, it just returns pixel coordinates
        outside of the map in that case. 
        """
        return _geocal.MapInfo_coordinate(self, *args)

    def cover(self, *args):
        """
        MapInfo MapInfo::cover(const std::vector< boost::shared_ptr< GroundCoordinate > > &Pt, int
        boundary=0) const
        Create a MapInfo that has the same map projection and pixel resolution
        as this one, but covers the given set of points.

        An optional boundary can be given, this adds a boundary of the given
        number of pixels on each edge of the resulting MapInfo. 
        """
        return _geocal.MapInfo_cover(self, *args)

    def ground_coordinate(self, *args):
        """
        boost::shared_ptr< GroundCoordinate > MapInfo::ground_coordinate(double Pixel_x_index, double Pixel_y_index) const
        Convert pixel coordinates to ground coordinates. 
        """
        return _geocal.MapInfo_ground_coordinate(self, *args)

    def intersection(self, *args):
        """
        MapInfo MapInfo::intersection(const MapInfo &Mi) const
        This finds a rectangle box in the map projection and pixel size of
        this class that contains the intersection with the second map info Mi.

        """
        return _geocal.MapInfo_intersection(self, *args)

    def map_union(self, *args):
        """
        MapInfo MapInfo::map_union(const MapInfo &Mi) const
        This finds a rectangle box in the map projection and pixel size of
        this class that contains the union with the second map info Mi.

        Note we call this "map_union" because "union" is a reserved word
        in C++. 
        """
        return _geocal.MapInfo_map_union(self, *args)

    def index_to_coordinate(self, *args):
        """
        void GeoCal::MapInfo::index_to_coordinate(double Pixel_x_index, double Pixel_y_index, double
        &Pixel_x_coordinate, double &Pixel_y_coordinate) const
        Convert pixel index to pixel coordinate. 
        """
        return _geocal.MapInfo_index_to_coordinate(self, *args)

    def coordinate_to_index(self, *args):
        """
        void GeoCal::MapInfo::coordinate_to_index(double Pixel_x_coordinate, double Pixel_y_coordinate, double
        &Pixel_x_index, double &Pixel_y_index) const
        Convert pixel coordinate to pixel index. 
        """
        return _geocal.MapInfo_coordinate_to_index(self, *args)

    def _lrc_x(self):
        """
        double GeoCal::MapInfo::lrc_x() const
        X of lower right corner.

        Note that this is for the outer edge of the pixel, not the center
        (i.e., for the bounding box). 
        """
        return _geocal.MapInfo__lrc_x(self)

    @property
    def lrc_x(self):
        return self._lrc_x()

    def _lrc_y(self):
        """
        double GeoCal::MapInfo::lrc_y() const
        Y of lower right corner.

        Note that this is for the outer edge of the pixel, not the center
        (i.e., for the bounding box). 
        """
        return _geocal.MapInfo__lrc_y(self)

    @property
    def lrc_y(self):
        return self._lrc_y()

    def _number_x_pixel(self):
        """
        int GeoCal::MapInfo::number_x_pixel() const
        Number of pixels in X direction. 
        """
        return _geocal.MapInfo__number_x_pixel(self)

    @property
    def number_x_pixel(self):
        return self._number_x_pixel()

    def _number_y_pixel(self):
        """
        int GeoCal::MapInfo::number_y_pixel() const
        Number of pixels in Y direction. 
        """
        return _geocal.MapInfo__number_y_pixel(self)

    @property
    def number_y_pixel(self):
        return self._number_y_pixel()

    def _resolution_meter(self):
        """
        double MapInfo::resolution_meter() const
        Return the approximate resolution of the MapInfo in meters.

        This looks at the center of the map, + 1 in the X and Y direction. We
        determine the distance between these points, and select the maximum of
        them. 
        """
        return _geocal.MapInfo__resolution_meter(self)

    @property
    def resolution_meter(self):
        return self._resolution_meter()

    def subset(self, *args):
        """
        MapInfo MapInfo::subset(int x_index, int y_index, int nx_pixel, int ny_pixel) const
        Return a MapInfo for a subset of this map info.

        Note that it is ok for x_index and y_index to be outside the range of
        the MapInfo, so you could use this function to get a MapInfo for a
        larger area or an area next to this one. 
        """
        return _geocal.MapInfo_subset(self, *args)

    def scale(self, *args):
        """
        MapInfo MapInfo::scale(double Number_x_per_pixel, double Number_y_per_pixel) const
        Create a MapInfo that has the same upper left corner, and a pixel size
        scaled by the given number of line and samples per pixel.

        Note that in general this won't exactly cover this MapInfo, we trim
        lower left corner if needed to be the largest MapInfo that fits in
        this MapInfo. 
        """
        return _geocal.MapInfo_scale(self, *args)

    def _ulc_x(self):
        """
        double GeoCal::MapInfo::ulc_x() const
        X of upper left corner.

        Note that this is for the outer edge of the pixel, not the center
        (i.e., for the bounding box). 
        """
        return _geocal.MapInfo__ulc_x(self)

    @property
    def ulc_x(self):
        return self._ulc_x()

    def _ulc_y(self):
        """
        double GeoCal::MapInfo::ulc_y() const
        Y of upper left corner.

        Note that this is for the outer edge of the pixel, not the center
        (i.e., for the bounding box). 
        """
        return _geocal.MapInfo__ulc_y(self)

    @property
    def ulc_y(self):
        return self._ulc_y()

    def _transform(self):
        """
        blitz::Array<double, 1> GeoCal::MapInfo::transform() const
        This is the affine geometric transformation used by the MapInfo.

        You don't normally use this directly, but it is useful when writing
        out file metadata, e.g., with Gdal SetGeoTransform. 
        """
        return _geocal.MapInfo__transform(self)

    @property
    def transform(self):
        return self._transform()

    def __str__(self):
        """
        std::string GeoCal::Printable< MapInfo  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.MapInfo___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.coordinate_converter,self.transform,self.number_x_pixel,self.number_y_pixel)

    __swig_destroy__ = _geocal.delete_MapInfo
MapInfo._coordinate_converter = new_instancemethod(_geocal.MapInfo__coordinate_converter,None,MapInfo)
MapInfo.coordinate = new_instancemethod(_geocal.MapInfo_coordinate,None,MapInfo)
MapInfo.cover = new_instancemethod(_geocal.MapInfo_cover,None,MapInfo)
MapInfo.ground_coordinate = new_instancemethod(_geocal.MapInfo_ground_coordinate,None,MapInfo)
MapInfo.intersection = new_instancemethod(_geocal.MapInfo_intersection,None,MapInfo)
MapInfo.map_union = new_instancemethod(_geocal.MapInfo_map_union,None,MapInfo)
MapInfo.index_to_coordinate = new_instancemethod(_geocal.MapInfo_index_to_coordinate,None,MapInfo)
MapInfo.coordinate_to_index = new_instancemethod(_geocal.MapInfo_coordinate_to_index,None,MapInfo)
MapInfo._lrc_x = new_instancemethod(_geocal.MapInfo__lrc_x,None,MapInfo)
MapInfo._lrc_y = new_instancemethod(_geocal.MapInfo__lrc_y,None,MapInfo)
MapInfo._number_x_pixel = new_instancemethod(_geocal.MapInfo__number_x_pixel,None,MapInfo)
MapInfo._number_y_pixel = new_instancemethod(_geocal.MapInfo__number_y_pixel,None,MapInfo)
MapInfo._resolution_meter = new_instancemethod(_geocal.MapInfo__resolution_meter,None,MapInfo)
MapInfo.subset = new_instancemethod(_geocal.MapInfo_subset,None,MapInfo)
MapInfo.scale = new_instancemethod(_geocal.MapInfo_scale,None,MapInfo)
MapInfo._ulc_x = new_instancemethod(_geocal.MapInfo__ulc_x,None,MapInfo)
MapInfo._ulc_y = new_instancemethod(_geocal.MapInfo__ulc_y,None,MapInfo)
MapInfo._transform = new_instancemethod(_geocal.MapInfo__transform,None,MapInfo)
MapInfo.__str__ = new_instancemethod(_geocal.MapInfo___str__,None,MapInfo)
MapInfo_swigregister = _geocal.MapInfo_swigregister
MapInfo_swigregister(MapInfo)

def _new_rpc(is_rpc_a, error_bias, error_random, height_offset, 
             height_scale, latitude_offset,
             latitude_scale, longitude_offset, longitude_scale,
             line_offset, line_scale, sample_offset, sample_scale,
             line_denominator, line_numerator, sample_denominator,
             sample_numerator, fit_line_numerator, fit_sample_numerator):
    rpc = Rpc()
    rpc.rpc_type = Rpc.RPC_A if(is_rpc_a) else Rpc.RPC_B
    rpc.error_bias = error_bias
    rpc.error_random = error_random				
    rpc.height_offset = height_offset
    rpc.height_scale = height_scale
    rpc.latitude_offset = latitude_offset
    rpc.latitude_scale = latitude_scale
    rpc.longitude_offset = longitude_offset
    rpc.longitude_scale = longitude_scale
    rpc.line_offset = line_offset
    rpc.line_scale = line_scale
    rpc.sample_offset = sample_offset
    rpc.sample_scale = sample_scale
    rpc.line_denominator.set(line_denominator)
    rpc.line_numerator.set(line_numerator)
    rpc.sample_denominator.set(sample_denominator)
    rpc.sample_numerator.set(sample_numerator)
    rpc.fit_line_numerator.set(fit_line_numerator)
    rpc.fit_sample_numerator.set(fit_sample_numerator)
    return rpc

class Rpc(object):
    """
    This is used to handle RPC (Rational Polynomial Coefficients).

    RPC is an alternative to using a rigorous camera/orbit model to map
    project satellite data.

    This is a common technique, and there are numerous references. One
    reference is Fraser, CS, Dial, G, Grodecki, J "Sensor orientation via
    RPCs" ISPRS J PHOTOGRAMM 60 (3): 182-194 MAY 2006.

    Note that there are two versions of the RPCs, type "A" and type
    "B". The difference is the order of the terms. The military tends to
    use "A" and the rest of the world tends to use "B". This class
    supports both types, based on the setting of the rpc_type variable.

    By definition of RPC, the leading term of the denominator coefficient
    should be 1.0 - so there are 20 degrees of freedom for the numerator
    but only 19 for the denominator. After some debate, I decided to do
    nothing in this class to enforce this restriction, you can assign a
    value other than 1 to the first coefficient of the denominator.
    However, this class will complain when you actually try to use this.

    The definition of line, sample and height offset and scale allow these
    numbers to be floats. However file formats such as geotiff and NITF
    treat these as integers. If you store a RPC into a file with one of
    these formats, the data will be truncated. If you plan on saving to
    one of these formats, you should be aware of this and keep these an
    whole numbers. This limitation is not present in the VICAR file
    format.

    C++ includes: geocal_rpc.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __reduce__(self):
      return _new_rpc, (self.rpc_type == Rpc.RPC_A,
    		    self.error_bias,
                        self.error_random,
    		    self.height_offset,
    		    self.height_scale,
    		    self.latitude_offset,
    		    self.latitude_scale,
    		    self.longitude_offset,
    		    self.longitude_scale,
    		    self.line_offset,
    		    self.line_scale,
    		    self.sample_offset,
    		    self.sample_scale,
    		    list(self.line_denominator),
    		    list(self.line_numerator),
    		    list(self.sample_denominator),
    		    list(self.sample_numerator),
    		    list(self.fit_line_numerator),
    		    list(self.fit_sample_numerator))

    def __str__(self):
        """
        std::string GeoCal::Printable< Rpc  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Rpc___str__(self)

    RPC_A = _geocal.Rpc_RPC_A
    RPC_B = _geocal.Rpc_RPC_B
    rpc_type = _swig_property(_geocal.Rpc_rpc_type_get, _geocal.Rpc_rpc_type_set)
    error_bias = _swig_property(_geocal.Rpc_error_bias_get, _geocal.Rpc_error_bias_set)
    error_random = _swig_property(_geocal.Rpc_error_random_get, _geocal.Rpc_error_random_set)
    height_offset = _swig_property(_geocal.Rpc_height_offset_get, _geocal.Rpc_height_offset_set)
    height_scale = _swig_property(_geocal.Rpc_height_scale_get, _geocal.Rpc_height_scale_set)
    latitude_offset = _swig_property(_geocal.Rpc_latitude_offset_get, _geocal.Rpc_latitude_offset_set)
    latitude_scale = _swig_property(_geocal.Rpc_latitude_scale_get, _geocal.Rpc_latitude_scale_set)
    longitude_offset = _swig_property(_geocal.Rpc_longitude_offset_get, _geocal.Rpc_longitude_offset_set)
    longitude_scale = _swig_property(_geocal.Rpc_longitude_scale_get, _geocal.Rpc_longitude_scale_set)
    line_offset = _swig_property(_geocal.Rpc_line_offset_get, _geocal.Rpc_line_offset_set)
    line_scale = _swig_property(_geocal.Rpc_line_scale_get, _geocal.Rpc_line_scale_set)
    sample_offset = _swig_property(_geocal.Rpc_sample_offset_get, _geocal.Rpc_sample_offset_set)
    sample_scale = _swig_property(_geocal.Rpc_sample_scale_get, _geocal.Rpc_sample_scale_set)
    line_denominator = _swig_property(_geocal.Rpc_line_denominator_get, _geocal.Rpc_line_denominator_set)
    line_numerator = _swig_property(_geocal.Rpc_line_numerator_get, _geocal.Rpc_line_numerator_set)
    sample_denominator = _swig_property(_geocal.Rpc_sample_denominator_get, _geocal.Rpc_sample_denominator_set)
    sample_numerator = _swig_property(_geocal.Rpc_sample_numerator_get, _geocal.Rpc_sample_numerator_set)
    fit_line_numerator = _swig_property(_geocal.Rpc_fit_line_numerator_get, _geocal.Rpc_fit_line_numerator_set)
    fit_sample_numerator = _swig_property(_geocal.Rpc_fit_sample_numerator_get, _geocal.Rpc_fit_sample_numerator_set)
    def resolution_meter(self, *args):
        """
        double Rpc::resolution_meter(const Dem &D) const
        Calculate the approximate resolution on the ground.

        This finds the intersection for the center pixel with the surface + 1
        in the line and sample direction. We find the difference in meters
        between these points, and select the maximum value. We the height from
        the Dem. 
        """
        return _geocal.Rpc_resolution_meter(self, *args)

    def fit(self, *args):
        """
        void Rpc::fit(const std::vector< boost::shared_ptr< GroundCoordinate > > &Gc, const
        std::vector< ImageCoordinate > &Ic, const std::vector< double >
        &Line_sigma, const std::vector< double > &Sample_sigma, std::set< int
        > &Blunder, double Blunder_threshold=3, double Chisq_threshold=0.8,
        bool Blunder_detect=true)
        This updates the RPC parameters to better match a given set of data.

        This class takes a list of GroundCoordinates, and the ImageCoordinate
        that should be returned by the RPC. Each of the ImageCoordinate has
        and associated line and sample sigma used to weight it (i.e., the line
        and sigma returned by ImageMatcher).

        We update the set of parameters given by fit_line_numerator and
        fit_sample_numerator. Right now, we only do a linear fit and don't try
        to fit the nonlinear denominator pieces. We can add that in the future
        if it is needed.

        The blunder detection used is iterative data snooping, where the point
        with the largest standardized residual is removed. If the Chisq of the
        match improves by the Chisq_threshold, we toss the point out,
        otherwise we keep it. We then proceed to the next largest residual,
        and so.

        However, if we expect large numbers of blunders in otherwise well
        matched data (e.g., image matching between two images with lots of
        differences), it might be preferable to toss out all large outliers.
        So, if Chisq_threshold is >= 1 we just toss out all points outside of
        the Blunder_threshold. 
        """
        return _geocal.Rpc_fit(self, *args)

    def fit_all(self, *args):
        """
        void Rpc::fit_all(const std::vector< double > &Line, const std::vector< double >
        &Sample, const std::vector< double > &Latitude, const std::vector<
        double > &Longitude, const std::vector< double > &Height)
        You may not want to use this function directly, but rather use
        Rpc::generate_rpc which sets up the entire RPC.

        This is a low level function used to create an RPC that matches a set
        of data. The RPC should have already had the various offset and scales
        filled in. This function then fills in line_denominator,
        line_numerator, sample_denominator, and sample_numerator.

        This fits all of the rpc parameters (the full 78 parameters) doing a
        linear least squares fit. This doesn't to any blunder detection, or
        allow a subset to be used.

        The idea is that through some other method you can determine latitude,
        longitude, height vs line, sample (e.g., using a Orbit and Camera).
        You then generate a regular set of points, set up the offset and
        scale, and finally call this function to fit the RPC. 
        """
        return _geocal.Rpc_fit_all(self, *args)

    def generate_rpc(*args):
        """
        Rpc Rpc::generate_rpc(const ImageGroundConnection &Igc, double Min_height, double
        Max_height, int Nlat=20, int Nlon=20, int Nheight=20)
        Generate a RPC that approximates the calculation done by a
        ImageGroundConnection.

        We determine that latitude and longitude range to use automatically to
        cover the range given by the ImageGroundConnection. 
        """
        return _geocal.Rpc_generate_rpc(*args)

    generate_rpc = staticmethod(generate_rpc)
    def ground_coordinate(self, *args):
        """
        Geodetic Rpc::ground_coordinate(const ImageCoordinate &Ic, const Dem &D) const
        Invert the RPC to find the ground coordinate that maps to a give
        ImageCoordinate.

        This routine may fail to find a solution, in which case a
        ConvergenceFailure exception will be thrown. 
        """
        return _geocal.Rpc_ground_coordinate(self, *args)

    def image_coordinate(self, *args):
        """
        blitz::Array<double, N + 1> GeoCal::Rpc::image_coordinate(const blitz::Array< double, N > &Latitude, const blitz::Array<
        double, N > &Longitude, const blitz::Array< double, N >
        &Height_ellipsoid) const
        Convert from object space to image space (i.e., calculate RPC).

        The longitude and latitude are given in degrees (this is the geodetic
        latitude). The height is in meters, relative to the reference
        ellipsoid (e.g., WGS-84).

        This converts a whole block of latitude, longitude and height points
        at once. The results returned have a first dimension of 2, the first
        value is line and the second sample. 
        """
        return _geocal.Rpc_image_coordinate(self, *args)

    def image_coordinate_jac_parm(self, *args):
        """
        blitz::Array<double, 2> GeoCal::Rpc::image_coordinate_jac_parm(const GroundCoordinate &Gc) const
        Jacobian of image_coordinate with respect to the parameters that are
        marked as ones we are fitting.

        This has two rows, the first is for line and the second sample. The
        columns are first the true values in fit_line_numerator, and then
        fit_sample_numerator. 
        """
        return _geocal.Rpc_image_coordinate_jac_parm(self, *args)

    def image_coordinate_jac(self, *args):
        """
        blitz::Array<double, 2> GeoCal::Rpc::image_coordinate_jac(double Latitude, double Longitude, double Height_ellipsoid) const
        Jacobian of image_coordinate with respect to the Latitude, Longitude,
        and Height_ellipsoid.

        This is a 2 x 3 matrix, with the first row being line and the second
        sample. The columns are in Latitude, Longitude and Height_ellipsoid
        order. 
        """
        return _geocal.Rpc_image_coordinate_jac(self, *args)

    def rpc_project(self, *args):
        """
        void Rpc::rpc_project(RasterImage &Res, const RasterImage &Img, const Dem &D, double
        Line_scale=1.0, double Sample_scale=1.0) const
        This uses the RPC to project a RasterImage to a MapInfo.

        On entry, the RasterImage Res should already have the size and MapInfo
        that we want to project to.

        In some cases, Img might be a lower resolution image than is described
        by the RPC (e.g., we are imaging matching 60 cm Quickbird data to 5 m
        CIB data, so we down sample by a factor of 9). In those cases, a scale
        to apply to the line and sample returned by the RPC before looking
        into Img can be given. The default value is to not scale. 
        """
        return _geocal.Rpc_rpc_project(self, *args)

    def rpc_type_a(self):
        """
        Rpc Rpc::rpc_type_a() const
        This return a Rpc that has type RPC_A.

        If this rpc is already type RPC_A, then this is just a copy. Otherwise
        we rearrange the coefficients to give a type RPC_A. 
        """
        return _geocal.Rpc_rpc_type_a(self)

    def rpc_type_b(self):
        """
        Rpc Rpc::rpc_type_b() const
        This return a Rpc that has type RPC_B.

        If this rpc is already type RPC_B, then this is just a copy. Otherwise
        we rearrange the coefficients to give a type RPC_B. 
        """
        return _geocal.Rpc_rpc_type_b(self)

    def __init__(self): 
        """
        Rpc::Rpc()
        Default constructor.

        Initializes fit_line_numerator and fit_sample_numerator to all false.

        """
        _geocal.Rpc_swiginit(self,_geocal.new_Rpc())
    __swig_destroy__ = _geocal.delete_Rpc
Rpc.__str__ = new_instancemethod(_geocal.Rpc___str__,None,Rpc)
Rpc.resolution_meter = new_instancemethod(_geocal.Rpc_resolution_meter,None,Rpc)
Rpc.fit = new_instancemethod(_geocal.Rpc_fit,None,Rpc)
Rpc.fit_all = new_instancemethod(_geocal.Rpc_fit_all,None,Rpc)
Rpc.ground_coordinate = new_instancemethod(_geocal.Rpc_ground_coordinate,None,Rpc)
Rpc.image_coordinate = new_instancemethod(_geocal.Rpc_image_coordinate,None,Rpc)
Rpc.image_coordinate_jac_parm = new_instancemethod(_geocal.Rpc_image_coordinate_jac_parm,None,Rpc)
Rpc.image_coordinate_jac = new_instancemethod(_geocal.Rpc_image_coordinate_jac,None,Rpc)
Rpc.rpc_project = new_instancemethod(_geocal.Rpc_rpc_project,None,Rpc)
Rpc.rpc_type_a = new_instancemethod(_geocal.Rpc_rpc_type_a,None,Rpc)
Rpc.rpc_type_b = new_instancemethod(_geocal.Rpc_rpc_type_b,None,Rpc)
Rpc_swigregister = _geocal.Rpc_swigregister
Rpc_swigregister(Rpc)

def Rpc_generate_rpc(*args):
  """
    Rpc Rpc::generate_rpc(const ImageGroundConnection &Igc, double Min_height, double
    Max_height, int Nlat=20, int Nlon=20, int Nheight=20)
    Generate a RPC that approximates the calculation done by a
    ImageGroundConnection.

    We determine that latitude and longitude range to use automatically to
    cover the range given by the ImageGroundConnection. 
    """
  return _geocal.Rpc_generate_rpc(*args)

class RasterImageTileIterator(object):
    """
    It can be useful to step through a Raster Image in tiles.

    This is a helper class for RasterImage to do this.

    C++ includes: raster_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        RasterImageTileIterator::RasterImageTileIterator(const RasterImage &Ri, int Number_tile_line, int Number_tile_sample)
        Constructor, where we supply a tile size to use (which may be
        different than Ri's tile size). 
        """
        _geocal.RasterImageTileIterator_swiginit(self,_geocal.new_RasterImageTileIterator(*args))
    def _istart(self):
        """
        int GeoCal::RasterImageTileIterator::istart() const

        """
        return _geocal.RasterImageTileIterator__istart(self)

    @property
    def istart(self):
        return self._istart()

    def _jstart(self):
        """
        int GeoCal::RasterImageTileIterator::jstart() const

        """
        return _geocal.RasterImageTileIterator__jstart(self)

    @property
    def jstart(self):
        return self._jstart()

    def _iend(self):
        """
        int GeoCal::RasterImageTileIterator::iend() const

        """
        return _geocal.RasterImageTileIterator__iend(self)

    @property
    def iend(self):
        return self._iend()

    def _jend(self):
        """
        int GeoCal::RasterImageTileIterator::jend() const

        """
        return _geocal.RasterImageTileIterator__jend(self)

    @property
    def jend(self):
        return self._jend()

    def _number_line(self):
        """
        int GeoCal::RasterImageTileIterator::number_line() const

        """
        return _geocal.RasterImageTileIterator__number_line(self)

    @property
    def number_line(self):
        return self._number_line()

    def _number_sample(self):
        """
        int GeoCal::RasterImageTileIterator::number_sample() const

        """
        return _geocal.RasterImageTileIterator__number_sample(self)

    @property
    def number_sample(self):
        return self._number_sample()

    def _end(self):
        """
        bool GeoCal::RasterImageTileIterator::end() const

        """
        return _geocal.RasterImageTileIterator__end(self)

    @property
    def end(self):
        return self._end()

    def __str__(self):
        """
        std::string GeoCal::Printable< RasterImageTileIterator  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.RasterImageTileIterator___str__(self)

    __swig_destroy__ = _geocal.delete_RasterImageTileIterator
RasterImageTileIterator._istart = new_instancemethod(_geocal.RasterImageTileIterator__istart,None,RasterImageTileIterator)
RasterImageTileIterator._jstart = new_instancemethod(_geocal.RasterImageTileIterator__jstart,None,RasterImageTileIterator)
RasterImageTileIterator._iend = new_instancemethod(_geocal.RasterImageTileIterator__iend,None,RasterImageTileIterator)
RasterImageTileIterator._jend = new_instancemethod(_geocal.RasterImageTileIterator__jend,None,RasterImageTileIterator)
RasterImageTileIterator._number_line = new_instancemethod(_geocal.RasterImageTileIterator__number_line,None,RasterImageTileIterator)
RasterImageTileIterator._number_sample = new_instancemethod(_geocal.RasterImageTileIterator__number_sample,None,RasterImageTileIterator)
RasterImageTileIterator._end = new_instancemethod(_geocal.RasterImageTileIterator__end,None,RasterImageTileIterator)
RasterImageTileIterator.next = new_instancemethod(_geocal.RasterImageTileIterator_next,None,RasterImageTileIterator)
RasterImageTileIterator.__str__ = new_instancemethod(_geocal.RasterImageTileIterator___str__,None,RasterImageTileIterator)
RasterImageTileIterator_swigregister = _geocal.RasterImageTileIterator_swigregister
RasterImageTileIterator_swigregister(RasterImageTileIterator)

class RasterImage(object):
    """
    This is a general image class.

    Conceptually, an image is just a two dimensional array of integers,
    although it is not necessarily implemented this way. This is an
    abstract class, containing behavior common to all images. It handles
    keeping track of the size of the image, but all other behaviour needs
    to be defined by subclasses.

    It is common for Raster data to be stored on disk as a series of
    tiles. It can be significantly more efficient to access and write the
    data in tiles. To support this, we provide a "preferred" tile size
    given by number_tile_line() and number_tile_sample(). Classes using a
    RasterImage are free to ignore this tiling - data can be read and
    written in any order desired, and the only impact of tiles is in the
    performance.

    It is very common to want to step through a file "efficiently".
    There is a macro "RASTER_FOREACH(Img, IND1, IND2)" that steps
    through a given raster image, setting the index variable IND1 and IND2
    to the line and samples. This steps through by tiles, so it avoids
    reading the same tile multiple times. If you need to step through by
    tiles (rather than looping through all line and samples), the class
    RasterImageTileIterator can be used.

    The default tile size is the entire image, derived classes can supply
    other values if desired.

    A RasterImage may or may not have a Rpc and MapInfo associated with
    it. You can query has_rpc() and has_mapinfo() to find out if it has
    this metadata, and if it does you can access this by rpc() and
    map_info().

    C++ includes: raster_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def overview(self, *args):
        """
        virtual boost::shared_ptr<RasterImage> GeoCal::RasterImage::overview(int Min_number_sample) const
        Some RasterImage may have overviews which are lower resolution images.

        If we do have these, then this will return the lower resolution
        RasterImage that has at least the given number of samples. If we don't
        have an overview, this returns a null - which the calling routine
        needs to be ready to handle. 
        """
        return _geocal.RasterImage_overview(self, *args)

    def interpolate_derivative(self, *args):
        """
        boost::array<double, 2> GeoCal::RasterImage::interpolate_derivative(double Line, double Sample) const
        This calculates the derivative of interpolate with respect to Line and
        Sample.

        First entry in results is derivative with respect to Line, the second
        is with respect to the Sample. 
        """
        return _geocal.RasterImage_interpolate_derivative(self, *args)

    def interpolate(self, *args):
        """
        double GeoCal::RasterImage::interpolate(const ImageCoordinate &Ic) const
        This does a bilinear interpolation of the data for fractional Line and
        Sample. 
        """
        return _geocal.RasterImage_interpolate(self, *args)

    def _number_line(self):
        """
        virtual int GeoCal::RasterImage::number_line() const =0
        Return number of lines in the image. 
        """
        return _geocal.RasterImage__number_line(self)

    @property
    def number_line(self):
        return self._number_line()

    def _number_sample(self):
        """
        virtual int GeoCal::RasterImage::number_sample() const =0
        Return number of samples in the image. 
        """
        return _geocal.RasterImage__number_sample(self)

    @property
    def number_sample(self):
        return self._number_sample()

    def _number_tile_line(self):
        """
        virtual int GeoCal::RasterImage::number_tile_line() const
        Number of lines in the preferred tile size.

        Default is the entire image. 
        """
        return _geocal.RasterImage__number_tile_line(self)

    @property
    def number_tile_line(self):
        return self._number_tile_line()

    def _number_tile_sample(self):
        """
        virtual int GeoCal::RasterImage::number_tile_sample() const
        Number of samples in the preferred tile size.

        Default is the entire image. 
        """
        return _geocal.RasterImage__number_tile_sample(self)

    @property
    def number_tile_sample(self):
        return self._number_tile_sample()

    def read_double(self, *args):
        """
        blitz::Array< double, 2 > RasterImage::read_double(int Lstart, int Sstart, int Number_line, int Number_sample) const
        Some raster images actually are floating point values (e.g., a
        CalcRaster).

        This function gives access to the underlying floating point numbers.
        The default function here just returns the result of read as a double,
        but derived classes can override this. 
        """
        return _geocal.RasterImage_read_double(self, *args)

    def read(self, *args):
        """
        blitz::Array< int, 2 > RasterImage::read(const RasterImageTileIterator &Ti) const
        Return a subset of the image. 
        """
        return _geocal.RasterImage_read(self, *args)

    def write(self, *args):
        """
        void RasterImage::write(int Lstart, int Sstart, const blitz::Array< int, 2 > &A)

        """
        return _geocal.RasterImage_write(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< RasterImage  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.RasterImage___str__(self)

    def _has_map_info(self):
        """
        virtual bool GeoCal::RasterImage::has_map_info() const
        Functions available if we have MapInfo data.

        Indicate if we have MapInfo. The default is false, but derived classes
        can override this. 
        """
        return _geocal.RasterImage__has_map_info(self)

    @property
    def has_map_info(self):
        return self._has_map_info()

    def _map_info(self):
        """
        virtual const MapInfo& GeoCal::RasterImage::map_info() const
        MapInfo for image. 
        """
        return _geocal.RasterImage__map_info(self)

    @property
    def map_info(self):
        return self._map_info()

    def ground_coordinate(self, *args):
        """
        boost::shared_ptr<GroundCoordinate> GeoCal::RasterImage::ground_coordinate(double Line, double Sample, const Dem &D) const
        Shortcut to calling mapinfo().ground_coordinate. 
        """
        return _geocal.RasterImage_ground_coordinate(self, *args)

    def coordinate(self, *args):
        """
        ImageCoordinate GeoCal::RasterImage::coordinate(const GroundCoordinate &Gc) const
        Shortcut to calling mapinfo().coordinate. 
        """
        return _geocal.RasterImage_coordinate(self, *args)

    def _grid_center_line_resolution(self):
        """
        double RasterImage::grid_center_line_resolution() const
        This calculates the grid resolution in meters for the center of the
        grid in the line direction.

        This is just the distance between The center pixel number_line() / 2,
        number_sample() / 2 and the pixel number_line() / 2 + 1,
        number_sample() / 2. 
        """
        return _geocal.RasterImage__grid_center_line_resolution(self)

    @property
    def grid_center_line_resolution(self):
        return self._grid_center_line_resolution()

    def _grid_center_sample_resolution(self):
        """
        double RasterImage::grid_center_sample_resolution() const
        This calculates the grid resolution in meters for the center of the
        grid in the sample direction.

        This is just the distance between The center pixel number_line() / 2,
        number_sample() / 2 and the pixel number_line() / 2, number_sample() /
        2 + 1. 
        """
        return _geocal.RasterImage__grid_center_sample_resolution(self)

    @property
    def grid_center_sample_resolution(self):
        return self._grid_center_sample_resolution()

    def _has_rpc(self):
        """
        virtual bool GeoCal::RasterImage::has_rpc() const
        Functions available if we have RPC

        Indicate if we have Rpc. The default is false, but derived classes can
        override this. 
        """
        return _geocal.RasterImage__has_rpc(self)

    @property
    def has_rpc(self):
        return self._has_rpc()

    def _rpc(self):
        """
        virtual Rpc GeoCal::RasterImage::rpc() const
        Rpc for image. 
        """
        return _geocal.RasterImage__rpc(self)

    @property
    def rpc(self):
        return self._rpc()

    __swig_destroy__ = _geocal.delete_RasterImage
RasterImage.overview = new_instancemethod(_geocal.RasterImage_overview,None,RasterImage)
RasterImage.interpolate_derivative = new_instancemethod(_geocal.RasterImage_interpolate_derivative,None,RasterImage)
RasterImage.interpolate = new_instancemethod(_geocal.RasterImage_interpolate,None,RasterImage)
RasterImage._number_line = new_instancemethod(_geocal.RasterImage__number_line,None,RasterImage)
RasterImage._number_sample = new_instancemethod(_geocal.RasterImage__number_sample,None,RasterImage)
RasterImage._number_tile_line = new_instancemethod(_geocal.RasterImage__number_tile_line,None,RasterImage)
RasterImage._number_tile_sample = new_instancemethod(_geocal.RasterImage__number_tile_sample,None,RasterImage)
RasterImage.read_double = new_instancemethod(_geocal.RasterImage_read_double,None,RasterImage)
RasterImage.read = new_instancemethod(_geocal.RasterImage_read,None,RasterImage)
RasterImage.write = new_instancemethod(_geocal.RasterImage_write,None,RasterImage)
RasterImage.__str__ = new_instancemethod(_geocal.RasterImage___str__,None,RasterImage)
RasterImage._has_map_info = new_instancemethod(_geocal.RasterImage__has_map_info,None,RasterImage)
RasterImage._map_info = new_instancemethod(_geocal.RasterImage__map_info,None,RasterImage)
RasterImage.ground_coordinate = new_instancemethod(_geocal.RasterImage_ground_coordinate,None,RasterImage)
RasterImage.coordinate = new_instancemethod(_geocal.RasterImage_coordinate,None,RasterImage)
RasterImage._grid_center_line_resolution = new_instancemethod(_geocal.RasterImage__grid_center_line_resolution,None,RasterImage)
RasterImage._grid_center_sample_resolution = new_instancemethod(_geocal.RasterImage__grid_center_sample_resolution,None,RasterImage)
RasterImage._has_rpc = new_instancemethod(_geocal.RasterImage__has_rpc,None,RasterImage)
RasterImage._rpc = new_instancemethod(_geocal.RasterImage__rpc,None,RasterImage)
RasterImage_swigregister = _geocal.RasterImage_swigregister
RasterImage_swigregister(RasterImage)


def copy_no_fill(*args):
  return _geocal.copy_no_fill(*args)
copy_no_fill = _geocal.copy_no_fill
class Vector_RasterImage(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_RasterImage_swiginit(self,_geocal.new_Vector_RasterImage(*args))
    __swig_destroy__ = _geocal.delete_Vector_RasterImage
Vector_RasterImage.iterator = new_instancemethod(_geocal.Vector_RasterImage_iterator,None,Vector_RasterImage)
Vector_RasterImage.__nonzero__ = new_instancemethod(_geocal.Vector_RasterImage___nonzero__,None,Vector_RasterImage)
Vector_RasterImage.__bool__ = new_instancemethod(_geocal.Vector_RasterImage___bool__,None,Vector_RasterImage)
Vector_RasterImage.__len__ = new_instancemethod(_geocal.Vector_RasterImage___len__,None,Vector_RasterImage)
Vector_RasterImage.pop = new_instancemethod(_geocal.Vector_RasterImage_pop,None,Vector_RasterImage)
Vector_RasterImage.__getslice__ = new_instancemethod(_geocal.Vector_RasterImage___getslice__,None,Vector_RasterImage)
Vector_RasterImage.__setslice__ = new_instancemethod(_geocal.Vector_RasterImage___setslice__,None,Vector_RasterImage)
Vector_RasterImage.__delslice__ = new_instancemethod(_geocal.Vector_RasterImage___delslice__,None,Vector_RasterImage)
Vector_RasterImage.__delitem__ = new_instancemethod(_geocal.Vector_RasterImage___delitem__,None,Vector_RasterImage)
Vector_RasterImage.__getitem__ = new_instancemethod(_geocal.Vector_RasterImage___getitem__,None,Vector_RasterImage)
Vector_RasterImage.__setitem__ = new_instancemethod(_geocal.Vector_RasterImage___setitem__,None,Vector_RasterImage)
Vector_RasterImage.append = new_instancemethod(_geocal.Vector_RasterImage_append,None,Vector_RasterImage)
Vector_RasterImage.empty = new_instancemethod(_geocal.Vector_RasterImage_empty,None,Vector_RasterImage)
Vector_RasterImage.size = new_instancemethod(_geocal.Vector_RasterImage_size,None,Vector_RasterImage)
Vector_RasterImage.clear = new_instancemethod(_geocal.Vector_RasterImage_clear,None,Vector_RasterImage)
Vector_RasterImage.swap = new_instancemethod(_geocal.Vector_RasterImage_swap,None,Vector_RasterImage)
Vector_RasterImage.get_allocator = new_instancemethod(_geocal.Vector_RasterImage_get_allocator,None,Vector_RasterImage)
Vector_RasterImage.begin = new_instancemethod(_geocal.Vector_RasterImage_begin,None,Vector_RasterImage)
Vector_RasterImage.end = new_instancemethod(_geocal.Vector_RasterImage_end,None,Vector_RasterImage)
Vector_RasterImage.rbegin = new_instancemethod(_geocal.Vector_RasterImage_rbegin,None,Vector_RasterImage)
Vector_RasterImage.rend = new_instancemethod(_geocal.Vector_RasterImage_rend,None,Vector_RasterImage)
Vector_RasterImage.pop_back = new_instancemethod(_geocal.Vector_RasterImage_pop_back,None,Vector_RasterImage)
Vector_RasterImage.erase = new_instancemethod(_geocal.Vector_RasterImage_erase,None,Vector_RasterImage)
Vector_RasterImage.push_back = new_instancemethod(_geocal.Vector_RasterImage_push_back,None,Vector_RasterImage)
Vector_RasterImage.front = new_instancemethod(_geocal.Vector_RasterImage_front,None,Vector_RasterImage)
Vector_RasterImage.back = new_instancemethod(_geocal.Vector_RasterImage_back,None,Vector_RasterImage)
Vector_RasterImage.assign = new_instancemethod(_geocal.Vector_RasterImage_assign,None,Vector_RasterImage)
Vector_RasterImage.resize = new_instancemethod(_geocal.Vector_RasterImage_resize,None,Vector_RasterImage)
Vector_RasterImage.insert = new_instancemethod(_geocal.Vector_RasterImage_insert,None,Vector_RasterImage)
Vector_RasterImage.reserve = new_instancemethod(_geocal.Vector_RasterImage_reserve,None,Vector_RasterImage)
Vector_RasterImage.capacity = new_instancemethod(_geocal.Vector_RasterImage_capacity,None,Vector_RasterImage)
Vector_RasterImage_swigregister = _geocal.Vector_RasterImage_swigregister
Vector_RasterImage_swigregister(Vector_RasterImage)

class ImageGroundConnectionFailed(Exception):
    """
    Exception thrown if ImageGroundConnection fails to calculate a image
    coordinate.

    C++ includes: image_ground_connection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::ImageGroundConnectionFailed::ImageGroundConnectionFailed(const std::string &W="")
        Default constructor.

        Can give an optional string describing the error. 
        """
        _geocal.ImageGroundConnectionFailed_swiginit(self,_geocal.new_ImageGroundConnectionFailed(*args))
    __swig_destroy__ = _geocal.delete_ImageGroundConnectionFailed
ImageGroundConnectionFailed_swigregister = _geocal.ImageGroundConnectionFailed_swigregister
ImageGroundConnectionFailed_swigregister(ImageGroundConnectionFailed)

class ImageGroundConnection(object):
    """
    Depending on the the data we are using, we may connect a location in
    an image to a ground location in one of several ways.

    For example, we might have a rigorous camera model and orbit data
    allowing us to use an Ipi. Or we might have a RPC (Rational Polynomial
    Coefficients) that connect an image to the ground. Or we might be
    working with data that has already been map projected, so a MapInfo
    gives us a direct connection.

    For many purposes, we don't care exactly how the connection is done,
    we just use the fact that there is a connection.

    This class gives a generic interface that can be used for any kind of
    a connection between the ground and an image.

    C++ includes: image_ground_connection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        if self.__class__ == ImageGroundConnection:
            _self = None
        else:
            _self = self
        _geocal.ImageGroundConnection_swiginit(self,_geocal.new_ImageGroundConnection(_self, *args))
    __swig_destroy__ = _geocal.delete_ImageGroundConnection
    def cf_look_vector(self, *args):
        """
        virtual void GeoCal::ImageGroundConnection::cf_look_vector(const ImageCoordinate &Ic, CartesianFixedLookVector &Lv,
        boost::shared_ptr< CartesianFixed > &P) const =0
        Return look vector for given coordinate, along with a position that
        lies along the direction of the look vector (so position of satellite,
        or a position on the surface. 
        """
        return _geocal.ImageGroundConnection_cf_look_vector(self, *args)

    def __ground_coordinate(self, *args):
        """
        virtual boost::shared_ptr<GroundCoordinate> GeoCal::ImageGroundConnection::ground_coordinate(const ImageCoordinate &Ic) const
        Return ground coordinate that goes with a particular image coordinate.

        """
        return _geocal.ImageGroundConnection___ground_coordinate(self, *args)

    def ground_coordinate_dem(self, *args):
        """
        virtual boost::shared_ptr<GroundCoordinate> GeoCal::ImageGroundConnection::ground_coordinate_dem(const ImageCoordinate &Ic, const Dem &D) const =0
        Return ground coordinate that goes with a particular image coordinate.

        This version supplies a Dem to use. 
        """
        return _geocal.ImageGroundConnection_ground_coordinate_dem(self, *args)

    def image_coordinate(self, *args):
        """
        virtual ImageCoordinate GeoCal::ImageGroundConnection::image_coordinate(const GroundCoordinate &Gc) const =0
        Return image coordinate that goes with a particular GroundCoordinate.

        For some types of ImageGroundConnection, we might not be able to
        calculate image_coordinate for all values (e.g., Ipi might fail). In
        those cases, we will through a ImageGroundConnectionFailed exception.
        This means that nothing is wrong, other than that we can't calculate
        the image_coordinate. Callers can catch this exception if they have
        some way of handling no image coordinate data. 
        """
        return _geocal.ImageGroundConnection_image_coordinate(self, *args)

    def image_coordinate_jac_ecr(self, *args):
        """
        blitz::Array< double, 2 > ImageGroundConnection::image_coordinate_jac_ecr(const Ecr &Gc) const
        Return the Jacobian of the image coordinates with respect to the X, Y,
        and Z components of the Ecr ground location. 
        """
        return _geocal.ImageGroundConnection_image_coordinate_jac_ecr(self, *args)

    def image_coordinate_jac_parm(self, *args):
        """
        virtual blitz::Array<double, 2> GeoCal::ImageGroundConnection::image_coordinate_jac_parm(const GroundCoordinate &Gc) const
        Return the Jacobian of the image coordinates with respect to the
        parameters. 
        """
        return _geocal.ImageGroundConnection_image_coordinate_jac_parm(self, *args)

    def cover(self, *args):
        """
        MapInfo ImageGroundConnection::cover(const MapInfo &Mi, int boundary=0) const
        Find a MapInfo that covers the ground coordinate of this
        ImageGroundConnection.

        We calculate the ground coordinate of the four corners, then find the
        MapInfo that covers those corners, optionally adding a boundary in map
        pixels. Depending on the actual warping involved, this may or may not
        fully cover the edges of the image. 
        """
        return _geocal.ImageGroundConnection_cover(self, *args)

    def _image(self):
        """
        virtual boost::shared_ptr<RasterImage> GeoCal::ImageGroundConnection::image() const
        Underlying image. 
        """
        return _geocal.ImageGroundConnection__image(self)

    @property
    def image(self):
        return self._image()

    def _number_line(self):
        """
        virtual int GeoCal::ImageGroundConnection::number_line() const
        Return number of lines in underlying image. 
        """
        return _geocal.ImageGroundConnection__number_line(self)

    @property
    def number_line(self):
        return self._number_line()

    def _number_sample(self):
        """
        virtual int GeoCal::ImageGroundConnection::number_sample() const
        Return number of samples in underlying image. 
        """
        return _geocal.ImageGroundConnection__number_sample(self)

    @property
    def number_sample(self):
        return self._number_sample()

    def _title(self, *args):
        """
        virtual void GeoCal::ImageGroundConnection::title(const std::string &Title)
        Set image title. 
        """
        return _geocal.ImageGroundConnection__title(self, *args)

    @property
    def title(self):
        return self._title()

    @title.setter
    def title(self, value):
      self._title(value)

    def __str__(self):
        """
        std::string GeoCal::Printable< ImageGroundConnection  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.ImageGroundConnection___str__(self)

    def _parameter(self, *args):
        """
        virtual void GeoCal::ImageGroundConnection::parameter(const blitz::Array< double, 1 > &Parm)
        Set the value of the parameters. 
        """
        return _geocal.ImageGroundConnection__parameter(self, *args)

    @property
    def parameter(self):
        return self._parameter()

    @parameter.setter
    def parameter(self, value):
      self._parameter(value)

    def _parameter_name(self):
        """
        virtual std::vector<std::string> GeoCal::ImageGroundConnection::parameter_name() const
        Descriptive name of each parameter. 
        """
        return _geocal.ImageGroundConnection__parameter_name(self)

    @property
    def parameter_name(self):
        return self._parameter_name()

    def resolution_meter(self, *args):
        """
        double ImageGroundConnection::resolution_meter() const
        Variation of resolution_meter that find the resolution of the center
        pixel. 
        """
        return _geocal.ImageGroundConnection_resolution_meter(self, *args)

    def _dem(self):
        """
        const boost::shared_ptr<Dem>& GeoCal::ImageGroundConnection::dem_ptr() const
        DEM used by ground_coordinate. 
        """
        return _geocal.ImageGroundConnection__dem(self)

    @property
    def dem(self):
        return self._dem()

    def __dem(self, *args):
        """
        const Dem& GeoCal::ImageGroundConnection::dem() const
        Dem used by ground_coordinate. 
        """
        return _geocal.ImageGroundConnection___dem(self, *args)

    @dem.setter
    def dem(self, value):  
      self.__dem(value)

    def ground_coordinate(self, ic, dem = None):
      '''Return ground coordinate for the given image coordinate. You can specify
       a dem to use, or we use the dem associated with the class.'''
      if(dem):
        return self.ground_coordinate_dem(ic, dem)
      else:
        return self.__ground_coordinate(ic)

    def __disown__(self):
        self.this.disown()
        _geocal.disown_ImageGroundConnection(self)
        return weakref_proxy(self)
ImageGroundConnection.cf_look_vector = new_instancemethod(_geocal.ImageGroundConnection_cf_look_vector,None,ImageGroundConnection)
ImageGroundConnection.__ground_coordinate = new_instancemethod(_geocal.ImageGroundConnection___ground_coordinate,None,ImageGroundConnection)
ImageGroundConnection.ground_coordinate_dem = new_instancemethod(_geocal.ImageGroundConnection_ground_coordinate_dem,None,ImageGroundConnection)
ImageGroundConnection.image_coordinate = new_instancemethod(_geocal.ImageGroundConnection_image_coordinate,None,ImageGroundConnection)
ImageGroundConnection.image_coordinate_jac_ecr = new_instancemethod(_geocal.ImageGroundConnection_image_coordinate_jac_ecr,None,ImageGroundConnection)
ImageGroundConnection.image_coordinate_jac_parm = new_instancemethod(_geocal.ImageGroundConnection_image_coordinate_jac_parm,None,ImageGroundConnection)
ImageGroundConnection.cover = new_instancemethod(_geocal.ImageGroundConnection_cover,None,ImageGroundConnection)
ImageGroundConnection._image = new_instancemethod(_geocal.ImageGroundConnection__image,None,ImageGroundConnection)
ImageGroundConnection._number_line = new_instancemethod(_geocal.ImageGroundConnection__number_line,None,ImageGroundConnection)
ImageGroundConnection._number_sample = new_instancemethod(_geocal.ImageGroundConnection__number_sample,None,ImageGroundConnection)
ImageGroundConnection._title = new_instancemethod(_geocal.ImageGroundConnection__title,None,ImageGroundConnection)
ImageGroundConnection.__str__ = new_instancemethod(_geocal.ImageGroundConnection___str__,None,ImageGroundConnection)
ImageGroundConnection._parameter = new_instancemethod(_geocal.ImageGroundConnection__parameter,None,ImageGroundConnection)
ImageGroundConnection._parameter_name = new_instancemethod(_geocal.ImageGroundConnection__parameter_name,None,ImageGroundConnection)
ImageGroundConnection.resolution_meter = new_instancemethod(_geocal.ImageGroundConnection_resolution_meter,None,ImageGroundConnection)
ImageGroundConnection._dem = new_instancemethod(_geocal.ImageGroundConnection__dem,None,ImageGroundConnection)
ImageGroundConnection.__dem = new_instancemethod(_geocal.ImageGroundConnection___dem,None,ImageGroundConnection)
ImageGroundConnection_swigregister = _geocal.ImageGroundConnection_swigregister
ImageGroundConnection_swigregister(ImageGroundConnection)

class OffsetImageGroundConnection(ImageGroundConnection):
    """
    This class creates an ImageGroundConnection that that is an offset of
    a given one.

    This would be used for example when a image is subsetted to create a
    ImageGroundConnection to go with that subsetted image.

    C++ includes: image_ground_connection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::OffsetImageGroundConnection::OffsetImageGroundConnection(const boost::shared_ptr< ImageGroundConnection > &Ig_original, double
        Line_offset, double Sample_offset, int Number_line, int Number_sample)
        Constructor. 
        """
        _geocal.OffsetImageGroundConnection_swiginit(self,_geocal.new_OffsetImageGroundConnection(*args))
    def _original_image_ground_connection(self):
        """
        boost::shared_ptr<ImageGroundConnection> GeoCal::OffsetImageGroundConnection::original_image_ground_connection() const
        Underlying ImageGroundConnection. 
        """
        return _geocal.OffsetImageGroundConnection__original_image_ground_connection(self)

    @property
    def original_image_ground_connection(self):
        return self._original_image_ground_connection()

    def _line_offset(self):
        """
        double GeoCal::OffsetImageGroundConnection::line_offset() const
        Return line offset. 
        """
        return _geocal.OffsetImageGroundConnection__line_offset(self)

    @property
    def line_offset(self):
        return self._line_offset()

    def _sample_offset(self):
        """
        double GeoCal::OffsetImageGroundConnection::sample_offset() const
        Return sample offset. 
        """
        return _geocal.OffsetImageGroundConnection__sample_offset(self)

    @property
    def sample_offset(self):
        return self._sample_offset()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.original_image_ground_connection,self.line_offset,self.sample_offset,self.number_line,self.number_sample)

    __swig_destroy__ = _geocal.delete_OffsetImageGroundConnection
OffsetImageGroundConnection._original_image_ground_connection = new_instancemethod(_geocal.OffsetImageGroundConnection__original_image_ground_connection,None,OffsetImageGroundConnection)
OffsetImageGroundConnection._line_offset = new_instancemethod(_geocal.OffsetImageGroundConnection__line_offset,None,OffsetImageGroundConnection)
OffsetImageGroundConnection._sample_offset = new_instancemethod(_geocal.OffsetImageGroundConnection__sample_offset,None,OffsetImageGroundConnection)
OffsetImageGroundConnection_swigregister = _geocal.OffsetImageGroundConnection_swigregister
OffsetImageGroundConnection_swigregister(OffsetImageGroundConnection)

class FrameCoordinate(object):
    """
    This is the coordinates of a frame camera.

    C++ includes: frame_coordinate.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::FrameCoordinate::FrameCoordinate(double L, double S)
        Create a FrameCoordinate with the given coordinates. 
        """
        _geocal.FrameCoordinate_swiginit(self,_geocal.new_FrameCoordinate(*args))
    line = _swig_property(_geocal.FrameCoordinate_line_get, _geocal.FrameCoordinate_line_set)
    sample = _swig_property(_geocal.FrameCoordinate_sample_get, _geocal.FrameCoordinate_sample_set)
    def __str__(self):
        """
        std::string GeoCal::Printable< FrameCoordinate  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.FrameCoordinate___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.line,self.sample)

    __swig_destroy__ = _geocal.delete_FrameCoordinate
FrameCoordinate.__str__ = new_instancemethod(_geocal.FrameCoordinate___str__,None,FrameCoordinate)
FrameCoordinate_swigregister = _geocal.FrameCoordinate_swigregister
FrameCoordinate_swigregister(FrameCoordinate)

class Camera(object):
    """
    This class models a frame camera.

    It is used to convert ScLookVector to FrameCoordinate and vice versa.

    C++ includes: camera.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    FORWARD = _geocal.Camera_FORWARD
    AFTWARD = _geocal.Camera_AFTWARD
    def integration_time(self, *args):
        """
        virtual double GeoCal::Camera::integration_time(int Band) const
        This is the integration time in seconds.

        The integration time is how long it takes the camera to collect data.
        It is important to model this, so that we can include movement of the
        spacecraft while the camera is in the middle of collecting data. If
        the integration time is very short, or if a particular derived class
        doesn't wish to model this, then the integration time can be set to 0
        seconds.

        The default version returns 0.0. 
        """
        return _geocal.Camera_integration_time(self, *args)

    def _direction(self):
        """
        virtual Direction GeoCal::Camera::direction() const
        This gives the camera direction.

        This is intended for use with steep camera angles (e.g., MISR AF
        camera). For cameras that are near nadir looking, we can just
        arbitrarily pick a direction for it.

        The default version returns FORWARD. 
        """
        return _geocal.Camera__direction(self)

    @property
    def direction(self):
        return self._direction()

    def _number_band(self):
        """
        virtual int GeoCal::Camera::number_band() const =0
        Number of bands in camera. 
        """
        return _geocal.Camera__number_band(self)

    @property
    def number_band(self):
        return self._number_band()

    def number_line(self, *args):
        """
        virtual int GeoCal::Camera::number_line(int Band) const =0
        Number of lines in camera for given band. 
        """
        return _geocal.Camera_number_line(self, *args)

    def number_sample(self, *args):
        """
        virtual int GeoCal::Camera::number_sample(int Band) const =0
        Number of samples in camera for given band. 
        """
        return _geocal.Camera_number_sample(self, *args)

    def frame_coordinate(self, *args):
        """
        virtual FrameCoordinate GeoCal::Camera::frame_coordinate(const ScLookVector &Sl, int Band) const =0
        This converts from ScLookVector to FrameCoordinate for a given band.

        Note that the FrameCoordinate may be outside of the range (0,
        number_line(band) - 1), (0, number_sample(band) - 1), this just means
        the look vector is not with the active portion of the camera (i.e., it
        is not seen). 
        """
        return _geocal.Camera_frame_coordinate(self, *args)

    def frame_line_coordinate(self, *args):
        """
        virtual double GeoCal::Camera::frame_line_coordinate(const ScLookVector &Sl, int Band) const
        This is similar to frame_coordinate, except it only calculates the
        line coordinate.

        For some camera models, it is more expensive to calculate the sample
        number than the line (e.g., MISR camera needs to use the pixel-theta
        measurements). For functions that only need the line information, it
        is wasteful to do the full calculation.

        The default version of this function just calls frame_coordinate and
        returns the line portion, but a derived class can override this
        default with a faster way of calculation the line information. 
        """
        return _geocal.Camera_frame_line_coordinate(self, *args)

    def sc_look_vector(self, *args):
        """
        virtual ScLookVector GeoCal::Camera::sc_look_vector(const FrameCoordinate &F, int Band) const =0
        Convert from FrameCoordinate to ScLookVector.

        It is perfectly allowable for F.line to be outside the range (0,
        number_line(band) 1) or for F.sample to be outside the range (0,
        number_sample(band) - 1). The conversion will just act as if the
        camera has infinite extent. 
        """
        return _geocal.Camera_sc_look_vector(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< Camera  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Camera___str__(self)

    __swig_destroy__ = _geocal.delete_Camera
Camera.integration_time = new_instancemethod(_geocal.Camera_integration_time,None,Camera)
Camera._direction = new_instancemethod(_geocal.Camera__direction,None,Camera)
Camera._number_band = new_instancemethod(_geocal.Camera__number_band,None,Camera)
Camera.number_line = new_instancemethod(_geocal.Camera_number_line,None,Camera)
Camera.number_sample = new_instancemethod(_geocal.Camera_number_sample,None,Camera)
Camera.frame_coordinate = new_instancemethod(_geocal.Camera_frame_coordinate,None,Camera)
Camera.frame_line_coordinate = new_instancemethod(_geocal.Camera_frame_line_coordinate,None,Camera)
Camera.sc_look_vector = new_instancemethod(_geocal.Camera_sc_look_vector,None,Camera)
Camera.__str__ = new_instancemethod(_geocal.Camera___str__,None,Camera)
Camera_swigregister = _geocal.Camera_swigregister
Camera_swigregister(Camera)

class PushBroomCamera(Camera):
    """
    This is a camera specialized to 1 line per band.

    C++ includes: camera.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _geocal.delete_PushBroomCamera
PushBroomCamera_swigregister = _geocal.PushBroomCamera_swigregister
PushBroomCamera_swigregister(PushBroomCamera)

class SimplePushBroomCamera(PushBroomCamera):
    """
    This is a simple PushBroomCamera.

    It is not intended as a realistic camera model, but rather as
    supplying a simple class to use for testing. The defaults are for the
    nominal MISR DF camera, red band.

    C++ includes: camera.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        SimplePushBroomCamera::SimplePushBroomCamera(double Beta=58 *Constant::deg_to_rad, double Delta=-2.7
        *Constant::deg_to_rad, double Epsilon=0, double Focal=123.8e-3, double
        line_pitch=18e-6, double sample_pitch=21e-6, int Number_sample=1504)
        This creates SimplePushBroomCamera with the given data.

        The default data is for the nominal MISR DF, red band. 
        """
        _geocal.SimplePushBroomCamera_swiginit(self,_geocal.new_SimplePushBroomCamera(*args))
    def _beta(self):
        """
        double GeoCal::SimplePushBroomCamera::beta() const

        """
        return _geocal.SimplePushBroomCamera__beta(self)

    @property
    def beta(self):
        return self._beta()

    def _delta(self):
        """
        double GeoCal::SimplePushBroomCamera::delta() const

        """
        return _geocal.SimplePushBroomCamera__delta(self)

    @property
    def delta(self):
        return self._delta()

    def _epsilon(self):
        """
        double GeoCal::SimplePushBroomCamera::epsilon() const

        """
        return _geocal.SimplePushBroomCamera__epsilon(self)

    @property
    def epsilon(self):
        return self._epsilon()

    def _focal_length(self):
        """
        double GeoCal::SimplePushBroomCamera::focal_length() const

        """
        return _geocal.SimplePushBroomCamera__focal_length(self)

    @property
    def focal_length(self):
        return self._focal_length()

    def _line_pitch(self):
        """
        double GeoCal::SimplePushBroomCamera::line_pitch() const

        """
        return _geocal.SimplePushBroomCamera__line_pitch(self)

    @property
    def line_pitch(self):
        return self._line_pitch()

    def _sample_pitch(self):
        """
        double GeoCal::SimplePushBroomCamera::sample_pitch() const

        """
        return _geocal.SimplePushBroomCamera__sample_pitch(self)

    @property
    def sample_pitch(self):
        return self._sample_pitch()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.beta,self.delta,self.epsilon,self.focal_length,self.line_pitch,self.sample_pitch,self.number_sample(0))

    __swig_destroy__ = _geocal.delete_SimplePushBroomCamera
SimplePushBroomCamera._beta = new_instancemethod(_geocal.SimplePushBroomCamera__beta,None,SimplePushBroomCamera)
SimplePushBroomCamera._delta = new_instancemethod(_geocal.SimplePushBroomCamera__delta,None,SimplePushBroomCamera)
SimplePushBroomCamera._epsilon = new_instancemethod(_geocal.SimplePushBroomCamera__epsilon,None,SimplePushBroomCamera)
SimplePushBroomCamera._focal_length = new_instancemethod(_geocal.SimplePushBroomCamera__focal_length,None,SimplePushBroomCamera)
SimplePushBroomCamera._line_pitch = new_instancemethod(_geocal.SimplePushBroomCamera__line_pitch,None,SimplePushBroomCamera)
SimplePushBroomCamera._sample_pitch = new_instancemethod(_geocal.SimplePushBroomCamera__sample_pitch,None,SimplePushBroomCamera)
SimplePushBroomCamera_swigregister = _geocal.SimplePushBroomCamera_swigregister
SimplePushBroomCamera_swigregister(SimplePushBroomCamera)

class Vector_Camera(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_Camera_swiginit(self,_geocal.new_Vector_Camera(*args))
    __swig_destroy__ = _geocal.delete_Vector_Camera
Vector_Camera.iterator = new_instancemethod(_geocal.Vector_Camera_iterator,None,Vector_Camera)
Vector_Camera.__nonzero__ = new_instancemethod(_geocal.Vector_Camera___nonzero__,None,Vector_Camera)
Vector_Camera.__bool__ = new_instancemethod(_geocal.Vector_Camera___bool__,None,Vector_Camera)
Vector_Camera.__len__ = new_instancemethod(_geocal.Vector_Camera___len__,None,Vector_Camera)
Vector_Camera.pop = new_instancemethod(_geocal.Vector_Camera_pop,None,Vector_Camera)
Vector_Camera.__getslice__ = new_instancemethod(_geocal.Vector_Camera___getslice__,None,Vector_Camera)
Vector_Camera.__setslice__ = new_instancemethod(_geocal.Vector_Camera___setslice__,None,Vector_Camera)
Vector_Camera.__delslice__ = new_instancemethod(_geocal.Vector_Camera___delslice__,None,Vector_Camera)
Vector_Camera.__delitem__ = new_instancemethod(_geocal.Vector_Camera___delitem__,None,Vector_Camera)
Vector_Camera.__getitem__ = new_instancemethod(_geocal.Vector_Camera___getitem__,None,Vector_Camera)
Vector_Camera.__setitem__ = new_instancemethod(_geocal.Vector_Camera___setitem__,None,Vector_Camera)
Vector_Camera.append = new_instancemethod(_geocal.Vector_Camera_append,None,Vector_Camera)
Vector_Camera.empty = new_instancemethod(_geocal.Vector_Camera_empty,None,Vector_Camera)
Vector_Camera.size = new_instancemethod(_geocal.Vector_Camera_size,None,Vector_Camera)
Vector_Camera.clear = new_instancemethod(_geocal.Vector_Camera_clear,None,Vector_Camera)
Vector_Camera.swap = new_instancemethod(_geocal.Vector_Camera_swap,None,Vector_Camera)
Vector_Camera.get_allocator = new_instancemethod(_geocal.Vector_Camera_get_allocator,None,Vector_Camera)
Vector_Camera.begin = new_instancemethod(_geocal.Vector_Camera_begin,None,Vector_Camera)
Vector_Camera.end = new_instancemethod(_geocal.Vector_Camera_end,None,Vector_Camera)
Vector_Camera.rbegin = new_instancemethod(_geocal.Vector_Camera_rbegin,None,Vector_Camera)
Vector_Camera.rend = new_instancemethod(_geocal.Vector_Camera_rend,None,Vector_Camera)
Vector_Camera.pop_back = new_instancemethod(_geocal.Vector_Camera_pop_back,None,Vector_Camera)
Vector_Camera.erase = new_instancemethod(_geocal.Vector_Camera_erase,None,Vector_Camera)
Vector_Camera.push_back = new_instancemethod(_geocal.Vector_Camera_push_back,None,Vector_Camera)
Vector_Camera.front = new_instancemethod(_geocal.Vector_Camera_front,None,Vector_Camera)
Vector_Camera.back = new_instancemethod(_geocal.Vector_Camera_back,None,Vector_Camera)
Vector_Camera.assign = new_instancemethod(_geocal.Vector_Camera_assign,None,Vector_Camera)
Vector_Camera.resize = new_instancemethod(_geocal.Vector_Camera_resize,None,Vector_Camera)
Vector_Camera.insert = new_instancemethod(_geocal.Vector_Camera_insert,None,Vector_Camera)
Vector_Camera.reserve = new_instancemethod(_geocal.Vector_Camera_reserve,None,Vector_Camera)
Vector_Camera.capacity = new_instancemethod(_geocal.Vector_Camera_capacity,None,Vector_Camera)
Vector_Camera_swigregister = _geocal.Vector_Camera_swigregister
Vector_Camera_swigregister(Vector_Camera)

class OrbitData(object):
    """
    This class is used to convert ScLookVector,
    CartesianInertialLookVector and CartesianFixedLookVector to and from
    each other at a given time.

    C++ includes: orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def resolution_meter(self, *args):
        """
        double OrbitData::resolution_meter(const Camera &C, const FrameCoordinate &Fc, int Band=0) const
        Calculate the approximate resolution on the ground of a given Camera
        for this OrbitData.

        This finds the intersection with the reference surface for the given
        pixel of the camera, + 1 in the line and sample direction. We find the
        difference in meters between these points, and select the maximum
        value. 
        """
        return _geocal.OrbitData_resolution_meter(self, *args)

    def ci_look_vector(self, *args):
        """
        virtual CartesianInertialLookVector GeoCal::OrbitData::ci_look_vector(const ScLookVector &Sl) const =0
        Convert from ScLookVector to CartesianInertialLookVector. 
        """
        return _geocal.OrbitData_ci_look_vector(self, *args)

    def cf_look_vector(self, *args):
        """
        virtual CartesianFixedLookVector GeoCal::OrbitData::cf_look_vector(const ScLookVector &Sl) const =0
        Convert from ScLookVector to CartesianFixedLookVector. 
        """
        return _geocal.OrbitData_cf_look_vector(self, *args)

    def sc_look_vector(self, *args):
        """
        virtual ScLookVector GeoCal::OrbitData::sc_look_vector(const CartesianFixedLookVector &Cf) const =0
        Convert from CartesianFixedLookVector to ScLookVector. 
        """
        return _geocal.OrbitData_sc_look_vector(self, *args)

    def frame_coordinate(self, *args):
        """
        FrameCoordinate OrbitData::frame_coordinate(const GroundCoordinate &Gc, const Camera &C, int Band=0) const
        Give the frame coordinates that a particular point on the ground is
        seen. 
        """
        return _geocal.OrbitData_frame_coordinate(self, *args)

    def reference_surface_intersect_approximate(self, *args):
        """
        boost::shared_ptr< CartesianFixed > OrbitData::reference_surface_intersect_approximate(const Camera &C, const FrameCoordinate &Fc, int Band=0, double
        Height_reference_surface=0.0) const
        Return location on the reference surface that a particular frame
        coordinate is seen.

        This is approximate, in the same way
        CartesianFixed::reference_intersect_approximate is approximate. 
        """
        return _geocal.OrbitData_reference_surface_intersect_approximate(self, *args)

    def _position_ci(self):
        """
        virtual boost::shared_ptr<CartesianInertial> GeoCal::OrbitData::position_ci() const =0
        Return position as a pointer. 
        """
        return _geocal.OrbitData__position_ci(self)

    @property
    def position_ci(self):
        return self._position_ci()

    def _position_cf(self):
        """
        virtual boost::shared_ptr<CartesianFixed> GeoCal::OrbitData::position_cf() const =0
        Return position as a pointer. 
        """
        return _geocal.OrbitData__position_cf(self)

    @property
    def position_cf(self):
        return self._position_cf()

    def footprint(self, *args):
        """
        std::vector< boost::shared_ptr< GroundCoordinate > > OrbitData::footprint(const Camera &C, const Dem &D, double Resolution=30, int Band=0,
        double Max_height=9000) const
        Return the footprint on the ground for the given camera and dem.

        This just calls surface_intersect for the four corner points. 
        """
        return _geocal.OrbitData_footprint(self, *args)

    def surface_intersect(self, *args):
        """
        boost::shared_ptr< CartesianFixed > OrbitData::surface_intersect(const Camera &C, const FrameCoordinate &Fc, const Dem &D, double
        Resolution=30, int Band=0, double Max_height=9000) const
        Calculate the intersection with the surface.

        Resolution is the dem postings in meters, you usually don't want this
        much more accurate than the intrinsic accuracy of the Dem (e.g., the
        Did is 30 meter, so resolution shouldn't be better than 30). 
        """
        return _geocal.OrbitData_surface_intersect(self, *args)

    def _velocity_ci(self):
        """
        virtual boost::array<double, 3> GeoCal::OrbitData::velocity_ci() const =0
        Return velocity.

        This is in meters per second, in same CartesianInertial coordinate
        system as position (e.g., ECI). 
        """
        return _geocal.OrbitData__velocity_ci(self)

    @property
    def velocity_ci(self):
        return self._velocity_ci()

    def _time(self):
        """
        virtual Time GeoCal::OrbitData::time() const =0
        Return Time of OrbitData. 
        """
        return _geocal.OrbitData__time(self)

    @property
    def time(self):
        return self._time()

    def __str__(self):
        """
        std::string GeoCal::Printable< OrbitData  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.OrbitData___str__(self)

    __swig_destroy__ = _geocal.delete_OrbitData
OrbitData.resolution_meter = new_instancemethod(_geocal.OrbitData_resolution_meter,None,OrbitData)
OrbitData.ci_look_vector = new_instancemethod(_geocal.OrbitData_ci_look_vector,None,OrbitData)
OrbitData.cf_look_vector = new_instancemethod(_geocal.OrbitData_cf_look_vector,None,OrbitData)
OrbitData.sc_look_vector = new_instancemethod(_geocal.OrbitData_sc_look_vector,None,OrbitData)
OrbitData.frame_coordinate = new_instancemethod(_geocal.OrbitData_frame_coordinate,None,OrbitData)
OrbitData.reference_surface_intersect_approximate = new_instancemethod(_geocal.OrbitData_reference_surface_intersect_approximate,None,OrbitData)
OrbitData._position_ci = new_instancemethod(_geocal.OrbitData__position_ci,None,OrbitData)
OrbitData._position_cf = new_instancemethod(_geocal.OrbitData__position_cf,None,OrbitData)
OrbitData.footprint = new_instancemethod(_geocal.OrbitData_footprint,None,OrbitData)
OrbitData.surface_intersect = new_instancemethod(_geocal.OrbitData_surface_intersect,None,OrbitData)
OrbitData._velocity_ci = new_instancemethod(_geocal.OrbitData__velocity_ci,None,OrbitData)
OrbitData._time = new_instancemethod(_geocal.OrbitData__time,None,OrbitData)
OrbitData.__str__ = new_instancemethod(_geocal.OrbitData___str__,None,OrbitData)
OrbitData_swigregister = _geocal.OrbitData_swigregister
OrbitData_swigregister(OrbitData)

class QuaternionOrbitData(OrbitData):
    """
    This class implements the most common way of doing OrbitData
    conversions, which just uses fixed quaternions.

    This accounts for both the orientation of the spacecraft relative to
    the planet, as well as the aberration of light (a small correction due
    to the movement of the spacecraft relative to the planet).

    This does not account for atmospheric refraction. Depending on the
    zenith angle, this can be somewhat important for satellites. From the
    approximate atmospheric model described in "Theoretical Basis of the
    SDP Toolkit Geolocation package for the ECS", Table 6-5 the linear
    displacement for a zenith angle of 10 is 0.549 meters, 20 degrees is
    1.223 meters, and 30 degrees is 2.221.

    We may want to add a atmospheric refraction correction in the future,
    but this hasn't been done yet.

    We need to have one of the toolkit available if we want to convert for
    the CartesianFixed coordinates used by this class to
    CartesianInertial. If you stick to working with CartesianFixed only,
    you can avoid the need of using one of these toolkits.

    C++ includes: orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        QuaternionOrbitData::QuaternionOrbitData(Time Tm, const boost::shared_ptr< CartesianInertial > &pos_ci, const
        boost::array< double, 3 > &vel_inertial, const
        boost::math::quaternion< double > &sc_to_ci_q)
        Construct QuaternionOrbitData.

        This takes data in a CartesianInertial coordinate system (e.g., Eci
        coordinates). 
        """
        _geocal.QuaternionOrbitData_swiginit(self,_geocal.new_QuaternionOrbitData(*args))
    def sc_look_vector(self, *args):
        """
        ScLookVector QuaternionOrbitData::sc_look_vector(const CartesianFixedLookVector &Cf) const
        Convert to ScLookVector. 
        """
        return _geocal.QuaternionOrbitData_sc_look_vector(self, *args)

    def _sc_to_ci(self):
        """
        boost::math::quaternion<double> GeoCal::QuaternionOrbitData::sc_to_ci() const
        Return the quaternion used to go from spacecraft to cartesian
        inertial. 
        """
        return _geocal.QuaternionOrbitData__sc_to_ci(self)

    @property
    def sc_to_ci(self):
        return self._sc_to_ci()

    def _sc_to_cf(self):
        """
        boost::math::quaternion<double> GeoCal::QuaternionOrbitData::sc_to_cf() const
        Return the quaternion used to go from spacecraft to cartesian fixed.

        """
        return _geocal.QuaternionOrbitData__sc_to_cf(self)

    @property
    def sc_to_cf(self):
        return self._sc_to_cf()

    def _from_cf(self):
        """
        bool GeoCal::QuaternionOrbitData::from_cf() const
        Was this created form the cartesian fixed version of the constructor?
        This is intended for use by python when we pickle this object so we
        know which constructor to call.

        It probably isn't of interest to anything else. 
        """
        return _geocal.QuaternionOrbitData__from_cf(self)

    @property
    def from_cf(self):
        return self._from_cf()

    def _velocity_cf(self):
        """
        boost::array< double, 3 > QuaternionOrbitData::velocity_cf() const
        Velocity in CartisianFixed coordinates. 
        """
        return _geocal.QuaternionOrbitData__velocity_cf(self)

    @property
    def velocity_cf(self):
        return self._velocity_cf()

    def __reduce__(self):
      if(self.from_cf):
        return _new_from_init, (self.__class__, self.time, self.position_cf, 
    			    self.velocity_cf, self.sc_to_cf)
      else:
        return _new_from_init, (self.__class__, self.time, self.position_ci, 
    			    self.velocity_ci, self.sc_to_ci)


    __swig_destroy__ = _geocal.delete_QuaternionOrbitData
QuaternionOrbitData.sc_look_vector = new_instancemethod(_geocal.QuaternionOrbitData_sc_look_vector,None,QuaternionOrbitData)
QuaternionOrbitData._sc_to_ci = new_instancemethod(_geocal.QuaternionOrbitData__sc_to_ci,None,QuaternionOrbitData)
QuaternionOrbitData._sc_to_cf = new_instancemethod(_geocal.QuaternionOrbitData__sc_to_cf,None,QuaternionOrbitData)
QuaternionOrbitData._from_cf = new_instancemethod(_geocal.QuaternionOrbitData__from_cf,None,QuaternionOrbitData)
QuaternionOrbitData._velocity_cf = new_instancemethod(_geocal.QuaternionOrbitData__velocity_cf,None,QuaternionOrbitData)
QuaternionOrbitData_swigregister = _geocal.QuaternionOrbitData_swigregister
QuaternionOrbitData_swigregister(QuaternionOrbitData)

class Orbit(object):
    """
    This class is used to model orbit data, allowing conversions from
    spacecraft coordinates to CartesianInertial and CartesianFixed
    coordinates.

    This class is used to return orbit data at a given time. OrbitData is
    a class that is able to convert from spacecraft coordinates to
    CartesianInertial coordinates and vice-versa at a given time, as well
    as giving the platforms position.

    As an optimization, methods for direct conversion from spacecraft
    coordinates to CartesianInertial and vice-versa, which don't use the
    intermediate OrbitData classes, are supplied. The default methods just
    use the OrbitData methods, but derived classes can supply more
    optimized versions of these methods.

    An orbit has a min_time() and a max_time() that orbit data is
    available for. Requesting data outside of this range will cause an
    exception to be thrown. For Time T, we must have min_time() <= T <
    max_time().

    C++ includes: orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::Orbit::Orbit(Time Min_time=Time::min_valid_time, Time
        Max_time=Time::max_valid_time)
        Constructor.

        The Orbit is valid for the given range of minimum to maximum time. 
        """
        if self.__class__ == Orbit:
            _self = None
        else:
            _self = self
        _geocal.Orbit_swiginit(self,_geocal.new_Orbit(_self, *args))
    __swig_destroy__ = _geocal.delete_Orbit
    def ci_look_vector(self, *args):
        """
        virtual CartesianInertialLookVector GeoCal::Orbit::ci_look_vector(Time T, const ScLookVector &Sl) const
        Convert from ScLookVector to CartesianInertialLookVector for the given
        time.

        We should have min_time() <= T < max_time(). 
        """
        return _geocal.Orbit_ci_look_vector(self, *args)

    def cf_look_vector(self, *args):
        """
        virtual CartesianFixedLookVector GeoCal::Orbit::cf_look_vector(Time T, const ScLookVector &Sl) const
        Convert from ScLookVector to CartesianFixedLookVector for the given
        time.

        We should have min_time() <= T < max_time(). 
        """
        return _geocal.Orbit_cf_look_vector(self, *args)

    def frame_coordinate(self, *args):
        """
        FrameCoordinate GeoCal::Orbit::frame_coordinate(Time T, const GroundCoordinate &Gc, const Camera &C, int Band=0)
        const
        Give the frame coordinates that a particular point on the ground is
        seen. 
        """
        return _geocal.Orbit_frame_coordinate(self, *args)

    def reference_surface_intersect_approximate(self, *args):
        """
        boost::shared_ptr<CartesianFixed> GeoCal::Orbit::reference_surface_intersect_approximate(Time T, const Camera &C, const FrameCoordinate &Fc, int Band=0,
        double Height_reference_surface=0.0) const
        Return location on the reference surface that a particular frame
        coordinate is seen.

        This is approximate, in the same way
        CartesianFixed::reference_intersect_approximate is approximate. 
        """
        return _geocal.Orbit_reference_surface_intersect_approximate(self, *args)

    def sc_look_vector(self, *args):
        """
        virtual ScLookVector GeoCal::Orbit::sc_look_vector(Time T, const CartesianFixedLookVector &Cf) const
        Convert from CartesianFixedLookVector to ScLookVector for the given
        time.

        We should have min_time() <= T < max_time(). 
        """
        return _geocal.Orbit_sc_look_vector(self, *args)

    def position_ci(self, *args):
        """
        virtual boost::shared_ptr<CartesianInertial> GeoCal::Orbit::position_ci(Time T) const
        Return position at given time.

        We should have min_time() <= T < max_time(). 
        """
        return _geocal.Orbit_position_ci(self, *args)

    def position_cf(self, *args):
        """
        virtual boost::shared_ptr<CartesianFixed> GeoCal::Orbit::position_cf(Time T) const
        Return position at given time.

        We should have min_time() <= T < max_time(). 
        """
        return _geocal.Orbit_position_cf(self, *args)

    def velocity_ci(self, *args):
        """
        virtual boost::array<double, 3> GeoCal::Orbit::velocity_ci(Time T) const
        Return velocity at given time.

        This is in m/s, in same coordinate system as position. 
        """
        return _geocal.Orbit_velocity_ci(self, *args)

    def _min_time(self):
        """
        Time GeoCal::Orbit::min_time() const
        Minimum time that we can return OrbitData for. 
        """
        return _geocal.Orbit__min_time(self)

    @property
    def min_time(self):
        return self._min_time()

    def _max_time(self):
        """
        Time GeoCal::Orbit::max_time() const
        Maximum time that we can return OrbitData for. 
        """
        return _geocal.Orbit__max_time(self)

    @property
    def max_time(self):
        return self._max_time()

    def orbit_data(self, *args):
        """
        virtual boost::shared_ptr<OrbitData> GeoCal::Orbit::orbit_data(Time T) const =0
        Return OrbitData for the given time.

        We should have min_time() <= T < max_time(). 
        """
        return _geocal.Orbit_orbit_data(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< Orbit  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Orbit___str__(self)

    def interpolate(self, *args):
        """
        boost::math::quaternion<double> interpolate(const boost::math::quaternion< double > &Q1, const
        boost::math::quaternion< double > &Q2, double toffset, double tspace)
        This is a utility function for use by derived classes.

        A common way of getting orbit data is to have discrete measurements of
        the quaternion describing the rotation of the spacecraft. For a time t
        between t1 and t2, we have Q1 as the quaternion at time t1, Q2 the
        quaternion at time t2, tspace = t2 - t1, toffset = t - t1. This
        function then returns Qres. We calculate this by determining the axis
        and angle rotation that takes use from Q1 to Q2, and then do a linear
        interpolation of that angle for the given time. 
        """
        return _geocal.Orbit_interpolate(self, *args)

    def __disown__(self):
        self.this.disown()
        _geocal.disown_Orbit(self)
        return weakref_proxy(self)
Orbit.ci_look_vector = new_instancemethod(_geocal.Orbit_ci_look_vector,None,Orbit)
Orbit.cf_look_vector = new_instancemethod(_geocal.Orbit_cf_look_vector,None,Orbit)
Orbit.frame_coordinate = new_instancemethod(_geocal.Orbit_frame_coordinate,None,Orbit)
Orbit.reference_surface_intersect_approximate = new_instancemethod(_geocal.Orbit_reference_surface_intersect_approximate,None,Orbit)
Orbit.sc_look_vector = new_instancemethod(_geocal.Orbit_sc_look_vector,None,Orbit)
Orbit.position_ci = new_instancemethod(_geocal.Orbit_position_ci,None,Orbit)
Orbit.position_cf = new_instancemethod(_geocal.Orbit_position_cf,None,Orbit)
Orbit.velocity_ci = new_instancemethod(_geocal.Orbit_velocity_ci,None,Orbit)
Orbit._min_time = new_instancemethod(_geocal.Orbit__min_time,None,Orbit)
Orbit._max_time = new_instancemethod(_geocal.Orbit__max_time,None,Orbit)
Orbit.orbit_data = new_instancemethod(_geocal.Orbit_orbit_data,None,Orbit)
Orbit.__str__ = new_instancemethod(_geocal.Orbit___str__,None,Orbit)
Orbit.interpolate = new_instancemethod(_geocal.Orbit_interpolate,None,Orbit)
Orbit_swigregister = _geocal.Orbit_swigregister
Orbit_swigregister(Orbit)

class KeplerOrbit(Orbit):
    """
    This is a simple implementation of an Orbit.

    It just uses Kepler's equations. This is intended primarily for easy
    testing of other classes that need an Orbit, rather than being a
    realistic orbit simulation for real use.

    The default parameters are for a nominal MISR orbit.

    C++ includes: orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        KeplerOrbit::KeplerOrbit(Time Min_time=Time::min_valid_time, Time
        Max_time=Time::max_valid_time, Time
        Epoch=Time::time_pgs(173357492.32), double Semimajor_axis=7086930,
        double Eccentricity=0.001281620, double Inclination=98.199990, double
        Ra_ascending_node=255.355971130, double Ap_at_epoch=69.086962170,
        double Mean_anomaly_at_epoch=290.912925280)
        Create a Kepler orbit with the given elements, valid over the given
        time range.

        Distances are in meters and angles are in degrees. The Epoch gives the
        Time that the rest of the data is valid for. The default values are a
        nominal orbit for MISR. 
        """
        _geocal.KeplerOrbit_swiginit(self,_geocal.new_KeplerOrbit(*args))
    def _epoch(self):
        """
        const Time& GeoCal::KeplerOrbit::epoch() const
        Epoch that rest of data is for. 
        """
        return _geocal.KeplerOrbit__epoch(self)

    @property
    def epoch(self):
        return self._epoch()

    def _semimajor_axis(self):
        """
        double GeoCal::KeplerOrbit::semimajor_axis() const
        Semimajor axis in meters. 
        """
        return _geocal.KeplerOrbit__semimajor_axis(self)

    @property
    def semimajor_axis(self):
        return self._semimajor_axis()

    def _argument_of_perigee(self):
        """
        double GeoCal::KeplerOrbit::argument_of_perigee() const
        Argument of perigee at epoch, in degrees. 
        """
        return _geocal.KeplerOrbit__argument_of_perigee(self)

    @property
    def argument_of_perigee(self):
        return self._argument_of_perigee()

    def _eccentricity(self):
        """
        double GeoCal::KeplerOrbit::eccentricity() const
        Eccentricity of orbit. 
        """
        return _geocal.KeplerOrbit__eccentricity(self)

    @property
    def eccentricity(self):
        return self._eccentricity()

    def _mean_anomoly(self):
        """
        double GeoCal::KeplerOrbit::mean_anomoly() const
        Mean anomoly at epoch, in degrees. 
        """
        return _geocal.KeplerOrbit__mean_anomoly(self)

    @property
    def mean_anomoly(self):
        return self._mean_anomoly()

    def _inclination(self):
        """
        double GeoCal::KeplerOrbit::inclination() const
        Inclination of orbit, in degrees. 
        """
        return _geocal.KeplerOrbit__inclination(self)

    @property
    def inclination(self):
        return self._inclination()

    def _right_ascension(self):
        """
        double GeoCal::KeplerOrbit::right_ascension() const
        Right ascension of ascending node, in degrees. 
        """
        return _geocal.KeplerOrbit__right_ascension(self)

    @property
    def right_ascension(self):
        return self._right_ascension()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.min_time,self.max_time,self.epoch,self.semimajor_axis,self.eccentricity,self.inclination,self.right_ascension,self.argument_of_perigee,self.mean_anomoly)

    __swig_destroy__ = _geocal.delete_KeplerOrbit
KeplerOrbit._epoch = new_instancemethod(_geocal.KeplerOrbit__epoch,None,KeplerOrbit)
KeplerOrbit._semimajor_axis = new_instancemethod(_geocal.KeplerOrbit__semimajor_axis,None,KeplerOrbit)
KeplerOrbit._argument_of_perigee = new_instancemethod(_geocal.KeplerOrbit__argument_of_perigee,None,KeplerOrbit)
KeplerOrbit._eccentricity = new_instancemethod(_geocal.KeplerOrbit__eccentricity,None,KeplerOrbit)
KeplerOrbit._mean_anomoly = new_instancemethod(_geocal.KeplerOrbit__mean_anomoly,None,KeplerOrbit)
KeplerOrbit._inclination = new_instancemethod(_geocal.KeplerOrbit__inclination,None,KeplerOrbit)
KeplerOrbit._right_ascension = new_instancemethod(_geocal.KeplerOrbit__right_ascension,None,KeplerOrbit)
KeplerOrbit_swigregister = _geocal.KeplerOrbit_swigregister
KeplerOrbit_swigregister(KeplerOrbit)

class Vector_QuaternionOrbitData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_QuaternionOrbitData_swiginit(self,_geocal.new_Vector_QuaternionOrbitData(*args))
    __swig_destroy__ = _geocal.delete_Vector_QuaternionOrbitData
Vector_QuaternionOrbitData.iterator = new_instancemethod(_geocal.Vector_QuaternionOrbitData_iterator,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.__nonzero__ = new_instancemethod(_geocal.Vector_QuaternionOrbitData___nonzero__,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.__bool__ = new_instancemethod(_geocal.Vector_QuaternionOrbitData___bool__,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.__len__ = new_instancemethod(_geocal.Vector_QuaternionOrbitData___len__,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.pop = new_instancemethod(_geocal.Vector_QuaternionOrbitData_pop,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.__getslice__ = new_instancemethod(_geocal.Vector_QuaternionOrbitData___getslice__,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.__setslice__ = new_instancemethod(_geocal.Vector_QuaternionOrbitData___setslice__,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.__delslice__ = new_instancemethod(_geocal.Vector_QuaternionOrbitData___delslice__,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.__delitem__ = new_instancemethod(_geocal.Vector_QuaternionOrbitData___delitem__,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.__getitem__ = new_instancemethod(_geocal.Vector_QuaternionOrbitData___getitem__,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.__setitem__ = new_instancemethod(_geocal.Vector_QuaternionOrbitData___setitem__,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.append = new_instancemethod(_geocal.Vector_QuaternionOrbitData_append,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.empty = new_instancemethod(_geocal.Vector_QuaternionOrbitData_empty,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.size = new_instancemethod(_geocal.Vector_QuaternionOrbitData_size,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.clear = new_instancemethod(_geocal.Vector_QuaternionOrbitData_clear,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.swap = new_instancemethod(_geocal.Vector_QuaternionOrbitData_swap,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.get_allocator = new_instancemethod(_geocal.Vector_QuaternionOrbitData_get_allocator,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.begin = new_instancemethod(_geocal.Vector_QuaternionOrbitData_begin,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.end = new_instancemethod(_geocal.Vector_QuaternionOrbitData_end,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.rbegin = new_instancemethod(_geocal.Vector_QuaternionOrbitData_rbegin,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.rend = new_instancemethod(_geocal.Vector_QuaternionOrbitData_rend,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.pop_back = new_instancemethod(_geocal.Vector_QuaternionOrbitData_pop_back,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.erase = new_instancemethod(_geocal.Vector_QuaternionOrbitData_erase,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.push_back = new_instancemethod(_geocal.Vector_QuaternionOrbitData_push_back,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.front = new_instancemethod(_geocal.Vector_QuaternionOrbitData_front,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.back = new_instancemethod(_geocal.Vector_QuaternionOrbitData_back,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.assign = new_instancemethod(_geocal.Vector_QuaternionOrbitData_assign,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.resize = new_instancemethod(_geocal.Vector_QuaternionOrbitData_resize,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.insert = new_instancemethod(_geocal.Vector_QuaternionOrbitData_insert,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.reserve = new_instancemethod(_geocal.Vector_QuaternionOrbitData_reserve,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData.capacity = new_instancemethod(_geocal.Vector_QuaternionOrbitData_capacity,None,Vector_QuaternionOrbitData)
Vector_QuaternionOrbitData_swigregister = _geocal.Vector_QuaternionOrbitData_swigregister
Vector_QuaternionOrbitData_swigregister(Vector_QuaternionOrbitData)

class TimeTable(object):
    """
    This class is used to relate time to image line number and vice versa.

    Often the relationship is pretty simply, there is just a fixed time
    interval between one line and the next. However this class can be used
    to model any instrument complications that need to be modelled (e.g.,
    missing lines, drift in spacing).

    C++ includes: time_table.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def image_coordinate(self, *args):
        """
        virtual ImageCoordinate GeoCal::TimeTable::image_coordinate(Time T, const FrameCoordinate &F) const =0
        Convert from Time and FrameCoordinate to ImageCoordinate. 
        """
        return _geocal.TimeTable_image_coordinate(self, *args)

    def time(self, *args):
        """
        virtual void GeoCal::TimeTable::time(const ImageCoordinate &Ic, Time &T, FrameCoordinate &F) const =0
        Convert from ImageCoordinate to Time and FrameCoordinate. 
        """
        return _geocal.TimeTable_time(self, *args)

    def _min_line(self):
        """
        virtual int GeoCal::TimeTable::min_line() const =0
        Minimum line table is valid for. 
        """
        return _geocal.TimeTable__min_line(self)

    @property
    def min_line(self):
        return self._min_line()

    def _max_line(self):
        """
        virtual int GeoCal::TimeTable::max_line() const =0
        Maximum line table is valid for. 
        """
        return _geocal.TimeTable__max_line(self)

    @property
    def max_line(self):
        return self._max_line()

    def _min_time(self):
        """
        virtual Time GeoCal::TimeTable::min_time() const =0
        Minimum time table is valid for. 
        """
        return _geocal.TimeTable__min_time(self)

    @property
    def min_time(self):
        return self._min_time()

    def _max_time(self):
        """
        virtual Time GeoCal::TimeTable::max_time() const =0
        Maximum time table is valid for. 
        """
        return _geocal.TimeTable__max_time(self)

    @property
    def max_time(self):
        return self._max_time()

    def __str__(self):
        """
        std::string GeoCal::Printable< TimeTable  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.TimeTable___str__(self)

    __swig_destroy__ = _geocal.delete_TimeTable
TimeTable.image_coordinate = new_instancemethod(_geocal.TimeTable_image_coordinate,None,TimeTable)
TimeTable.time = new_instancemethod(_geocal.TimeTable_time,None,TimeTable)
TimeTable._min_line = new_instancemethod(_geocal.TimeTable__min_line,None,TimeTable)
TimeTable._max_line = new_instancemethod(_geocal.TimeTable__max_line,None,TimeTable)
TimeTable._min_time = new_instancemethod(_geocal.TimeTable__min_time,None,TimeTable)
TimeTable._max_time = new_instancemethod(_geocal.TimeTable__max_time,None,TimeTable)
TimeTable.__str__ = new_instancemethod(_geocal.TimeTable___str__,None,TimeTable)
TimeTable_swigregister = _geocal.TimeTable_swigregister
TimeTable_swigregister(TimeTable)

class ConstantSpacingTimeTable(TimeTable):
    """
    This is a time table that has a constant spacing between lines.

    C++ includes: time_table.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        ConstantSpacingTimeTable::ConstantSpacingTimeTable(Time Min_time, Time Max_time, double Time_space=40.8e-3)
        Constructor, creates time table from Min_time to Max_time with given
        Time spacing.

        We adjust Max_time to exactly Min_time + i * Time_space, rounding to
        nearest integer i, so it ok if Max_time is a little sloppy. 
        """
        _geocal.ConstantSpacingTimeTable_swiginit(self,_geocal.new_ConstantSpacingTimeTable(*args))
    def _time_space(self):
        """
        double GeoCal::ConstantSpacingTimeTable::time_space() const

        """
        return _geocal.ConstantSpacingTimeTable__time_space(self)

    @property
    def time_space(self):
        return self._time_space()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.min_time,self.max_time,self.time_space)

    __swig_destroy__ = _geocal.delete_ConstantSpacingTimeTable
ConstantSpacingTimeTable._time_space = new_instancemethod(_geocal.ConstantSpacingTimeTable__time_space,None,ConstantSpacingTimeTable)
ConstantSpacingTimeTable_swigregister = _geocal.ConstantSpacingTimeTable_swigregister
ConstantSpacingTimeTable_swigregister(ConstantSpacingTimeTable)

class Ipi(object):
    """
    This performs an image point intersection (IPI), finding the time or
    image coordinates that a given ground point is seen by a camera.

    This solves the collinearity equation in order to find the time and
    frame coordinates that a ground point is seen. Note however that the
    collinearity equation can give "false" solutions, because it is
    perfectly happy to find points seen by looking straight through the
    earth (since it does not account for an obstructed view).

    We also get "false" solutions if the camera model diverges (i.e, we
    pass in a look vector parallel to the camera CCD plane, so the point
    is not seen by the camera). This is because the root finder doesn't
    actually look for a zero, but rather a change in the sign of the
    equation. When the camera model diverges, we go from negative infinity
    to positive infinity. We recognize these "false" solutions by
    comparing the collinearity equation results to a user supplied
    tolerance.

    We find all the solutions to the collinearity equation, in the range
    Tmin to Tmax. The solutions found must be seperated by a time larger
    then Root_min_separation.

    We then inspect the list of roots, and reject those that are "false"
    solutions. If 1 solution is left, we return it with the success flag
    set to true. Otherwise, we return with the success flag set to false.

    It is very common to call the IPI with a ground point near the last
    call. As a performance improvement, we remember the time results from
    the previous IPI calculation. We first look in a local time range
    around the previous time result. If no solution is found, we then look
    over the entire time range.

    C++ includes: ipi.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        Ipi::Ipi(const boost::shared_ptr< Orbit > &Orb, const boost::shared_ptr<
        PushBroomCamera > &Cam, int Band, Time Tmin, Time Tmax, const
        boost::shared_ptr< TimeTable > &Tt=boost::shared_ptr< TimeTable >(),
        double Local_time_window_size=5.0, double Root_min_separation=30.0,
        double Time_tolerance=40.8e-3 *1.0/16)
        Constructor.

        If you only want to get the Time from the Ipi and not ImageCoordinate,
        it is ok for Tt to be null.

        We find solutions to the Collinearity equations over the full time
        range Tmin to Tmax. However, as a performance enhancement we first
        look around the given Local_time_window_size in seconds around the
        solution from the last call to time() or image_coordinate(). We look
        for all solutions that are Root_min_separation apart. We find time
        with a accuracy given by Time_tolerance. 
        """
        _geocal.Ipi_swiginit(self,_geocal.new_Ipi(*args))
    def image_coordinate(self, *args):
        """
        void Ipi::image_coordinate(const GroundCoordinate &Gp, ImageCoordinate &Ic, bool &Success) const
        Look for the image location that a point is seen.

        Note that unlike time, if a point is seen only outside of the sample
        range of the image then we consider the Ipi a failure. If Success is
        true, then Ic will have a line and sample number inside of the image
        given by the Camera and TimeTable. 
        """
        return _geocal.Ipi_image_coordinate(self, *args)

    def image_coordinate_extended(self, *args):
        """
        void Ipi::image_coordinate_extended(const GroundCoordinate &Gp, ImageCoordinate &Ic, bool &Success) const
        This is like image_coordinate, by we try to handle points out of the
        time and sample range of the data (so this returns line and samples
        outside of the range of the TimeTable and Camera).

        In some cases this is more useful than having image_coordinate fail.
        Note that we still might have Success false, if for example the point
        is outside the range of the Orbit.

        For points outside of the TimeTable range, we just extrapolate the
        last two lines in the time table. 
        """
        return _geocal.Ipi_image_coordinate_extended(self, *args)

    def time(self, *args):
        """
        void Ipi::time(const GroundCoordinate &Gp, Time &Tres, FrameCoordinate &Fres, bool
        &Success) const
        Look for solution for when the GroundCoordinate Gp is seen.

        If we don't find a solution, then Success will be false.

        Note that we may return a solution where Fres has a sample number < 0
        or > cam.number_sample(). This means that a point is not actually seen
        in the image, but would be if we had an infinite extent camera. Often
        this is useful information, however depending on the application you
        may want to reject points with Fres outside of the image range.

        If it is more useful to you, image_coordinate has the opposite
        behavior, it rejects any points that are outside of the actual image.

        """
        return _geocal.Ipi_time(self, *args)

    def footprint(self, *args):
        """
        std::vector< boost::shared_ptr< GroundCoordinate > > Ipi::footprint(const Dem &D) const
        Return the footprint of the data on the ground.

        This is just the footprint of the orbit data at the start and end of
        the time range. 
        """
        return _geocal.Ipi_footprint(self, *args)

    def _resolution_meter(self):
        """
        double Ipi::resolution_meter() const
        Give the approximate ground resolution in meters.

        This is for the center pixel in the area covered by the Ipi. 
        """
        return _geocal.Ipi__resolution_meter(self)

    @property
    def resolution_meter(self):
        return self._resolution_meter()

    def __str__(self):
        """
        std::string GeoCal::Printable< Ipi  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Ipi___str__(self)

    def _orbit(self):
        """
        boost::shared_ptr<Orbit> GeoCal::Ipi::orbit_ptr() const

        """
        return _geocal.Ipi__orbit(self)

    @property
    def orbit(self):
        return self._orbit()

    def _camera(self):
        """
        boost::shared_ptr<PushBroomCamera> GeoCal::Ipi::camera_ptr() const

        """
        return _geocal.Ipi__camera(self)

    @property
    def camera(self):
        return self._camera()

    def _time_table(self):
        """
        boost::shared_ptr<TimeTable> GeoCal::Ipi::time_table_ptr() const

        """
        return _geocal.Ipi__time_table(self)

    @property
    def time_table(self):
        return self._time_table()

    def _band(self):
        """
        int GeoCal::Ipi::band() const
        Band that we are using. 
        """
        return _geocal.Ipi__band(self)

    @property
    def band(self):
        return self._band()

    def _min_time(self):
        """
        Time GeoCal::Ipi::min_time() const
        Minimum time that we are using. 
        """
        return _geocal.Ipi__min_time(self)

    @property
    def min_time(self):
        return self._min_time()

    def _max_time(self):
        """
        Time GeoCal::Ipi::max_time() const
        Maximum time that we are using. 
        """
        return _geocal.Ipi__max_time(self)

    @property
    def max_time(self):
        return self._max_time()

    def _local_time_window_size(self):
        """
        double GeoCal::Ipi::local_time_window_size() const
        How large of a window to search around last solution, in seconds. 
        """
        return _geocal.Ipi__local_time_window_size(self)

    @property
    def local_time_window_size(self):
        return self._local_time_window_size()

    def _root_min_separation(self):
        """
        double GeoCal::Ipi::root_min_separation() const
        How far apart in seconds we look for solutions to the collinearity
        equation. 
        """
        return _geocal.Ipi__root_min_separation(self)

    @property
    def root_min_separation(self):
        return self._root_min_separation()

    def _time_tolerance(self):
        """
        double GeoCal::Ipi::time_tolerance() const
        How accurate we find the time. 
        """
        return _geocal.Ipi__time_tolerance(self)

    @property
    def time_tolerance(self):
        return self._time_tolerance()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.orbit,self.camera,self.band,self.min_time,self.max_time,self.time_table,self.local_time_window_size,self.root_min_separation,self.time_tolerance)

    __swig_destroy__ = _geocal.delete_Ipi
Ipi.image_coordinate = new_instancemethod(_geocal.Ipi_image_coordinate,None,Ipi)
Ipi.image_coordinate_extended = new_instancemethod(_geocal.Ipi_image_coordinate_extended,None,Ipi)
Ipi.time = new_instancemethod(_geocal.Ipi_time,None,Ipi)
Ipi.footprint = new_instancemethod(_geocal.Ipi_footprint,None,Ipi)
Ipi._resolution_meter = new_instancemethod(_geocal.Ipi__resolution_meter,None,Ipi)
Ipi.__str__ = new_instancemethod(_geocal.Ipi___str__,None,Ipi)
Ipi._orbit = new_instancemethod(_geocal.Ipi__orbit,None,Ipi)
Ipi._camera = new_instancemethod(_geocal.Ipi__camera,None,Ipi)
Ipi._time_table = new_instancemethod(_geocal.Ipi__time_table,None,Ipi)
Ipi._band = new_instancemethod(_geocal.Ipi__band,None,Ipi)
Ipi._min_time = new_instancemethod(_geocal.Ipi__min_time,None,Ipi)
Ipi._max_time = new_instancemethod(_geocal.Ipi__max_time,None,Ipi)
Ipi._local_time_window_size = new_instancemethod(_geocal.Ipi__local_time_window_size,None,Ipi)
Ipi._root_min_separation = new_instancemethod(_geocal.Ipi__root_min_separation,None,Ipi)
Ipi._time_tolerance = new_instancemethod(_geocal.Ipi__time_tolerance,None,Ipi)
Ipi_swigregister = _geocal.Ipi_swigregister
Ipi_swigregister(Ipi)

class RasterImageVariable(RasterImage):
    """
    Much of the time the constructor for a RasterImage determine the size,
    map_info, and tile size.

    This helper class holds these values in protected member function
    variables and fills in the corresponding functions.

    C++ includes: raster_image_variable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _geocal.delete_RasterImageVariable
RasterImageVariable_swigregister = _geocal.RasterImageVariable_swigregister
RasterImageVariable_swigregister(RasterImageVariable)

class SubRasterImage(RasterImageVariable):
    """
    This allows you to take a subset of a larger RasterImage and treat it
    like a RasterImage in its own right.

    C++ includes: sub_raster_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        SubRasterImage::SubRasterImage(const boost::shared_ptr< RasterImage > &Raster_image, const
        std::vector< boost::shared_ptr< GroundCoordinate > > &Pt, int
        boundary=0)
        Create a subset of Raster_image that covers the given set of points,
        plus a optional boundary.

        Note that the area given by Pt may be large than the area covered by
        Raster_image. In that case, we only give the portion that falls within
        this image. 
        """
        _geocal.SubRasterImage_swiginit(self,_geocal.new_SubRasterImage(*args))
    def _start_line(self):
        """
        int GeoCal::SubRasterImage::start_line() const
        Start line of underlying data. 
        """
        return _geocal.SubRasterImage__start_line(self)

    @property
    def start_line(self):
        return self._start_line()

    def _start_sample(self):
        """
        int GeoCal::SubRasterImage::start_sample() const
        Start sample of underlying data. 
        """
        return _geocal.SubRasterImage__start_sample(self)

    @property
    def start_sample(self):
        return self._start_sample()

    def _full_raster_image(self):
        """
        const boost::shared_ptr<RasterImage>& GeoCal::SubRasterImage::full_raster_image_ptr() const
        Underlying full raster image. 
        """
        return _geocal.SubRasterImage__full_raster_image(self)

    @property
    def full_raster_image(self):
        return self._full_raster_image()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.full_raster_image,self.start_line,self.start_sample,self.number_line,self.number_sample)

    __swig_destroy__ = _geocal.delete_SubRasterImage
SubRasterImage._start_line = new_instancemethod(_geocal.SubRasterImage__start_line,None,SubRasterImage)
SubRasterImage._start_sample = new_instancemethod(_geocal.SubRasterImage__start_sample,None,SubRasterImage)
SubRasterImage._full_raster_image = new_instancemethod(_geocal.SubRasterImage__full_raster_image,None,SubRasterImage)
SubRasterImage_swigregister = _geocal.SubRasterImage_swigregister
SubRasterImage_swigregister(SubRasterImage)

class RasterImageMultiBand(object):
    """
    This is a set of RasterImages, one for each band.

    C++ includes: raster_image_multi_band.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def _number_band(self):
        """
        virtual int GeoCal::RasterImageMultiBand::number_band() const =0
        Return number of bands. 
        """
        return _geocal.RasterImageMultiBand__number_band(self)

    @property
    def number_band(self):
        return self._number_band()

    def raster_image(self, *args):
        """
        virtual boost::shared_ptr<RasterImage> GeoCal::RasterImageMultiBand::raster_image_ptr(int band) const =0

        """
        return _geocal.RasterImageMultiBand_raster_image(self, *args)

    def read(self, *args):
        """
        Array< int, 3 > RasterImageMultiBand::read(int Lstart, int Sstart, int Nline, int Nsamp) const
        Read the data from the same location in each image, and put into an
        array.

        This will be number_band x number_line x number_sample. 
        """
        return _geocal.RasterImageMultiBand_read(self, *args)

    def read_double(self, *args):
        """
        Array< double, 3 > RasterImageMultiBand::read_double(int Lstart, int Sstart, int Nline, int Nsamp) const
        Read the data from the same location in each image, and put into an
        array.

        This will be number_band x number_line x number_sample. 
        """
        return _geocal.RasterImageMultiBand_read_double(self, *args)

    def write(self, *args):
        """
        void RasterImageMultiBand::write(int Lstart, int Sstart, const blitz::Array< int, 3 > &Data)
        Write the data to the same location in each image.

        Data should be number_band() x nline x nsamp. 
        """
        return _geocal.RasterImageMultiBand_write(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< RasterImageMultiBand  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.RasterImageMultiBand___str__(self)

    def subset(self, *args):
        """
        RasterImageMultiBandVariable RasterImageMultiBand::subset(int line_offset, int sample_offset, int nline, int nsamp) const
        Create a RasterImageMultiBandVariable by taking the same
        SubRasterImage of each band. 
        """
        return _geocal.RasterImageMultiBand_subset(self, *args)

    def overview(self, *args):
        """
        RasterImageMultiBandVariable RasterImageMultiBand::overview(int Min_number_sample) const
        Create a RasterImageMultiBandVariable by finding the overview (if any)
        for each of the raster bands.

        The bands will all be the same size, so if the overviews don't match
        in size we don't use them. If we can't find overviews, then the
        RasterImageMultiBandVariable will just point to the same data as this
        object does. 
        """
        return _geocal.RasterImageMultiBand_overview(self, *args)

    __swig_destroy__ = _geocal.delete_RasterImageMultiBand
RasterImageMultiBand._number_band = new_instancemethod(_geocal.RasterImageMultiBand__number_band,None,RasterImageMultiBand)
RasterImageMultiBand.raster_image = new_instancemethod(_geocal.RasterImageMultiBand_raster_image,None,RasterImageMultiBand)
RasterImageMultiBand.read = new_instancemethod(_geocal.RasterImageMultiBand_read,None,RasterImageMultiBand)
RasterImageMultiBand.read_double = new_instancemethod(_geocal.RasterImageMultiBand_read_double,None,RasterImageMultiBand)
RasterImageMultiBand.write = new_instancemethod(_geocal.RasterImageMultiBand_write,None,RasterImageMultiBand)
RasterImageMultiBand.__str__ = new_instancemethod(_geocal.RasterImageMultiBand___str__,None,RasterImageMultiBand)
RasterImageMultiBand.subset = new_instancemethod(_geocal.RasterImageMultiBand_subset,None,RasterImageMultiBand)
RasterImageMultiBand.overview = new_instancemethod(_geocal.RasterImageMultiBand_overview,None,RasterImageMultiBand)
RasterImageMultiBand_swigregister = _geocal.RasterImageMultiBand_swigregister
RasterImageMultiBand_swigregister(RasterImageMultiBand)


def copy(*args):
  return _geocal.copy(*args)
copy = _geocal.copy
class RasterImageMultiBandVariable(RasterImageMultiBand):
    """
    A common implementation of RasterImageMultiBand is to just store a
    vector of RasterImage.

    This class gives the common behavior.

    C++ includes: raster_image_multi_band_variable.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::RasterImageMultiBandVariable::RasterImageMultiBandVariable(const std::vector< boost::shared_ptr< RasterImage > > &Raster_image)

        """
        _geocal.RasterImageMultiBandVariable_swiginit(self,_geocal.new_RasterImageMultiBandVariable(*args))
    def add_raster_image(self, *args):
        """
        void GeoCal::RasterImageMultiBandVariable::add_raster_image(const boost::shared_ptr< RasterImage > &Ri)

        """
        return _geocal.RasterImageMultiBandVariable_add_raster_image(self, *args)

    __swig_destroy__ = _geocal.delete_RasterImageMultiBandVariable
RasterImageMultiBandVariable.add_raster_image = new_instancemethod(_geocal.RasterImageMultiBandVariable_add_raster_image,None,RasterImageMultiBandVariable)
RasterImageMultiBandVariable_swigregister = _geocal.RasterImageMultiBandVariable_swigregister
RasterImageMultiBandVariable_swigregister(RasterImageMultiBandVariable)

class Mask(object):
    """
    This provides a Mask, which can be used to prevent doing some kind of
    processing.

    An example is a using a Land/Water mask to restrict image matching to
    land, or a cloud mask to restrict image matching to cloud free areas.

    The mask can look at specific GroundCoordinate points indicating if
    the that point is masked or not. You can also look at a region to see
    if the entire area is masked (e.g., avoid processing on this area
    because it is masked).

    The region search is a bit loose, you give the corners of the area to
    search. The region selected depends on the underlying map projection
    used by the mask data - it might be a region in latitude/longitude, a
    region in UTM, or something else. The region search is useful only for
    small areas where these difference aren't very important. If you need
    detailed, accurate information about a region in a specific map
    projection then you should simply look at each individual point. The
    region is useful for the "don't bother looking here for tie points,
    look somewhere else" sorts of uses.

    If the region search returns true, then all of the region is masked.
    If this is false, then some of the region might be unmasked. Note that
    this is conservative in the true direction - a value of false doesn't
    promise that there is an unmasked pixel, just that we are pretty sure
    that there is one. Edge cases where a false value clips the corner of
    a region might have region search return false, while when you look at
    it pixel by pixel every point ends up being masked.

    Typically a Mask has an underlying RasterImage or something similar. A
    particular GroundCoordinate probably doesn't fall exactly on a pixel
    of the Mask. How we interpolate is defined by the particular derived
    class uses - a common approach is to mask if any of the 4 neighboring
    pixels are masked (but check the derived class for details).

    C++ includes: mask.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def mask(self, *args):
        """
        virtual bool GeoCal::Mask::mask(const GroundCoordinate &Gc) const =0
        Indicate if a particular point is masked.

        If true, the point is masked and should not be used in processing
        (e.g., don't do image matching) 
        """
        return _geocal.Mask_mask(self, *args)

    def region_masked(self, *args):
        """
        virtual bool GeoCal::Mask::region_masked(const GroundCoordinate &Ulc, const GroundCoordinate &Lrc) const =0
        Indicated if a region is all masked or not.

        See the discussion in the comments of Mask for detailed discussion of
        the check. 
        """
        return _geocal.Mask_region_masked(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< Mask  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Mask___str__(self)

    __swig_destroy__ = _geocal.delete_Mask
Mask.mask = new_instancemethod(_geocal.Mask_mask,None,Mask)
Mask.region_masked = new_instancemethod(_geocal.Mask_region_masked,None,Mask)
Mask.__str__ = new_instancemethod(_geocal.Mask___str__,None,Mask)
Mask_swigregister = _geocal.Mask_swigregister
Mask_swigregister(Mask)

class CombinedMask(Mask):
    """
    This is combines a set of masks into a single one.

    The combination just check each mask in turn, and if any of them
    indicates a point or a region is masked, then we return true.

    Note that this class handles the degenerate case of no masked. This is
    particular useful in handling situations where you might or might not
    have mask, e.g. a general routine that can take a mask but where you
    don't happen to have any masks in a particular case.

    When there are no masks, we return true.

    C++ includes: mask.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::CombinedMask::CombinedMask(It First, It Last)
        Create a CombinedMask using the given set of masks, where we get this
        from a general InputIterator. 
        """
        _geocal.CombinedMask_swiginit(self,_geocal.new_CombinedMask(*args))
    mask_list = _swig_property(_geocal.CombinedMask_mask_list_get, _geocal.CombinedMask_mask_list_set)
    def __reduce__(self):
      return _new_from_init, (self.__class__, self.mask_list)

    __swig_destroy__ = _geocal.delete_CombinedMask
CombinedMask_swigregister = _geocal.CombinedMask_swigregister
CombinedMask_swigregister(CombinedMask)

class Vector_Mask(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_Mask_swiginit(self,_geocal.new_Vector_Mask(*args))
    __swig_destroy__ = _geocal.delete_Vector_Mask
Vector_Mask.iterator = new_instancemethod(_geocal.Vector_Mask_iterator,None,Vector_Mask)
Vector_Mask.__nonzero__ = new_instancemethod(_geocal.Vector_Mask___nonzero__,None,Vector_Mask)
Vector_Mask.__bool__ = new_instancemethod(_geocal.Vector_Mask___bool__,None,Vector_Mask)
Vector_Mask.__len__ = new_instancemethod(_geocal.Vector_Mask___len__,None,Vector_Mask)
Vector_Mask.pop = new_instancemethod(_geocal.Vector_Mask_pop,None,Vector_Mask)
Vector_Mask.__getslice__ = new_instancemethod(_geocal.Vector_Mask___getslice__,None,Vector_Mask)
Vector_Mask.__setslice__ = new_instancemethod(_geocal.Vector_Mask___setslice__,None,Vector_Mask)
Vector_Mask.__delslice__ = new_instancemethod(_geocal.Vector_Mask___delslice__,None,Vector_Mask)
Vector_Mask.__delitem__ = new_instancemethod(_geocal.Vector_Mask___delitem__,None,Vector_Mask)
Vector_Mask.__getitem__ = new_instancemethod(_geocal.Vector_Mask___getitem__,None,Vector_Mask)
Vector_Mask.__setitem__ = new_instancemethod(_geocal.Vector_Mask___setitem__,None,Vector_Mask)
Vector_Mask.append = new_instancemethod(_geocal.Vector_Mask_append,None,Vector_Mask)
Vector_Mask.empty = new_instancemethod(_geocal.Vector_Mask_empty,None,Vector_Mask)
Vector_Mask.size = new_instancemethod(_geocal.Vector_Mask_size,None,Vector_Mask)
Vector_Mask.clear = new_instancemethod(_geocal.Vector_Mask_clear,None,Vector_Mask)
Vector_Mask.swap = new_instancemethod(_geocal.Vector_Mask_swap,None,Vector_Mask)
Vector_Mask.get_allocator = new_instancemethod(_geocal.Vector_Mask_get_allocator,None,Vector_Mask)
Vector_Mask.begin = new_instancemethod(_geocal.Vector_Mask_begin,None,Vector_Mask)
Vector_Mask.end = new_instancemethod(_geocal.Vector_Mask_end,None,Vector_Mask)
Vector_Mask.rbegin = new_instancemethod(_geocal.Vector_Mask_rbegin,None,Vector_Mask)
Vector_Mask.rend = new_instancemethod(_geocal.Vector_Mask_rend,None,Vector_Mask)
Vector_Mask.pop_back = new_instancemethod(_geocal.Vector_Mask_pop_back,None,Vector_Mask)
Vector_Mask.erase = new_instancemethod(_geocal.Vector_Mask_erase,None,Vector_Mask)
Vector_Mask.push_back = new_instancemethod(_geocal.Vector_Mask_push_back,None,Vector_Mask)
Vector_Mask.front = new_instancemethod(_geocal.Vector_Mask_front,None,Vector_Mask)
Vector_Mask.back = new_instancemethod(_geocal.Vector_Mask_back,None,Vector_Mask)
Vector_Mask.assign = new_instancemethod(_geocal.Vector_Mask_assign,None,Vector_Mask)
Vector_Mask.resize = new_instancemethod(_geocal.Vector_Mask_resize,None,Vector_Mask)
Vector_Mask.insert = new_instancemethod(_geocal.Vector_Mask_insert,None,Vector_Mask)
Vector_Mask.reserve = new_instancemethod(_geocal.Vector_Mask_reserve,None,Vector_Mask)
Vector_Mask.capacity = new_instancemethod(_geocal.Vector_Mask_capacity,None,Vector_Mask)
Vector_Mask_swigregister = _geocal.Vector_Mask_swigregister
Vector_Mask_swigregister(Vector_Mask)

class Datum(object):
    """
    This is a Datum, which returns the distance from mean sea level to a
    reference ellipsoid.

    C++ includes: geocal_datum.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def undulation(self, *args):
        """
        virtual double GeoCal::Datum::undulation(const GroundCoordinate &Gc) const =0
        Undulation, which is the distance form mean sea level to the reference
        ellipsoid, for the given ground location.

        This is in meters. 
        """
        return _geocal.Datum_undulation(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< Datum  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Datum___str__(self)

    __swig_destroy__ = _geocal.delete_Datum
Datum.undulation = new_instancemethod(_geocal.Datum_undulation,None,Datum)
Datum.__str__ = new_instancemethod(_geocal.Datum___str__,None,Datum)
Datum_swigregister = _geocal.Datum_swigregister
Datum_swigregister(Datum)

class SimpleDatum(Datum):
    """
    This is a Datum which returns a constant undulation everywhere.

    This is useful for testing, and also in the case you are using a Dem
    with height already relative to the reference surface, so no Datum
    correction is needed.

    C++ includes: geocal_datum.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, U=0.0): 
        """
        GeoCal::SimpleDatum::SimpleDatum(double U=0.0)
        Constructor. 
        """
        _geocal.SimpleDatum_swiginit(self,_geocal.new_SimpleDatum(U))
    def _u(self):
        """
        double GeoCal::SimpleDatum::u() const
        Fixed value that is returned by this class. 
        """
        return _geocal.SimpleDatum__u(self)

    @property
    def u(self):
        return self._u()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.u)

    __swig_destroy__ = _geocal.delete_SimpleDatum
SimpleDatum._u = new_instancemethod(_geocal.SimpleDatum__u,None,SimpleDatum)
SimpleDatum_swigregister = _geocal.SimpleDatum_swigregister
SimpleDatum_swigregister(SimpleDatum)

class SimpleDem(Dem):
    """
    This is a simple implementation of a Dem, intended primarily for use
    during testing.

    It find the height of a given point above the WGS84 ellipsoid + fixed
    height, in geodetic coordinates.

    C++ includes: simple_dem.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, H=0): 
        """
        GeoCal::SimpleDem::SimpleDem(double H=0)
        Default constructor. 
        """
        _geocal.SimpleDem_swiginit(self,_geocal.new_SimpleDem(H))
    def _h(self, *args):
        """
        void GeoCal::SimpleDem::h(double Hnew)
        Set height value used by this object. 
        """
        return _geocal.SimpleDem__h(self, *args)

    @property
    def h(self):
        return self._h()

    @h.setter
    def h(self, value):
      self._h(value)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.h)

    __swig_destroy__ = _geocal.delete_SimpleDem
SimpleDem._h = new_instancemethod(_geocal.SimpleDem__h,None,SimpleDem)
SimpleDem_swigregister = _geocal.SimpleDem_swigregister
SimpleDem_swigregister(SimpleDem)

class MemoryRasterImage(RasterImageVariable):
    """
    This is a simple implementation of a RasterImage, where the data is
    just stored in a 2D array.

    This is useful both for testing and to read all of another RasterImage
    into memory.

    C++ includes: memory_raster_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::MemoryRasterImage::MemoryRasterImage(const MapInfo &Mi)
        Construct a MemoryRasterImage of the given MapInfo. 
        """
        _geocal.MemoryRasterImage_swiginit(self,_geocal.new_MemoryRasterImage(*args))
    __swig_destroy__ = _geocal.delete_MemoryRasterImage
MemoryRasterImage_swigregister = _geocal.MemoryRasterImage_swigregister
MemoryRasterImage_swigregister(MemoryRasterImage)

class DemMapInfo(Dem):
    """
    This handles a Dem from a file with a MapInfo.

    A very common Dem is one where the height is a geodetic height
    relative to a Datum on a regular grid in some map projection (e.g., a
    GeoTiff file containing elevations on a latitude/longitude grid). This
    class implements surface_gp and distance_to_surface in terms of a
    derived class supplied "elevation" function.

    We do a bilinear interpolation to get heights in between the values
    given by elevation.

    Depending on what we are doing, calling with a location outside of the
    underlying DEM data might be ok, or might be something that should
    trigger an error. If requested, this class can just return a
    height_reference_surface of 0 everywhere outside of the Dem (so
    height_datum is -datum().undulation).

    Derived classes need to call the constructor or initialize(), and fill
    in the elavation() function.

    C++ includes: dem_map_info.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def _datum(self):
        """
        const boost::shared_ptr<Datum> GeoCal::DemMapInfo::datum_ptr() const
        Pointer to datum. 
        """
        return _geocal.DemMapInfo__datum(self)

    @property
    def datum(self):
        return self._datum()

    def _map_info(self):
        """
        const MapInfo& GeoCal::DemMapInfo::map_info() const
        MapInfo of underlying data. 
        """
        return _geocal.DemMapInfo__map_info(self)

    @property
    def map_info(self):
        return self._map_info()

    def height_datum(self, *args):
        """
        double DemMapInfo::height_datum(const GroundCoordinate &Gp) const
        Height relative to datum. 
        """
        return _geocal.DemMapInfo_height_datum(self, *args)

    def _outside_dem_is_error(self):
        """
        bool GeoCal::DemMapInfo::outside_dem_is_error() const
        If true, then calling with values outside the range of area of the DEM
        triggers an exception, otherwise we just return a height of 0. 
        """
        return _geocal.DemMapInfo__outside_dem_is_error(self)

    @property
    def outside_dem_is_error(self):
        return self._outside_dem_is_error()

    __swig_destroy__ = _geocal.delete_DemMapInfo
DemMapInfo._datum = new_instancemethod(_geocal.DemMapInfo__datum,None,DemMapInfo)
DemMapInfo._map_info = new_instancemethod(_geocal.DemMapInfo__map_info,None,DemMapInfo)
DemMapInfo.height_datum = new_instancemethod(_geocal.DemMapInfo_height_datum,None,DemMapInfo)
DemMapInfo._outside_dem_is_error = new_instancemethod(_geocal.DemMapInfo__outside_dem_is_error,None,DemMapInfo)
DemMapInfo_swigregister = _geocal.DemMapInfo_swigregister
DemMapInfo_swigregister(DemMapInfo)

class InterestPoint(object):
    """
    This is an interest point, determined by a FeatureDetector.

    C++ includes: feature_detector.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::InterestPoint::InterestPoint(const ImageCoordinate &Ic, double Weight)
        Constructor. 
        """
        _geocal.InterestPoint_swiginit(self,_geocal.new_InterestPoint(*args))
    image_coordinate = _swig_property(_geocal.InterestPoint_image_coordinate_get, _geocal.InterestPoint_image_coordinate_set)
    weight = _swig_property(_geocal.InterestPoint_weight_get, _geocal.InterestPoint_weight_set)
    def __str__(self):
        """
        std::string GeoCal::Printable< InterestPoint  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.InterestPoint___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.image_coordinate,self.weight)

    __swig_destroy__ = _geocal.delete_InterestPoint
InterestPoint.__str__ = new_instancemethod(_geocal.InterestPoint___str__,None,InterestPoint)
InterestPoint.compare = new_instancemethod(_geocal.InterestPoint_compare,None,InterestPoint)
InterestPoint_swigregister = _geocal.InterestPoint_swigregister
InterestPoint_swigregister(InterestPoint)

class FeatureDetector(object):
    """
    This class detects interest points in an image.

    An interest point is one that is good for image matching by some sort
    of criteria. For example, a common feature detector is one that tries
    to detect corners, with the idea that these are good choices for doing
    image matching on.

    C++ includes: feature_detector.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def interest_point_detect(self, *args):
        """
        virtual std::vector<InterestPoint> GeoCal::FeatureDetector::interest_point_detect(const RasterImage &Img) const =0
        Go through a RasterImage, and return a list of InterstPoints for it.

        The list isn't in any particular order, but note that InterstPoints
        have a natural order by the weight, and you can sort the points if
        desired using std::sort, or just pick at the "best" point by
        std::max_element. 
        """
        return _geocal.FeatureDetector_interest_point_detect(self, *args)

    def _interest_point_grid_raw(self, *args):
        """
        boost::shared_ptr< ImageCoordinate > FeatureDetector::interest_point_grid_ptr(const RasterImage &Img, int i, int j, int Number_grid_line, int
        Number_grid_sample, int Border=0) const
        Python much prefers getting shared_ptr back, so we have this variation
        that wraps that.

        We also return only a single point. This is a somewhat awkward
        interface, but it gets wrapped into a interest_point_grid function in
        python, possibly doing processing in parallel. 
        """
        return _geocal.FeatureDetector__interest_point_grid_raw(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< FeatureDetector  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.FeatureDetector___str__(self)

    __swig_destroy__ = _geocal.delete_FeatureDetector
FeatureDetector.interest_point_detect = new_instancemethod(_geocal.FeatureDetector_interest_point_detect,None,FeatureDetector)
FeatureDetector._interest_point_grid_raw = new_instancemethod(_geocal.FeatureDetector__interest_point_grid_raw,None,FeatureDetector)
FeatureDetector.__str__ = new_instancemethod(_geocal.FeatureDetector___str__,None,FeatureDetector)
FeatureDetector_swigregister = _geocal.FeatureDetector_swigregister
FeatureDetector_swigregister(FeatureDetector)

class Vector_InterestPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_InterestPoint_swiginit(self,_geocal.new_Vector_InterestPoint(*args))
    __swig_destroy__ = _geocal.delete_Vector_InterestPoint
Vector_InterestPoint.iterator = new_instancemethod(_geocal.Vector_InterestPoint_iterator,None,Vector_InterestPoint)
Vector_InterestPoint.__nonzero__ = new_instancemethod(_geocal.Vector_InterestPoint___nonzero__,None,Vector_InterestPoint)
Vector_InterestPoint.__bool__ = new_instancemethod(_geocal.Vector_InterestPoint___bool__,None,Vector_InterestPoint)
Vector_InterestPoint.__len__ = new_instancemethod(_geocal.Vector_InterestPoint___len__,None,Vector_InterestPoint)
Vector_InterestPoint.pop = new_instancemethod(_geocal.Vector_InterestPoint_pop,None,Vector_InterestPoint)
Vector_InterestPoint.__getslice__ = new_instancemethod(_geocal.Vector_InterestPoint___getslice__,None,Vector_InterestPoint)
Vector_InterestPoint.__setslice__ = new_instancemethod(_geocal.Vector_InterestPoint___setslice__,None,Vector_InterestPoint)
Vector_InterestPoint.__delslice__ = new_instancemethod(_geocal.Vector_InterestPoint___delslice__,None,Vector_InterestPoint)
Vector_InterestPoint.__delitem__ = new_instancemethod(_geocal.Vector_InterestPoint___delitem__,None,Vector_InterestPoint)
Vector_InterestPoint.__getitem__ = new_instancemethod(_geocal.Vector_InterestPoint___getitem__,None,Vector_InterestPoint)
Vector_InterestPoint.__setitem__ = new_instancemethod(_geocal.Vector_InterestPoint___setitem__,None,Vector_InterestPoint)
Vector_InterestPoint.append = new_instancemethod(_geocal.Vector_InterestPoint_append,None,Vector_InterestPoint)
Vector_InterestPoint.empty = new_instancemethod(_geocal.Vector_InterestPoint_empty,None,Vector_InterestPoint)
Vector_InterestPoint.size = new_instancemethod(_geocal.Vector_InterestPoint_size,None,Vector_InterestPoint)
Vector_InterestPoint.clear = new_instancemethod(_geocal.Vector_InterestPoint_clear,None,Vector_InterestPoint)
Vector_InterestPoint.swap = new_instancemethod(_geocal.Vector_InterestPoint_swap,None,Vector_InterestPoint)
Vector_InterestPoint.get_allocator = new_instancemethod(_geocal.Vector_InterestPoint_get_allocator,None,Vector_InterestPoint)
Vector_InterestPoint.begin = new_instancemethod(_geocal.Vector_InterestPoint_begin,None,Vector_InterestPoint)
Vector_InterestPoint.end = new_instancemethod(_geocal.Vector_InterestPoint_end,None,Vector_InterestPoint)
Vector_InterestPoint.rbegin = new_instancemethod(_geocal.Vector_InterestPoint_rbegin,None,Vector_InterestPoint)
Vector_InterestPoint.rend = new_instancemethod(_geocal.Vector_InterestPoint_rend,None,Vector_InterestPoint)
Vector_InterestPoint.pop_back = new_instancemethod(_geocal.Vector_InterestPoint_pop_back,None,Vector_InterestPoint)
Vector_InterestPoint.erase = new_instancemethod(_geocal.Vector_InterestPoint_erase,None,Vector_InterestPoint)
Vector_InterestPoint.push_back = new_instancemethod(_geocal.Vector_InterestPoint_push_back,None,Vector_InterestPoint)
Vector_InterestPoint.front = new_instancemethod(_geocal.Vector_InterestPoint_front,None,Vector_InterestPoint)
Vector_InterestPoint.back = new_instancemethod(_geocal.Vector_InterestPoint_back,None,Vector_InterestPoint)
Vector_InterestPoint.assign = new_instancemethod(_geocal.Vector_InterestPoint_assign,None,Vector_InterestPoint)
Vector_InterestPoint.resize = new_instancemethod(_geocal.Vector_InterestPoint_resize,None,Vector_InterestPoint)
Vector_InterestPoint.insert = new_instancemethod(_geocal.Vector_InterestPoint_insert,None,Vector_InterestPoint)
Vector_InterestPoint.reserve = new_instancemethod(_geocal.Vector_InterestPoint_reserve,None,Vector_InterestPoint)
Vector_InterestPoint.capacity = new_instancemethod(_geocal.Vector_InterestPoint_capacity,None,Vector_InterestPoint)
Vector_InterestPoint_swigregister = _geocal.Vector_InterestPoint_swigregister
Vector_InterestPoint_swigregister(Vector_InterestPoint)

class ForstnerFeatureDetector(FeatureDetector):
    """
    This class detects interest points in an image using Forstner feature
    detection.

    C++ includes: forstner_feature_detector.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, Basic_ip_large_number=1000, Maximum_weight_threshold=10000, Forstner_max_window_large_size=9, 
    Forstner_max_window_small_size=7, Forstner_window_size=3, Roundness_threshold=0.2, 
    Weight_threshold=1.0, Basic_robert_threshold=1.2): 
        """
        BZ_END_STENCIL ForstnerFeatureDetector::ForstnerFeatureDetector(int Basic_ip_large_number=1000, int Maximum_weight_threshold=10000,
        int Forstner_max_window_large_size=9, int
        Forstner_max_window_small_size=7, int Forstner_window_size=3, double
        Roundness_threshold=0.2, double Weight_threshold=1.0, double
        Basic_robert_threshold=1.2)
        Constructor. 
        """
        _geocal.ForstnerFeatureDetector_swiginit(self,_geocal.new_ForstnerFeatureDetector(Basic_ip_large_number, Maximum_weight_threshold, Forstner_max_window_large_size, 
    Forstner_max_window_small_size, Forstner_window_size, Roundness_threshold, 
    Weight_threshold, Basic_robert_threshold))
    def _basic_ip_large_number(self):
        """
        int GeoCal::ForstnerFeatureDetector::basic_ip_large_number() const

        """
        return _geocal.ForstnerFeatureDetector__basic_ip_large_number(self)

    @property
    def basic_ip_large_number(self):
        return self._basic_ip_large_number()

    def _maximum_weight_threshold(self):
        """
        int GeoCal::ForstnerFeatureDetector::maximum_weight_threshold() const

        """
        return _geocal.ForstnerFeatureDetector__maximum_weight_threshold(self)

    @property
    def maximum_weight_threshold(self):
        return self._maximum_weight_threshold()

    def _forstner_max_window_large_size(self):
        """
        int GeoCal::ForstnerFeatureDetector::forstner_max_window_large_size() const

        """
        return _geocal.ForstnerFeatureDetector__forstner_max_window_large_size(self)

    @property
    def forstner_max_window_large_size(self):
        return self._forstner_max_window_large_size()

    def _forstner_max_window_small_size(self):
        """
        int GeoCal::ForstnerFeatureDetector::forstner_max_window_small_size() const

        """
        return _geocal.ForstnerFeatureDetector__forstner_max_window_small_size(self)

    @property
    def forstner_max_window_small_size(self):
        return self._forstner_max_window_small_size()

    def _forstner_window_size(self):
        """
        int GeoCal::ForstnerFeatureDetector::forstner_window_size() const

        """
        return _geocal.ForstnerFeatureDetector__forstner_window_size(self)

    @property
    def forstner_window_size(self):
        return self._forstner_window_size()

    def _roundness_threshold(self):
        """
        double GeoCal::ForstnerFeatureDetector::roundness_threshold() const

        """
        return _geocal.ForstnerFeatureDetector__roundness_threshold(self)

    @property
    def roundness_threshold(self):
        return self._roundness_threshold()

    def _weight_threshold(self):
        """
        double GeoCal::ForstnerFeatureDetector::weight_threshold() const

        """
        return _geocal.ForstnerFeatureDetector__weight_threshold(self)

    @property
    def weight_threshold(self):
        return self._weight_threshold()

    def _basic_robert_threshold(self):
        """
        double GeoCal::ForstnerFeatureDetector::basic_robert_threshold() const

        """
        return _geocal.ForstnerFeatureDetector__basic_robert_threshold(self)

    @property
    def basic_robert_threshold(self):
        return self._basic_robert_threshold()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.basic_ip_large_number,self.maximum_weight_threshold,self.forstner_max_window_large_size,self.forstner_max_window_small_size,self.forstner_window_size,self.roundness_threshold,self.weight_threshold,self.basic_robert_threshold)

    __swig_destroy__ = _geocal.delete_ForstnerFeatureDetector
ForstnerFeatureDetector._basic_ip_large_number = new_instancemethod(_geocal.ForstnerFeatureDetector__basic_ip_large_number,None,ForstnerFeatureDetector)
ForstnerFeatureDetector._maximum_weight_threshold = new_instancemethod(_geocal.ForstnerFeatureDetector__maximum_weight_threshold,None,ForstnerFeatureDetector)
ForstnerFeatureDetector._forstner_max_window_large_size = new_instancemethod(_geocal.ForstnerFeatureDetector__forstner_max_window_large_size,None,ForstnerFeatureDetector)
ForstnerFeatureDetector._forstner_max_window_small_size = new_instancemethod(_geocal.ForstnerFeatureDetector__forstner_max_window_small_size,None,ForstnerFeatureDetector)
ForstnerFeatureDetector._forstner_window_size = new_instancemethod(_geocal.ForstnerFeatureDetector__forstner_window_size,None,ForstnerFeatureDetector)
ForstnerFeatureDetector._roundness_threshold = new_instancemethod(_geocal.ForstnerFeatureDetector__roundness_threshold,None,ForstnerFeatureDetector)
ForstnerFeatureDetector._weight_threshold = new_instancemethod(_geocal.ForstnerFeatureDetector__weight_threshold,None,ForstnerFeatureDetector)
ForstnerFeatureDetector._basic_robert_threshold = new_instancemethod(_geocal.ForstnerFeatureDetector__basic_robert_threshold,None,ForstnerFeatureDetector)
ForstnerFeatureDetector_swigregister = _geocal.ForstnerFeatureDetector_swigregister
ForstnerFeatureDetector_swigregister(ForstnerFeatureDetector)

class ImageMatcher(object):
    """
    This class performs image matching, finding the location of a point in
    a reference image in a new image.

    C++ includes: image_matcher.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def match(self, *args):
        """
        virtual void GeoCal::ImageMatcher::match(const RasterImage &Ref, const RasterImage &New, const ImageCoordinate
        &Ref_loc, const ImageCoordinate &New_guess, ImageCoordinate &New_res,
        double &Line_sigma, double &Sample_sigma, bool &Success, int
        *Diagnostic=0) const =0
        Match a point found in the reference image with a point in the new
        image.

        A initial guess in the new image is supplied. We return an improved
        image in the new image along with the uncertainty if Success is true,
        otherwise the match failed.

        The Diagnostic argument is used to indicate why a match failed. For
        many purposes you can ignore this, because you need to know detailed
        information about the specific ImageMatcher that a user passed to a
        function and what the diagnostic codes mean. However, for some
        purposes the failure reason can be useful (e.g., tuning parameters of
        a LsmMatcher). 
        """
        return _geocal.ImageMatcher_match(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< ImageMatcher  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.ImageMatcher___str__(self)

    __swig_destroy__ = _geocal.delete_ImageMatcher
ImageMatcher.match = new_instancemethod(_geocal.ImageMatcher_match,None,ImageMatcher)
ImageMatcher.__str__ = new_instancemethod(_geocal.ImageMatcher___str__,None,ImageMatcher)
ImageMatcher_swigregister = _geocal.ImageMatcher_swigregister
ImageMatcher_swigregister(ImageMatcher)

class ImageToImageMatch(object):
    """
    This class find matches between two images.

    This is similar to the class ImageMatcher, but in addition to doing
    the matching it also keeps track of which two images we are matching,
    and how we do the initial guess for the location in the second image.

    C++ includes: image_to_image_match.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def match(self, *args):
        """
        virtual void GeoCal::ImageToImageMatch::match(const ImageCoordinate &Ic1, ImageCoordinate &Ic2, double &Line_sigma,
        double &Sample_sigma, bool &Success, int *Diagnostic=0) const =0
        Match point Ic1 in the first image with the second image.

        We return the location in the second image along with the uncertainty
        if Success is true, otherwise the match failed.

        The Diagnostic argument is used to indicate why a match failed. For
        many purposes you can ignore this, because you need to know detailed
        information about the specific ImageMatcher that a user passed to a
        function and what the diagnostic codes mean. However, for some
        purposes the failure reason can be useful (e.g., tuning parameters of
        a LsmMatcher). 
        """
        return _geocal.ImageToImageMatch_match(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< ImageToImageMatch  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.ImageToImageMatch___str__(self)

    __swig_destroy__ = _geocal.delete_ImageToImageMatch
ImageToImageMatch.match = new_instancemethod(_geocal.ImageToImageMatch_match,None,ImageToImageMatch)
ImageToImageMatch.__str__ = new_instancemethod(_geocal.ImageToImageMatch___str__,None,ImageToImageMatch)
ImageToImageMatch_swigregister = _geocal.ImageToImageMatch_swigregister
ImageToImageMatch_swigregister(ImageToImageMatch)

class CcorrMatcher(ImageMatcher):
    """
    This class performs image matching.

    It does a normalized cross correlation match.

    C++ includes: ccorr_matcher.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, Target_nline=37, Target_nsamp=37, Template_nline=9, Template_nsamp=9, Min_ccorr=0.3, 
    Min_variance=0): 
        """
        CcorrMatcher::CcorrMatcher(int Target_nline=37, int Target_nsamp=37, int Template_nline=9, int
        Template_nsamp=9, double Min_ccorr=0.3, double Min_variance=0)

        """
        _geocal.CcorrMatcher_swiginit(self,_geocal.new_CcorrMatcher(Target_nline, Target_nsamp, Template_nline, Template_nsamp, Min_ccorr, Min_variance))
    def _min_correlation(self):
        """
        double GeoCal::CcorrMatcher::min_correlation() const
        Minimum correlation threshold. 
        """
        return _geocal.CcorrMatcher__min_correlation(self)

    @property
    def min_correlation(self):
        return self._min_correlation()

    def _min_variance(self):
        """
        double GeoCal::CcorrMatcher::min_variance() const
        Minimum variance threshold. 
        """
        return _geocal.CcorrMatcher__min_variance(self)

    @property
    def min_variance(self):
        return self._min_variance()

    def _target_number_line(self):
        """
        int GeoCal::CcorrMatcher::target_number_line() const
        Number of lines in target window. 
        """
        return _geocal.CcorrMatcher__target_number_line(self)

    @property
    def target_number_line(self):
        return self._target_number_line()

    def _target_number_sample(self):
        """
        int GeoCal::CcorrMatcher::target_number_sample() const
        Number of samples in target window. 
        """
        return _geocal.CcorrMatcher__target_number_sample(self)

    @property
    def target_number_sample(self):
        return self._target_number_sample()

    def _template_number_line(self):
        """
        int GeoCal::CcorrMatcher::template_number_line() const
        Number of lines in template window. 
        """
        return _geocal.CcorrMatcher__template_number_line(self)

    @property
    def template_number_line(self):
        return self._template_number_line()

    def _template_number_sample(self):
        """
        int GeoCal::CcorrMatcher::template_number_sample() const
        Number of samples in template window. 
        """
        return _geocal.CcorrMatcher__template_number_sample(self)

    @property
    def template_number_sample(self):
        return self._template_number_sample()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.target_number_line,self.target_number_sample,self.template_number_line,self.template_number_sample,self.min_correlation,self.min_variance)

    __swig_destroy__ = _geocal.delete_CcorrMatcher
CcorrMatcher._min_correlation = new_instancemethod(_geocal.CcorrMatcher__min_correlation,None,CcorrMatcher)
CcorrMatcher._min_variance = new_instancemethod(_geocal.CcorrMatcher__min_variance,None,CcorrMatcher)
CcorrMatcher._target_number_line = new_instancemethod(_geocal.CcorrMatcher__target_number_line,None,CcorrMatcher)
CcorrMatcher._target_number_sample = new_instancemethod(_geocal.CcorrMatcher__target_number_sample,None,CcorrMatcher)
CcorrMatcher._template_number_line = new_instancemethod(_geocal.CcorrMatcher__template_number_line,None,CcorrMatcher)
CcorrMatcher._template_number_sample = new_instancemethod(_geocal.CcorrMatcher__template_number_sample,None,CcorrMatcher)
CcorrMatcher_swigregister = _geocal.CcorrMatcher_swigregister
CcorrMatcher_swigregister(CcorrMatcher)

class LsmMatcher(ImageMatcher):
    """
    This class performs image matching.

    This does a nonlinear least squares match. It also calculates an
    estimate of the error in its matching.

    We attempt to reach a goal of precision_goal in determining a0 and b0.
    If at any iteration, the uncertainty in determining a0 and b0 is
    greater than max_sigma, then we give up on doing LSM. If the final
    uncertainty in determining a0 and b0 is larger than
    precision_requirement, then we give up on doing LSM. We now also check
    radiometric uncertainty at each iteration as described in MISR SDS
    DFM-0245-I. The maximum allowed radiometric uncertainty is calculated
    by multiplying the factor radiometric_uncertainty_factor by the
    minimum of the template and target window sigmas. After each iteration
    in the lsm the uncertainty in the calculation of h0 is greater than
    this threshold we stop doing LSM and return unsuccessful.

    The minimum uncertainty that will be returned is precision_goal (i.e.,
    if the estimated uncertainty is smaller than this value, then
    precision_goal is returned instead).

    The model used is to resample the target using an affine
    transformation combined with a linear correction to the radiometry:

    g'(i, j) = h0 + h1 * g(a0 + a1 * i + a2 * j, b0 + b1 * i + b2 * j)

    Where g is the target, g' is the template.

    As a convention, internal to this class we index things so g'(0, 0) is
    the center of the template.

    We solve for the parameters giving the best fit against the template.

    C++ includes: lsm_matcher.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, Number_line=21, Number_sample=21, Border_size=3, Precision_goal=0.0625, Precision_requirement=0.2, 
    Max_sigma=0.5, Rad_uncertainty_factor=2.0, Precision_min_geo_goal=0.15, 
    Precision_min_rad_goal=1): 
        """
        LsmMatcher::LsmMatcher(const LsmMatcher &M)
        Copy constructor. 
        """
        _geocal.LsmMatcher_swiginit(self,_geocal.new_LsmMatcher(Number_line, Number_sample, Border_size, Precision_goal, Precision_requirement, Max_sigma, 
    Rad_uncertainty_factor, Precision_min_geo_goal, Precision_min_rad_goal))
    def _number_line(self):
        """
        int GeoCal::LsmMatcher::number_line() const
        Number of lines in target and template. 
        """
        return _geocal.LsmMatcher__number_line(self)

    @property
    def number_line(self):
        return self._number_line()

    def _number_sample(self):
        """
        int GeoCal::LsmMatcher::number_sample() const
        Number of samples in target and template. 
        """
        return _geocal.LsmMatcher__number_sample(self)

    @property
    def number_sample(self):
        return self._number_sample()

    def _border_size(self):
        """
        int GeoCal::LsmMatcher::border_size() const
        Border added to target to allow for template/target shift. 
        """
        return _geocal.LsmMatcher__border_size(self)

    @property
    def border_size(self):
        return self._border_size()

    def _precision_goal(self):
        """
        double GeoCal::LsmMatcher::precision_goal() const
        Goal in doing solving LSM. 
        """
        return _geocal.LsmMatcher__precision_goal(self)

    @property
    def precision_goal(self):
        return self._precision_goal()

    def _precision_requirement(self):
        """
        double GeoCal::LsmMatcher::precision_requirement() const
        Requirement for LSM success. 
        """
        return _geocal.LsmMatcher__precision_requirement(self)

    @property
    def precision_requirement(self):
        return self._precision_requirement()

    def _max_sigma(self):
        """
        double GeoCal::LsmMatcher::max_sigma() const
        If at any stagee in solving LSM uncertainty is greater than this
        value, then give up doing image matching. 
        """
        return _geocal.LsmMatcher__max_sigma(self)

    @property
    def max_sigma(self):
        return self._max_sigma()

    def _rad_uncertainty_factor(self):
        """
        double GeoCal::LsmMatcher::rad_uncertainty_factor() const
        This factor is used to scale the maximum allowable radiometric
        uncertainty while solving LSM. 
        """
        return _geocal.LsmMatcher__rad_uncertainty_factor(self)

    @property
    def rad_uncertainty_factor(self):
        return self._rad_uncertainty_factor()

    def _precision_min_geo_goal(self):
        """
        double GeoCal::LsmMatcher::precision_min_geo_goal() const
        Minimum geometric goal for LSM to success. 
        """
        return _geocal.LsmMatcher__precision_min_geo_goal(self)

    @property
    def precision_min_geo_goal(self):
        return self._precision_min_geo_goal()

    def _precision_min_rad_goal(self):
        """
        double GeoCal::LsmMatcher::precision_min_rad_goal() const
        Minimum radiometric goal for LSM to success. 
        """
        return _geocal.LsmMatcher__precision_min_rad_goal(self)

    @property
    def precision_min_rad_goal(self):
        return self._precision_min_rad_goal()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.number_line,self.number_sample,self.border_size,self.precision_goal,self.precision_requirement,self.max_sigma,self.rad_uncertainty_factor,self.precision_min_geo_goal,self.precision_min_rad_goal)

    __swig_destroy__ = _geocal.delete_LsmMatcher
LsmMatcher._number_line = new_instancemethod(_geocal.LsmMatcher__number_line,None,LsmMatcher)
LsmMatcher._number_sample = new_instancemethod(_geocal.LsmMatcher__number_sample,None,LsmMatcher)
LsmMatcher._border_size = new_instancemethod(_geocal.LsmMatcher__border_size,None,LsmMatcher)
LsmMatcher._precision_goal = new_instancemethod(_geocal.LsmMatcher__precision_goal,None,LsmMatcher)
LsmMatcher._precision_requirement = new_instancemethod(_geocal.LsmMatcher__precision_requirement,None,LsmMatcher)
LsmMatcher._max_sigma = new_instancemethod(_geocal.LsmMatcher__max_sigma,None,LsmMatcher)
LsmMatcher._rad_uncertainty_factor = new_instancemethod(_geocal.LsmMatcher__rad_uncertainty_factor,None,LsmMatcher)
LsmMatcher._precision_min_geo_goal = new_instancemethod(_geocal.LsmMatcher__precision_min_geo_goal,None,LsmMatcher)
LsmMatcher._precision_min_rad_goal = new_instancemethod(_geocal.LsmMatcher__precision_min_rad_goal,None,LsmMatcher)
LsmMatcher_swigregister = _geocal.LsmMatcher_swigregister
LsmMatcher_swigregister(LsmMatcher)

class CcorrLsmMatcher(ImageMatcher):
    """
    This class performs image matching.

    It first does a cross correlation match using CcorrMatcher to get to
    within a pixel, and then follows up with a least squares match using
    LsmMatcher to get subpixel accuracy.

    C++ includes: ccorr_lsm_matcher.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::CcorrLsmMatcher::CcorrLsmMatcher(const boost::shared_ptr< CcorrMatcher > &Ccorr, const
        boost::shared_ptr< LsmMatcher > &Lsm, bool Accept_ccorr_only=false)
        Constructor.

        This takes the CcorrMatcher and LsmMatcher, which allows you to use
        something other than the default values for the construction of these.

        There are two possibilities when a LSM fails. We can either have the
        whole match fail, or alternatively we can fall back on doing the Cccor
        only. The choice depends on how you are using the matches - are more
        matches of ok quality important, or do you only want the best possible
        matches as the cost of some coverage? 
        """
        _geocal.CcorrLsmMatcher_swiginit(self,_geocal.new_CcorrLsmMatcher(*args))
    def _ccorr_matcher(self):
        """
        boost::shared_ptr<CcorrMatcher> GeoCal::CcorrLsmMatcher::ccorr_matcher_ptr() const

        """
        return _geocal.CcorrLsmMatcher__ccorr_matcher(self)

    @property
    def ccorr_matcher(self):
        return self._ccorr_matcher()

    def _lsm_matcher(self):
        """
        boost::shared_ptr<LsmMatcher> GeoCal::CcorrLsmMatcher::lsm_matcher_ptr() const

        """
        return _geocal.CcorrLsmMatcher__lsm_matcher(self)

    @property
    def lsm_matcher(self):
        return self._lsm_matcher()

    def _accept_ccorr_only(self):
        """
        bool GeoCal::CcorrLsmMatcher::accept_ccorr_only() const
        True if we will accept a point where the least squares matcher fails
        but the cross correlation matcher succeeds.

        If allowed, a match like this will have a much larger line and sample
        sigma, but will be marked as successful.

        If this flag is false, then we require both matchers to be successful
        to match a point as successful. 
        """
        return _geocal.CcorrLsmMatcher__accept_ccorr_only(self)

    @property
    def accept_ccorr_only(self):
        return self._accept_ccorr_only()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.ccorr_matcher,self.lsm_matcher,self.accept_ccorr_only)

    __swig_destroy__ = _geocal.delete_CcorrLsmMatcher
CcorrLsmMatcher._ccorr_matcher = new_instancemethod(_geocal.CcorrLsmMatcher__ccorr_matcher,None,CcorrLsmMatcher)
CcorrLsmMatcher._lsm_matcher = new_instancemethod(_geocal.CcorrLsmMatcher__lsm_matcher,None,CcorrLsmMatcher)
CcorrLsmMatcher._accept_ccorr_only = new_instancemethod(_geocal.CcorrLsmMatcher__accept_ccorr_only,None,CcorrLsmMatcher)
CcorrLsmMatcher_swigregister = _geocal.CcorrLsmMatcher_swigregister
CcorrLsmMatcher_swigregister(CcorrLsmMatcher)

class RpcImage(RasterImageVariable):
    """
    This handles both an Rpc, and the RasterImage data the Rpc map
    projects.

    Some of the data we work with is high resolution (e.g., Quickbird at
    60 cm). For some purposes, we may want to work with a lower resolution
    version (e.g., image match with CIB data at 5 m). This class allows
    the resolution of the map projection to be given, in which case we
    will average the underlying RasterImage using RasterAveraged, before
    doing the map projection.

    We calculate imagery on demand. This means the imagery is always up to
    date, so changes to the Rpc get reflected in the imagery. However, if
    you are going to be accessing the same data more than once w/o
    updating the Rpc, you'll want to generate a static copy so you don't
    repeatedly calculate the same data over and over e.g., use a
    MemoryRasterImage to copy the data into memory.

    As you update the Rpc parameters, the area covered on the surface
    changes. This class does not update the MapInfo describing the area
    covered. However, you can call map_info_bounding_update() to update
    this information if desired.

    C++ includes: rpc_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        RpcImage::RpcImage(const boost::shared_ptr< RasterImage > &Raw_img, const Rpc &R, const
        boost::shared_ptr< Dem > &D, const MapInfo &Mi, int Avg_fact=-1)
        Constructor.

        We either average the raw data by the given factor, or we take the
        ratio of the Mi resolution and the Rpc resolution. 
        """
        _geocal.RpcImage_swiginit(self,_geocal.new_RpcImage(*args))
    def _dem(self):
        """
        boost::shared_ptr<Dem> GeoCal::RpcImage::dem_ptr() const

        """
        return _geocal.RpcImage__dem(self)

    @property
    def dem(self):
        return self._dem()

    def map_info_bounding(self):
        """
        MapInfo RpcImage::map_info_bounding() const
        Create a MapInfo that completely covers projection of the raw_image to
        the surface using the current Rpc values.

        This used the same CoordinateConverter, pixel_x_resolution, and
        pixel_y_resolution as the current map_info() - we just change the
        corners of the MapInfo to contain the data. Note that this just
        calculates the MapInfo, it doesn't actually set the map_info() to this
        new value. For that, use map_info_bounding_update. 
        """
        return _geocal.RpcImage_map_info_bounding(self)

    def map_info_bounding_update(self):
        """
        void RpcImage::map_info_bounding_update()
        This calls map_info_bounding(), and then sets the map_info() for this
        object to the results of that call. 
        """
        return _geocal.RpcImage_map_info_bounding_update(self)

    def _raw_image(self):
        """
        boost::shared_ptr<RasterImage> GeoCal::RpcImage::raw_image_ptr() const

        """
        return _geocal.RpcImage__raw_image(self)

    @property
    def raw_image(self):
        return self._raw_image()

    def read_ptr(self, *args):
        """
        void RpcImage::read_ptr(int Lstart, int Sstart, int Number_line, int Number_sample, int *Res)
        const
        Return a subset of the image. 
        """
        return _geocal.RpcImage_read_ptr(self, *args)

    def fit(self, *args):
        """
        void RpcImage::fit(const RasterImage &Ref_img, double Max_diff=1000, const Mask
        &M=CombinedMask(), const FeatureDetector
        &Fd=ForstnerFeatureDetector(), const ImageMatcher
        &Coarse_im=CcorrMatcher(), const ImageMatcher
        &Fine_im=CcorrLsmMatcher(true), double Match_search=15, int
        Feature_grid_space=100, double Blunder_threshold=3, double
        Chisq_threshold=1.0, bool Blunder_detect=true)
        This does image matching with a Ref_img, and adjusts the Rpc
        coefficients to give a better match between this map projected imagery
        and the reference imagery.

        This is done in two step. First we do a coarse fit to get the map
        projected roughly right, and then we do a finer adjustment to give a
        better fit.

        The first step is the coarse fit. Since an Rpc is usually based on
        navigation data only, without and ground control points, it can give
        relatively large errors. We do a coarse shift to the Rpc to reduce the
        errors enough that we can do a finer fit against the Ref_img.

        We first averages the image and the Ref_img. We average so that we are
        coarse enough that the given image matching search window size (given
        by Match_search) will contain errors up to Max_diff meters. For
        example, with a 1000 m Max_diff, a search window of Match_search, and
        5 m Ref_img, we would average by a factor of 14 (5 m x 14 factor x 15
        search window = 1050 m error, allowing us to find 1000 m differences).

        We use the FeatureDetector Fd to determine where to match, the areas
        we look for a feature is in each grid square of Feature_grid_space x
        Feature_grid_space. We then match at these features between the
        reference and map projected images. We use the supplied Mask to mask
        out areas that we should not do matching on (e.g., water, clouds). The
        default Mask doesn't mask any areas.

        We update the line_offset and sample_offset only of rpc() to reduce
        the difference between the map projected image and the Ref_img. This
        functions does not fit the other parameters given by
        rpc().fit_line_numerator and rpc().fit_sample_numerator.

        We repeat the coarse fit until the remaining differences between the
        map projected data and the Ref_img fall within Match_search at full
        resolution.

        We follow this with a fine fit. We again use the FeatureDetector Fd to
        determine where to match, the areas we look for a feature is in each
        grid square of Feature_grid_space x Feature_grid_space. We then match
        at these features between the reference and map projected images.

        We fit for the Rpc parameters given by rpc().fit_line_numerator and
        rpc().fit_sample_numerator.

        This fine matching step is repeated until the change in average
        difference from one step to the next is less than a tolerance (5%
        change). 
        """
        return _geocal.RpcImage_fit(self, *args)

    def reference_image_ground_point(self):
        """
        const std::vector<boost::shared_ptr<GroundCoordinate> >& GeoCal::RpcImage::reference_image_ground_point() const
        Return the location in the reference image used in the final iteration
        of fit, for diagnostic purposes.

        Note that you should also look at blunder, as some of these points
        might be marked as blunders. 
        """
        return _geocal.RpcImage_reference_image_ground_point(self)

    def new_image_ground_point(self):
        """
        const std::vector<boost::shared_ptr<GroundCoordinate> >& GeoCal::RpcImage::new_image_ground_point() const
        Return the location in the new image used in the final iteration of
        fit, for diagnostic purposes.

        Note that you should also look at blunder, as some of these points
        might be marked as blunders. 
        """
        return _geocal.RpcImage_new_image_ground_point(self)

    def distance_new_and_reference(self):
        """
        const std::vector<double>& GeoCal::RpcImage::distance_new_and_reference() const
        Return distance in meters between reference_image_ground_point and
        new_image_ground_point, for diagnostic purposes.

        This is a measure of how much the images disagree after the fitting
        done by fit(). Note that you should also look at blunder, as some of
        these points might be marked as blunders. 
        """
        return _geocal.RpcImage_distance_new_and_reference(self)

    def blunder(self):
        """
        const std::set<int> GeoCal::RpcImage::blunder() const
        Points in the last iteration of fit() that were marked as blunders. 
        """
        return _geocal.RpcImage_blunder(self)

    def failed_ground_point(self):
        """
        const std::vector<boost::shared_ptr<GroundCoordinate> >& GeoCal::RpcImage::failed_ground_point() const
        Return the location in the reference image used in the final iteration
        of fit, for diagnostic purposes.

        This point had image matching fail on it, see image_match_diagnostic
        for code as to why it failed. 
        """
        return _geocal.RpcImage_failed_ground_point(self)

    def image_match_diagnostic(self):
        """
        const std::vector<int>& GeoCal::RpcImage::image_match_diagnostic() const
        Return the code indicating why an image matching failed. 
        """
        return _geocal.RpcImage_image_match_diagnostic(self)

    __swig_destroy__ = _geocal.delete_RpcImage
RpcImage._dem = new_instancemethod(_geocal.RpcImage__dem,None,RpcImage)
RpcImage.map_info_bounding = new_instancemethod(_geocal.RpcImage_map_info_bounding,None,RpcImage)
RpcImage.map_info_bounding_update = new_instancemethod(_geocal.RpcImage_map_info_bounding_update,None,RpcImage)
RpcImage._raw_image = new_instancemethod(_geocal.RpcImage__raw_image,None,RpcImage)
RpcImage.__call__ = new_instancemethod(_geocal.RpcImage___call__,None,RpcImage)
RpcImage.read_ptr = new_instancemethod(_geocal.RpcImage_read_ptr,None,RpcImage)
RpcImage.fit = new_instancemethod(_geocal.RpcImage_fit,None,RpcImage)
RpcImage.reference_image_ground_point = new_instancemethod(_geocal.RpcImage_reference_image_ground_point,None,RpcImage)
RpcImage.new_image_ground_point = new_instancemethod(_geocal.RpcImage_new_image_ground_point,None,RpcImage)
RpcImage.distance_new_and_reference = new_instancemethod(_geocal.RpcImage_distance_new_and_reference,None,RpcImage)
RpcImage.blunder = new_instancemethod(_geocal.RpcImage_blunder,None,RpcImage)
RpcImage.failed_ground_point = new_instancemethod(_geocal.RpcImage_failed_ground_point,None,RpcImage)
RpcImage.image_match_diagnostic = new_instancemethod(_geocal.RpcImage_image_match_diagnostic,None,RpcImage)
RpcImage_swigregister = _geocal.RpcImage_swigregister
RpcImage_swigregister(RpcImage)

class RasterMultifile(RasterImageVariable):
    """
    There are certain larger data sets that are made up of a number of
    separate files all in the same map projection that cover a large area.

    For example, the SRTM data available through AFIDS. This class
    captures the common functionality needed to deal with those files. The
    data is stitched together by either reading one file or the other,
    there is no smoothing done by this class between neighboring files.

    Note that if you are creating a derived class, LocationToFile may be a
    useful class to use.

    In general, the area covered by this RasterMultifile will not be fully
    covered by the separate files (e.g., there are tiles missing in the
    SRTM). Depending on the application, trying to read data where we
    don't have a file will either be an error, or acceptable and we want
    to return a fill value instead. To handle this, derived classes return
    a RasterMultifileTile with data = 0. Then, depending on the value of
    No_coverage_is_error we either let the exception be thrown or we catch
    it and substitute a fill value for the attempted read.

    C++ includes: raster_multifile.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _geocal.delete_RasterMultifile
RasterMultifile_swigregister = _geocal.RasterMultifile_swigregister
RasterMultifile_swigregister(RasterMultifile)

class DidDatum(Datum):
    """
    This is a Datum used for the the DID.

    C++ includes: did_datum.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        DidDatum::DidDatum(const std::string &Fname)
        This creates a DidDatum.

        This takes the name of the mean sea level data, i.e.,
        /data/bank/anc/DID/MeanSeaLevel/current/geoid_2160h_4320w.half 
        """
        _geocal.DidDatum_swiginit(self,_geocal.new_DidDatum(*args))
    def _file_name(self):
        """
        const std::string& GeoCal::DidDatum::file_name() const

        """
        return _geocal.DidDatum__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name)

    __swig_destroy__ = _geocal.delete_DidDatum
DidDatum._file_name = new_instancemethod(_geocal.DidDatum__file_name,None,DidDatum)
DidDatum_swigregister = _geocal.DidDatum_swigregister
DidDatum_swigregister(DidDatum)

class MapInfoImageGroundConnection(ImageGroundConnection):
    """
    This class creates an ImageGroundConnection that simply maps map
    registered image to the ground.

    C++ includes: map_info_image_ground_connection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::MapInfoImageGroundConnection::MapInfoImageGroundConnection(const boost::shared_ptr< RasterImage > &Img, const boost::shared_ptr<
        Dem > &D, const std::string &Title="Image")
        Constructor. 
        """
        _geocal.MapInfoImageGroundConnection_swiginit(self,_geocal.new_MapInfoImageGroundConnection(*args))
    def __reduce__(self):
      return _new_from_init, (self.__class__, self.image,self.dem,self.title)

    __swig_destroy__ = _geocal.delete_MapInfoImageGroundConnection
MapInfoImageGroundConnection_swigregister = _geocal.MapInfoImageGroundConnection_swigregister
MapInfoImageGroundConnection_swigregister(MapInfoImageGroundConnection)

class MaskImage(Mask):
    """
    This provides a Mask where the underlying data is a RasterImage.

    We use the underlying map projection of the RasterImage we defining a
    region.

    For any point, we look at the four neighboring pixels. If any of the
    pixels are the mask_value, we say the point is masked, otherwise it is
    not masked. If we are outside of the RasterImage, then we say it is no
    masked.

    An example of this kind of Mask is the Land/Water mask used by Vicar
    ("world_30as_lwm.img")

    C++ includes: mask_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::MaskImage::MaskImage(boost::shared_ptr< RasterImage > Img, int Mask_value=0)
        Constructor. 
        """
        _geocal.MaskImage_swiginit(self,_geocal.new_MaskImage(*args))
    def _raster_image(self):
        """
        const boost::shared_ptr<RasterImage>& GeoCal::MaskImage::raster_image_ptr() const
        Underlying RasterImage. 
        """
        return _geocal.MaskImage__raster_image(self)

    @property
    def raster_image(self):
        return self._raster_image()

    def _masked_value(self):
        """
        int GeoCal::MaskImage::masked_value() const
        Value indicating masked data. 
        """
        return _geocal.MaskImage__masked_value(self)

    @property
    def masked_value(self):
        return self._masked_value()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.raster_image,self.masked_value)

    __swig_destroy__ = _geocal.delete_MaskImage
MaskImage._raster_image = new_instancemethod(_geocal.MaskImage__raster_image,None,MaskImage)
MaskImage._masked_value = new_instancemethod(_geocal.MaskImage__masked_value,None,MaskImage)
MaskImage_swigregister = _geocal.MaskImage_swigregister
MaskImage_swigregister(MaskImage)

class RasterAveraged(RasterImage):
    """
    This averages a higher resolution RasterImage into a lower resolution
    one.

    The data is a straight average of a given number of pixels in the line
    and sample direction of the full resolution data.

    Typically the pixel averaging factor doesn't exactly divide the number
    of lines and samples of the full resolution data. We just trim the
    data to the largest low resolution pixel that completely fits in the
    higher resolution data.

    This class calculates the average on the fly. Sometimes this is what
    you want, but if you are going to be using the resulting data a few
    times, you may want to use a MemoryRasterImage to generate a copy once
    and keep it in memory.

    C++ includes: raster_averaged.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        RasterAveraged::RasterAveraged(const boost::shared_ptr< RasterImage > &Data, int
        Number_line_per_pixel, int Number_sample_per_pixel, bool
        Ignore_zero=false)
        Constructor. 
        """
        _geocal.RasterAveraged_swiginit(self,_geocal.new_RasterAveraged(*args))
    def _high_resolution_image(self):
        """
        const boost::shared_ptr<RasterImage>& GeoCal::RasterAveraged::high_resolution_image_ptr() const
        Pointer to high resolution image that this object is based on. 
        """
        return _geocal.RasterAveraged__high_resolution_image(self)

    @property
    def high_resolution_image(self):
        return self._high_resolution_image()

    def _number_line_per_pixel(self):
        """
        int GeoCal::RasterAveraged::number_line_per_pixel() const
        Number of lines of high resolution data per pixel of this lower
        resolution RasterImage. 
        """
        return _geocal.RasterAveraged__number_line_per_pixel(self)

    @property
    def number_line_per_pixel(self):
        return self._number_line_per_pixel()

    def _number_sample_per_pixel(self):
        """
        int GeoCal::RasterAveraged::number_sample_per_pixel() const
        Number of samples of high resolution data per pixel of this lower
        resolution RasterImage. 
        """
        return _geocal.RasterAveraged__number_sample_per_pixel(self)

    @property
    def number_sample_per_pixel(self):
        return self._number_sample_per_pixel()

    def _ignore_zero(self):
        """
        bool GeoCal::RasterAveraged::ignore_zero() const
        If true, we ignore zeros when calculating the average. 
        """
        return _geocal.RasterAveraged__ignore_zero(self)

    @property
    def ignore_zero(self):
        return self._ignore_zero()

    def read_ptr(self, *args):
        """
        void RasterAveraged::read_ptr(int Lstart, int Sstart, int Number_line, int Number_sample, int *Res)
        const
        Return a subset of the image. 
        """
        return _geocal.RasterAveraged_read_ptr(self, *args)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.high_resolution_image,self.number_line_per_pixel,self.number_sample_per_pixel,self.ignore_zero)

    __swig_destroy__ = _geocal.delete_RasterAveraged
RasterAveraged._high_resolution_image = new_instancemethod(_geocal.RasterAveraged__high_resolution_image,None,RasterAveraged)
RasterAveraged._number_line_per_pixel = new_instancemethod(_geocal.RasterAveraged__number_line_per_pixel,None,RasterAveraged)
RasterAveraged._number_sample_per_pixel = new_instancemethod(_geocal.RasterAveraged__number_sample_per_pixel,None,RasterAveraged)
RasterAveraged._ignore_zero = new_instancemethod(_geocal.RasterAveraged__ignore_zero,None,RasterAveraged)
RasterAveraged.__call__ = new_instancemethod(_geocal.RasterAveraged___call__,None,RasterAveraged)
RasterAveraged.read_ptr = new_instancemethod(_geocal.RasterAveraged_read_ptr,None,RasterAveraged)
RasterAveraged_swigregister = _geocal.RasterAveraged_swigregister
RasterAveraged_swigregister(RasterAveraged)

class RasterSubSample(RasterImageVariable):
    """
    This subsamples a higher resolution RasterImage into a lower
    resolution one.

    Typically the pixel subsampling factor doesn't exactly divide the
    number of lines and samples of the full resolution data. We just trim
    the data to the largest low resolution pixel that completely fits in
    the higher resolution data.

    C++ includes: raster_subsample.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        RasterSubSample::RasterSubSample(const boost::shared_ptr< RasterImage > &Data, int
        Number_line_per_pixel, int Number_sample_per_pixel)
        Constructor. 
        """
        _geocal.RasterSubSample_swiginit(self,_geocal.new_RasterSubSample(*args))
    def _high_resolution_image(self):
        """
        const boost::shared_ptr<RasterImage>& GeoCal::RasterSubSample::high_resolution_image_ptr() const
        Pointer to high resolution image that this object is based on. 
        """
        return _geocal.RasterSubSample__high_resolution_image(self)

    @property
    def high_resolution_image(self):
        return self._high_resolution_image()

    def _number_line_per_pixel(self):
        """
        int GeoCal::RasterSubSample::number_line_per_pixel() const
        Number of lines of high resolution data per pixel of this lower
        resolution RasterImage. 
        """
        return _geocal.RasterSubSample__number_line_per_pixel(self)

    @property
    def number_line_per_pixel(self):
        return self._number_line_per_pixel()

    def _number_sample_per_pixel(self):
        """
        int GeoCal::RasterSubSample::number_sample_per_pixel() const
        Number of samples of high resolution data per pixel of this lower
        resolution RasterImage. 
        """
        return _geocal.RasterSubSample__number_sample_per_pixel(self)

    @property
    def number_sample_per_pixel(self):
        return self._number_sample_per_pixel()

    def read_ptr(self, *args):
        """
        void RasterSubSample::read_ptr(int Lstart, int Sstart, int Number_line, int Number_sample, int *Res)
        const
        Return a subset of the image. 
        """
        return _geocal.RasterSubSample_read_ptr(self, *args)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.high_resolution_image,self.number_line_per_pixel,self.number_sample_per_pixel)

    __swig_destroy__ = _geocal.delete_RasterSubSample
RasterSubSample._high_resolution_image = new_instancemethod(_geocal.RasterSubSample__high_resolution_image,None,RasterSubSample)
RasterSubSample._number_line_per_pixel = new_instancemethod(_geocal.RasterSubSample__number_line_per_pixel,None,RasterSubSample)
RasterSubSample._number_sample_per_pixel = new_instancemethod(_geocal.RasterSubSample__number_sample_per_pixel,None,RasterSubSample)
RasterSubSample.__call__ = new_instancemethod(_geocal.RasterSubSample___call__,None,RasterSubSample)
RasterSubSample.read_ptr = new_instancemethod(_geocal.RasterSubSample_read_ptr,None,RasterSubSample)
RasterSubSample_swigregister = _geocal.RasterSubSample_swigregister
RasterSubSample_swigregister(RasterSubSample)

class CalcRaster(RasterImageVariable):
    """
    Some classes most naturally generate a RasterImage by calculating a
    results for an array of data (e.g., a tile).

    This class handles the common behavior for these classes.

    C++ includes: calc_raster.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def read_double(self, *args):
        """
        blitz::Array< double, 2 > CalcRaster::read_double(int Lstart, int Sstart, int Number_line, int Number_sample) const
        Calculate the results as a blitz::Array of doubles. 
        """
        return _geocal.CalcRaster_read_double(self, *args)

    __swig_destroy__ = _geocal.delete_CalcRaster
CalcRaster.read_double = new_instancemethod(_geocal.CalcRaster_read_double,None,CalcRaster)
CalcRaster_swigregister = _geocal.CalcRaster_swigregister
CalcRaster_swigregister(CalcRaster)

class CalcRasterMultiBand(RasterImageMultiBandVariable):
    """
    Some classes most naturally generate a RasterImageMultiBand by
    calculating a results for an array of data (e.g., a tile).

    This class handles the common behavior for these classes.

    This is very similar to RasterImageMultiBand made upf of CalcRaster,
    the difference is that for this class it makes sense to calculate all
    the bands at once.

    C++ includes: calc_raster_multi_band.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def read_double(self, *args):
        """
        Array< double, 3 > CalcRasterMultiBand::read_double(int Lstart, int Sstart, int Nline, int Nsamp) const
        Read the data from the same location in each image, and put into an
        array.

        This will be number_band x number_line x number_sample. 
        """
        return _geocal.CalcRasterMultiBand_read_double(self, *args)

    __swig_destroy__ = _geocal.delete_CalcRasterMultiBand
CalcRasterMultiBand.read_double = new_instancemethod(_geocal.CalcRasterMultiBand_read_double,None,CalcRasterMultiBand)
CalcRasterMultiBand_swigregister = _geocal.CalcRasterMultiBand_swigregister
CalcRasterMultiBand_swigregister(CalcRasterMultiBand)

class MagnifyBilinear(CalcRaster):
    """
    This creates a magnified image of a RasterImage.

    We do a bilinear interpolation to get the values

    C++ includes: magnify_bilinear.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        MagnifyBilinear::MagnifyBilinear(const boost::shared_ptr< RasterImage > &Data, int Magfactor, int
        Number_tile=4)
        Constructor. 
        """
        _geocal.MagnifyBilinear_swiginit(self,_geocal.new_MagnifyBilinear(*args))
    __swig_destroy__ = _geocal.delete_MagnifyBilinear
MagnifyBilinear_swigregister = _geocal.MagnifyBilinear_swigregister
MagnifyBilinear_swigregister(MagnifyBilinear)

class MagnifyBilinearImageGroundConnection(ImageGroundConnection):
    """
    This create an ImageGroundConnection that is magnified the same way
    MagnifyBilinear does.

    C++ includes: magnify_bilinear.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::MagnifyBilinearImageGroundConnection::MagnifyBilinearImageGroundConnection(const boost::shared_ptr< ImageGroundConnection > &Ig_original, int
        Magfactor)
        Constructor. 
        """
        _geocal.MagnifyBilinearImageGroundConnection_swiginit(self,_geocal.new_MagnifyBilinearImageGroundConnection(*args))
    def _original_image_ground_connection(self):
        """
        boost::shared_ptr<ImageGroundConnection> GeoCal::MagnifyBilinearImageGroundConnection::original_image_ground_connection() const
        Underlying ImageGroundConnection. 
        """
        return _geocal.MagnifyBilinearImageGroundConnection__original_image_ground_connection(self)

    @property
    def original_image_ground_connection(self):
        return self._original_image_ground_connection()

    def _magnification_factor(self):
        """
        int GeoCal::MagnifyBilinearImageGroundConnection::magnification_factor() const
        Return magnification factor. 
        """
        return _geocal.MagnifyBilinearImageGroundConnection__magnification_factor(self)

    @property
    def magnification_factor(self):
        return self._magnification_factor()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.original_image_ground_connection,self.magnification_factor)

    __swig_destroy__ = _geocal.delete_MagnifyBilinearImageGroundConnection
MagnifyBilinearImageGroundConnection._original_image_ground_connection = new_instancemethod(_geocal.MagnifyBilinearImageGroundConnection__original_image_ground_connection,None,MagnifyBilinearImageGroundConnection)
MagnifyBilinearImageGroundConnection._magnification_factor = new_instancemethod(_geocal.MagnifyBilinearImageGroundConnection__magnification_factor,None,MagnifyBilinearImageGroundConnection)
MagnifyBilinearImageGroundConnection_swigregister = _geocal.MagnifyBilinearImageGroundConnection_swigregister
MagnifyBilinearImageGroundConnection_swigregister(MagnifyBilinearImageGroundConnection)

class MagnifyReplicate(CalcRaster):
    """
    This creates a magnified image of a RasterImage.

    We do replicatione to get the values.

    C++ includes: magnify_replicate.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        MagnifyReplicate::MagnifyReplicate(const boost::shared_ptr< RasterImage > &Data, int Magfactor, int
        Number_tile=4)
        Constructor. 
        """
        _geocal.MagnifyReplicate_swiginit(self,_geocal.new_MagnifyReplicate(*args))
    def _raw_data(self):
        """
        const boost::shared_ptr<RasterImage>& GeoCal::MagnifyReplicate::raw_data_ptr() const

        """
        return _geocal.MagnifyReplicate__raw_data(self)

    @property
    def raw_data(self):
        return self._raw_data()

    def _magfactor(self):
        """
        int GeoCal::MagnifyReplicate::magfactor() const

        """
        return _geocal.MagnifyReplicate__magfactor(self)

    @property
    def magfactor(self):
        return self._magfactor()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.raw_data,self.magfactor,self.number_tile)

    __swig_destroy__ = _geocal.delete_MagnifyReplicate
MagnifyReplicate._raw_data = new_instancemethod(_geocal.MagnifyReplicate__raw_data,None,MagnifyReplicate)
MagnifyReplicate._magfactor = new_instancemethod(_geocal.MagnifyReplicate__magfactor,None,MagnifyReplicate)
MagnifyReplicate_swigregister = _geocal.MagnifyReplicate_swigregister
MagnifyReplicate_swigregister(MagnifyReplicate)

class SmoothImage(CalcRaster):
    """
    This creates a smoothed version of a RasterImage.

    We do this by averaging a given region of the image, average (2 * nhs
    + 1) x (2 * nhs + 1) pixels centered on the resulting pixel.

    Rather than doing something complicated at the edges, we simply trim
    the underlying image by a border of nhs.

    C++ includes: smooth_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        SmoothImage::SmoothImage(const boost::shared_ptr< RasterImage > &Data, int Nhs=3, int
        Number_tile=4)
        Constructor.

        We give the size of the area to average over by supplying the number
        half size (Nhs), and then average over a region (2 * Nhs + 1) x (2 *
        Nhs + 1) 
        """
        _geocal.SmoothImage_swiginit(self,_geocal.new_SmoothImage(*args))
    def _raw_data(self):
        """
        const boost::shared_ptr<RasterImage>& GeoCal::SmoothImage::raw_data_ptr() const

        """
        return _geocal.SmoothImage__raw_data(self)

    @property
    def raw_data(self):
        return self._raw_data()

    def _number_half_size(self):
        """
        int GeoCal::SmoothImage::number_half_size() const

        """
        return _geocal.SmoothImage__number_half_size(self)

    @property
    def number_half_size(self):
        return self._number_half_size()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.raw_data,self.number_half_size,self.number_tile)

    __swig_destroy__ = _geocal.delete_SmoothImage
SmoothImage._raw_data = new_instancemethod(_geocal.SmoothImage__raw_data,None,SmoothImage)
SmoothImage._number_half_size = new_instancemethod(_geocal.SmoothImage__number_half_size,None,SmoothImage)
SmoothImage_swigregister = _geocal.SmoothImage_swigregister
SmoothImage_swigregister(SmoothImage)

class RasterImageTiledFile(RasterImageVariable):
    """
    This is a RasterImage that is implemented as a TiledFile<T, 2>.

    C++ includes: raster_image_tiled_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::RasterImageTiledFile::RasterImageTiledFile(const boost::shared_ptr< TiledFileBase< 2 > > &D, const MapInfo &M)

        """
        _geocal.RasterImageTiledFile_swiginit(self,_geocal.new_RasterImageTiledFile(*args))
    def _tile_file_base(self):
        """
        const boost::shared_ptr<TiledFileBase<2> >& GeoCal::RasterImageTiledFile::tile_file_base_ptr() const
        Underlying data. 
        """
        return _geocal.RasterImageTiledFile__tile_file_base(self)

    @property
    def tile_file_base(self):
        return self._tile_file_base()

    def flush(self):
        """
        virtual void GeoCal::RasterImageTiledFile::flush() const
        Flush data to disk. 
        """
        return _geocal.RasterImageTiledFile_flush(self)

    def _number_swap(self):
        """
        unsigned int GeoCal::RasterImageTiledFile::number_swap() const
        Number of times we have swapped a tile since reset_number_swap called.

        """
        return _geocal.RasterImageTiledFile__number_swap(self)

    @property
    def number_swap(self):
        return self._number_swap()

    def _number_tile(self):
        """
        int GeoCal::RasterImageTiledFile::number_tile() const
        Number of tiles. 
        """
        return _geocal.RasterImageTiledFile__number_tile(self)

    @property
    def number_tile(self):
        return self._number_tile()

    def reset_number_swap(self):
        """
        void GeoCal::RasterImageTiledFile::reset_number_swap()
        Reset number of swap counter to 0. 
        """
        return _geocal.RasterImageTiledFile_reset_number_swap(self)

    __swig_destroy__ = _geocal.delete_RasterImageTiledFile
RasterImageTiledFile._tile_file_base = new_instancemethod(_geocal.RasterImageTiledFile__tile_file_base,None,RasterImageTiledFile)
RasterImageTiledFile.flush = new_instancemethod(_geocal.RasterImageTiledFile_flush,None,RasterImageTiledFile)
RasterImageTiledFile._number_swap = new_instancemethod(_geocal.RasterImageTiledFile__number_swap,None,RasterImageTiledFile)
RasterImageTiledFile._number_tile = new_instancemethod(_geocal.RasterImageTiledFile__number_tile,None,RasterImageTiledFile)
RasterImageTiledFile.reset_number_swap = new_instancemethod(_geocal.RasterImageTiledFile_reset_number_swap,None,RasterImageTiledFile)
RasterImageTiledFile_swigregister = _geocal.RasterImageTiledFile_swigregister
RasterImageTiledFile_swigregister(RasterImageTiledFile)

class DemTiledFile(DemMapInfo):
    """
    This is a DemMapInfo that is implemented as a TiledFile<T, 2>

    C++ includes: dem_tiled_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def _number_tile(self):
        """
        unsigned int GeoCal::DemTiledFile::number_tile() const

        """
        return _geocal.DemTiledFile__number_tile(self)

    @property
    def number_tile(self):
        return self._number_tile()

    def _number_line_per_tile(self):
        """
        int GeoCal::DemTiledFile::number_line_per_tile() const

        """
        return _geocal.DemTiledFile__number_line_per_tile(self)

    @property
    def number_line_per_tile(self):
        return self._number_line_per_tile()

    def _number_sample_per_tile(self):
        """
        int GeoCal::DemTiledFile::number_sample_per_tile() const

        """
        return _geocal.DemTiledFile__number_sample_per_tile(self)

    @property
    def number_sample_per_tile(self):
        return self._number_sample_per_tile()

    def _number_swap(self):
        """
        int GeoCal::DemTiledFile::number_swap() const

        """
        return _geocal.DemTiledFile__number_swap(self)

    @property
    def number_swap(self):
        return self._number_swap()

    def reset_number_swap(self):
        """
        void GeoCal::DemTiledFile::reset_number_swap()

        """
        return _geocal.DemTiledFile_reset_number_swap(self)

    __swig_destroy__ = _geocal.delete_DemTiledFile
DemTiledFile._number_tile = new_instancemethod(_geocal.DemTiledFile__number_tile,None,DemTiledFile)
DemTiledFile._number_line_per_tile = new_instancemethod(_geocal.DemTiledFile__number_line_per_tile,None,DemTiledFile)
DemTiledFile._number_sample_per_tile = new_instancemethod(_geocal.DemTiledFile__number_sample_per_tile,None,DemTiledFile)
DemTiledFile._number_swap = new_instancemethod(_geocal.DemTiledFile__number_swap,None,DemTiledFile)
DemTiledFile.reset_number_swap = new_instancemethod(_geocal.DemTiledFile_reset_number_swap,None,DemTiledFile)
DemTiledFile_swigregister = _geocal.DemTiledFile_swigregister
DemTiledFile_swigregister(DemTiledFile)

class MemoryDem(DemMapInfo):
    """
    This is a DemMapInfo that has everything stored in memory.

    This Dem can be updated, and we can also supply the jacobian with
    respect to the Dem height values.

    C++ includes: memory_dem.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::MemoryDem::MemoryDem(const boost::shared_ptr< Datum > &D, const MapInfo &M, bool
        Outside_dem_is_error=false)
        Constructor. 
        """
        _geocal.MemoryDem_swiginit(self,_geocal.new_MemoryDem(*args))
    def elevation(self, *args):
        """
        virtual double GeoCal::MemoryDem::elevation(int Y_index, int X_index) const
        Return height in meters relative to datum().

        Note that the call is in line, sample order, which means Y and then X.

        """
        return _geocal.MemoryDem_elevation(self, *args)

    elevation_data = _swig_property(_geocal.MemoryDem_elevation_data_get, _geocal.MemoryDem_elevation_data_set)
    __swig_destroy__ = _geocal.delete_MemoryDem
MemoryDem.elevation = new_instancemethod(_geocal.MemoryDem_elevation,None,MemoryDem)
MemoryDem_swigregister = _geocal.MemoryDem_swigregister
MemoryDem_swigregister(MemoryDem)

class MapReprojectedImage(RasterImageVariable):
    """
    This is a RasterImage that has been resampled to a different map
    projection and/or a different resolution.

    To do this we do two steps:

    We calculate roughly what the difference in resolution is between the
    original and final MapInfo. We do this by looking at the center pixel
    of the original data and the pixel +1 in line and sample. We then use
    RasterAveraged to average the original data to roughly the resolution
    of the final MapInfo. If the final MapInfo is near the same resolution
    as the original, or if it has a higher resolution, then we don't do
    any averaging.

    We then interpolate the possibly averaged data to the final
    projection.

    It is ok if the final MapInfo contains areas outside of the original
    data. For any pixel outside of the original data, we just return a
    value of 0.

    This class calculates the reprojected data on the fly. Sometimes this
    is what you want, but if you are going to be using the resulting data
    a few times, you may want to use a MemoryRasterImage to generate a
    copy once and keep it in memory.

    C++ includes: map_reprojected_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        MapReprojectedImage::MapReprojectedImage(const boost::shared_ptr< RasterImage > Img_in, const MapInfo &Mi)
        Constructor.

        We resample Img_in to the projection and resolution given by MapInfo.

        """
        _geocal.MapReprojectedImage_swiginit(self,_geocal.new_MapReprojectedImage(*args))
    def _raw_image(self):
        """
        boost::shared_ptr<RasterImage> GeoCal::MapReprojectedImage::raw_image_ptr() const

        """
        return _geocal.MapReprojectedImage__raw_image(self)

    @property
    def raw_image(self):
        return self._raw_image()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.raw_image,self.map_info)

    __swig_destroy__ = _geocal.delete_MapReprojectedImage
MapReprojectedImage._raw_image = new_instancemethod(_geocal.MapReprojectedImage__raw_image,None,MapReprojectedImage)
MapReprojectedImage_swigregister = _geocal.MapReprojectedImage_swigregister
MapReprojectedImage_swigregister(MapReprojectedImage)

class CalcMapProjected(RasterImageVariable):
    """
    This is a RasterImage that has been map projected by a ground to image
    calculation.

    There are several obvious variations of this - calculate by OrbitData
    (e.g., Argus), by an Ipi (e.g., Quickbird), by an RPC. This base class
    capture the common behavior.

    To do this we do two steps:

    We calculate roughly what the difference in resolution is between the
    original data and final MapInfo. We do this by looking at the center
    pixel of the original data and the pixel +1 in line and sample. We
    then use RasterAveraged to average the original data to roughly the
    resolution of the final MapInfo. If the final MapInfo is near the same
    resolution as the original, or if it has a higher resolution, then we
    don't do any averaging. Alternatively, you can pass in the averaging
    factor.

    We then interpolate the possibly averaged data to the final
    projection.

    It is ok if the final MapInfo contains areas outside of the original
    data. For any pixel outside of the original data, we just return a
    value of 0.

    This class calculates the data on the fly. Sometimes this is what you
    want, but if you are going to be using the resulting data a few times,
    you may want to use a MemoryRasterImage to generate a copy once and
    keep it in memory.

    C++ includes: calc_map_projected.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def write_image(self, *args):
        """
        void CalcMapProjected::write_image(RasterImage &Out, int Grid_spacing=1) const
        input exactly at this grid spacing, and interpolate in between.

        This is much faster than calculating ever point, and if the grid
        spacing is small compared to the Dem and any nonlinearities give
        results very close to the full calculation. 
        """
        return _geocal.CalcMapProjected_write_image(self, *args)

    def write_multiple(self, *args):
        """
        void CalcMapProjected::write_multiple(const std::vector< boost::shared_ptr< RasterImage > > &Out, int
        Grid_spacing) const
        Write output to multiple RasterImage at once.

        This variation takes a grid spacing to use. We calculate the image
        coordinates in the input exactly at this grid spacing, and interpolate
        in between. This is much faster than calculating ever point, and if
        the grid spacing is small compared to the Dem and any Camera
        nonlinearities give results very close to the full calculation. 
        """
        return _geocal.CalcMapProjected_write_multiple(self, *args)

    __swig_destroy__ = _geocal.delete_CalcMapProjected
CalcMapProjected.write_image = new_instancemethod(_geocal.CalcMapProjected_write_image,None,CalcMapProjected)
CalcMapProjected.write_multiple = new_instancemethod(_geocal.CalcMapProjected_write_multiple,None,CalcMapProjected)
CalcMapProjected_swigregister = _geocal.CalcMapProjected_swigregister
CalcMapProjected_swigregister(CalcMapProjected)

class OrbitMapProjected(CalcMapProjected):
    """
    Note that this class is deprecated, it is redundant with
    IgcMapProjected just passing in a OrbitDataGroundConnection.

    But leave this is place now until we are ready to remove this.

    This is a RasterImage that has been map projected using OrbitData and
    a Camera.

    To do this we do two steps:

    We calculate roughly what the difference in resolution is between the
    original data and final MapInfo. We do this by looking at the center
    pixel of the original data and the pixel +1 in line and sample. We
    then use RasterAveraged to average the original data to roughly the
    resolution of the final MapInfo. If the final MapInfo is near the same
    resolution as the original, or if it has a higher resolution, then we
    don't do any averaging. Alternatively, you can pass in the averaging
    factor.

    We then interpolate the possibly averaged data to the final
    projection.

    It is ok if the final MapInfo contains areas outside of the original
    data. For any pixel outside of the original data, we just return a
    value of 0.

    This class calculates the data on the fly. Sometimes this is what you
    want, but if you are going to be using the resulting data a few times,
    you may want to use a MemoryRasterImage to generate a copy once and
    keep it in memory.

    C++ includes: orbit_map_projected.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        OrbitMapProjected::OrbitMapProjected(const MapInfo &Mi, const boost::shared_ptr< OrbitData > &Od, const
        std::vector< boost::shared_ptr< RasterImage > > &R, const
        boost::shared_ptr< Camera > &C, const boost::shared_ptr< Dem > &D, int
        Band=0, int Avg_fact=-1, bool Read_into_memory=true)
        Constructor.

        We average the data either by the factor given as Avg_fact, or by
        ratio of the Mapinfo resolution and the camera resolution.

        This is a variation that handles multiple bands at one time, you give
        it the set of raster image to process. 
        """
        _geocal.OrbitMapProjected_swiginit(self,_geocal.new_OrbitMapProjected(*args))
    __swig_destroy__ = _geocal.delete_OrbitMapProjected
OrbitMapProjected_swigregister = _geocal.OrbitMapProjected_swigregister
OrbitMapProjected_swigregister(OrbitMapProjected)

class IgcMapProjected(CalcMapProjected):
    """
    This is a RasterImage that has been map projected using an
    ImageGroundConnection and a Camera.

    To do this we do two steps:

    We calculate roughly what the difference in resolution is between the
    original data and final MapInfo. We do this by looking at the center
    pixel of the original data and the pixel +1 in line and sample. We
    then use RasterAveraged to average the original data to roughly the
    resolution of the final MapInfo. If the final MapInfo is near the same
    resolution as the original, or if it has a higher resolution, then we
    don't do any averaging. Alternatively, you can pass in the averaging
    factor (include a value of 1 which turns this behavior off).

    We then interpolate the possibly averaged data to the final
    projection.

    It is ok if the final MapInfo contains areas outside of the original
    data. For any pixel outside of the original data, we just return a
    value of 0.

    This class calculates the data on the fly. Sometimes this is what you
    want, but if you are going to be using the resulting data a few times,
    you may want to use a MemoryRasterImage to generate a copy once and
    keep it in memory.

    C++ includes: igc_map_projected.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        IgcMapProjected::IgcMapProjected(const MapInfo &Mi, const boost::shared_ptr< ImageGroundConnection >
        &Igc, int Avg_fact=-1, bool Read_into_memory=true)
        Constructor.

        We average the data either by the factor given as Avg_fact, or by
        ratio of the Mapinfo resolution and the camera resolution.

        This uses the Igc.image(). 
        """
        _geocal.IgcMapProjected_swiginit(self,_geocal.new_IgcMapProjected(*args))
    __swig_destroy__ = _geocal.delete_IgcMapProjected
IgcMapProjected_swigregister = _geocal.IgcMapProjected_swigregister
IgcMapProjected_swigregister(IgcMapProjected)

class IgcImageToImageMatch(ImageToImageMatch):
    """
    ImageToImageMatch where the images and prediction comes from
    ImageGroundConnection objects.

    C++ includes: igc_image_to_image_match.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::IgcImageToImageMatch::IgcImageToImageMatch(const boost::shared_ptr< ImageGroundConnection > &Igc1, const
        boost::shared_ptr< ImageGroundConnection > &Igc2, const
        boost::shared_ptr< ImageMatcher > &Matcher)

        """
        _geocal.IgcImageToImageMatch_swiginit(self,_geocal.new_IgcImageToImageMatch(*args))
    def _image_ground_connection1(self):
        """
        const boost::shared_ptr<ImageGroundConnection>& GeoCal::IgcImageToImageMatch::image_ground_connection1() const
        ImageGroundConnection for image 1. 
        """
        return _geocal.IgcImageToImageMatch__image_ground_connection1(self)

    @property
    def image_ground_connection1(self):
        return self._image_ground_connection1()

    def _image_ground_connection2(self):
        """
        const boost::shared_ptr<ImageGroundConnection>& GeoCal::IgcImageToImageMatch::image_ground_connection2() const
        ImageGroundConnection for image 2. 
        """
        return _geocal.IgcImageToImageMatch__image_ground_connection2(self)

    @property
    def image_ground_connection2(self):
        return self._image_ground_connection2()

    def _matcher(self):
        """
        const boost::shared_ptr<ImageMatcher>& GeoCal::IgcImageToImageMatch::matcher() const
        Matcher we are using. 
        """
        return _geocal.IgcImageToImageMatch__matcher(self)

    @property
    def matcher(self):
        return self._matcher()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.image_ground_connection1,self.image_ground_connection2,self.matcher)

    __swig_destroy__ = _geocal.delete_IgcImageToImageMatch
IgcImageToImageMatch._image_ground_connection1 = new_instancemethod(_geocal.IgcImageToImageMatch__image_ground_connection1,None,IgcImageToImageMatch)
IgcImageToImageMatch._image_ground_connection2 = new_instancemethod(_geocal.IgcImageToImageMatch__image_ground_connection2,None,IgcImageToImageMatch)
IgcImageToImageMatch._matcher = new_instancemethod(_geocal.IgcImageToImageMatch__matcher,None,IgcImageToImageMatch)
IgcImageToImageMatch_swigregister = _geocal.IgcImageToImageMatch_swigregister
IgcImageToImageMatch_swigregister(IgcImageToImageMatch)

class SurfaceImageToImageMatch(ImageToImageMatch):
    """
    This is an ImageToImageMatch that takes two image ground connections
    along with a MapInfo to project to.

    The data is matched at the surface, although the results are reported
    in image coordinates.

    The MapInfo is used to get the resolution and map projection, the
    actual coverage isn't important (e.g., the ulc and lrc). We make sure
    that the coverage works over the full image.

    Depending on your application, we can do the map projection only where
    we need an image patch for matching, or you can supply the full
    surface image.

    If you are collecting tiepoints over a large image, you usually want
    to do the map projection on the fly as needed, since we typically only
    map project a small part of the image.

    In some cases, you may be doing lots of points or simply already have
    the data map projected. In those cases, you can pass the RasterImage
    in. These should be map projected, with a MapInfo (e.g., geotiff label
    or whatever in the data).

    C++ includes: surface_image_to_image_match.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        SurfaceImageToImageMatch::SurfaceImageToImageMatch(const boost::shared_ptr< ImageGroundConnection > &Igc1, const
        boost::shared_ptr< RasterImage > &Surface_image1, const
        boost::shared_ptr< ImageGroundConnection > &Igc2, const
        boost::shared_ptr< RasterImage > &Surface_image2, const
        boost::shared_ptr< ImageMatcher > &Matcher)
        Constructor, where we supply the already map projected data. 
        """
        _geocal.SurfaceImageToImageMatch_swiginit(self,_geocal.new_SurfaceImageToImageMatch(*args))
    def _image_ground_connection1(self):
        """
        const boost::shared_ptr<ImageGroundConnection>& GeoCal::SurfaceImageToImageMatch::image_ground_connection1() const
        ImageGroundConnection for image 1. 
        """
        return _geocal.SurfaceImageToImageMatch__image_ground_connection1(self)

    @property
    def image_ground_connection1(self):
        return self._image_ground_connection1()

    def _image_ground_connection2(self):
        """
        const boost::shared_ptr<ImageGroundConnection>& GeoCal::SurfaceImageToImageMatch::image_ground_connection2() const
        ImageGroundConnection for image 2. 
        """
        return _geocal.SurfaceImageToImageMatch__image_ground_connection2(self)

    @property
    def image_ground_connection2(self):
        return self._image_ground_connection2()

    def _matcher(self):
        """
        const boost::shared_ptr<ImageMatcher>& GeoCal::SurfaceImageToImageMatch::matcher() const
        Matcher we are using. 
        """
        return _geocal.SurfaceImageToImageMatch__matcher(self)

    @property
    def matcher(self):
        return self._matcher()

    def _map_project_on_demand(self):
        """
        bool GeoCal::SurfaceImageToImageMatch::map_project_on_demand() const
        Indicate if we are doing the map projection on demand, or if we
        already have the data map projected. 
        """
        return _geocal.SurfaceImageToImageMatch__map_project_on_demand(self)

    @property
    def map_project_on_demand(self):
        return self._map_project_on_demand()

    def _surface_image1(self):
        """
        const boost::shared_ptr<RasterImage>& GeoCal::SurfaceImageToImageMatch::surface_image1() const
        Surface projected image 1. 
        """
        return _geocal.SurfaceImageToImageMatch__surface_image1(self)

    @property
    def surface_image1(self):
        return self._surface_image1()

    def _surface_image2(self):
        """
        const boost::shared_ptr<RasterImage>& GeoCal::SurfaceImageToImageMatch::surface_image2() const
        Surface projected image 2. 
        """
        return _geocal.SurfaceImageToImageMatch__surface_image2(self)

    @property
    def surface_image2(self):
        return self._surface_image2()

    def __reduce__(self):
        if(self.map_project_on_demand):
          return _new_from_init, (self.__class__, self.image_ground_connection1,
    			      self.image_ground_connection2, 
    			      self.surface_image1.map_info(),
    			      self.matcher)
        else:
          return _new_from_init, (self.__class__, self.image_ground_connection1,
    			      self.surface_image1,
    			      self.image_ground_connection2, 
    			      self.surface_image2,
    			      self.matcher)
      
    __swig_destroy__ = _geocal.delete_SurfaceImageToImageMatch
SurfaceImageToImageMatch._image_ground_connection1 = new_instancemethod(_geocal.SurfaceImageToImageMatch__image_ground_connection1,None,SurfaceImageToImageMatch)
SurfaceImageToImageMatch._image_ground_connection2 = new_instancemethod(_geocal.SurfaceImageToImageMatch__image_ground_connection2,None,SurfaceImageToImageMatch)
SurfaceImageToImageMatch._matcher = new_instancemethod(_geocal.SurfaceImageToImageMatch__matcher,None,SurfaceImageToImageMatch)
SurfaceImageToImageMatch._map_project_on_demand = new_instancemethod(_geocal.SurfaceImageToImageMatch__map_project_on_demand,None,SurfaceImageToImageMatch)
SurfaceImageToImageMatch._surface_image1 = new_instancemethod(_geocal.SurfaceImageToImageMatch__surface_image1,None,SurfaceImageToImageMatch)
SurfaceImageToImageMatch._surface_image2 = new_instancemethod(_geocal.SurfaceImageToImageMatch__surface_image2,None,SurfaceImageToImageMatch)
SurfaceImageToImageMatch_swigregister = _geocal.SurfaceImageToImageMatch_swigregister
SurfaceImageToImageMatch_swigregister(SurfaceImageToImageMatch)

class IpiMapProjected(CalcMapProjected):
    """
    This is a CalcMapProjected where the calculation of the image
    coordinates is done by an Ipi.

    This class calculates the data on the fly. Sometimes this is what you
    want, but if you are going to be using the resulting data a few times,
    you may want to use a MemoryRasterImage to generate a copy once and
    keep it in memory.

    C++ includes: ipi_map_projected.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        IpiMapProjected::IpiMapProjected(const MapInfo &Mi, const boost::shared_ptr< Ipi > &I, const
        std::vector< boost::shared_ptr< RasterImage > > &R, const
        boost::shared_ptr< Dem > &D, int Avg_fact=-1, bool
        Read_into_memory=true)
        Constructor.

        We average the data either by the factor given as Avg_fact, or by
        ratio of the Mapinfo resolution and the camera resolution.

        This is a variation that handles multiple bands at one time, you give
        it the set of raster image to process. 
        """
        _geocal.IpiMapProjected_swiginit(self,_geocal.new_IpiMapProjected(*args))
    __swig_destroy__ = _geocal.delete_IpiMapProjected
IpiMapProjected_swigregister = _geocal.IpiMapProjected_swigregister
IpiMapProjected_swigregister(IpiMapProjected)

class LocationToFile(object):
    """
    A common implementation of MapProjectedMultifile is to have some sort
    of a look up table that gives the file name for a particular location.

    This class is a thin wrapper around RTree to give a mapping between
    location and file name. We do this both because RTree's interface is a
    bit different than how we want to access this, and because we want to
    abstract out the use of the libsdbx library since this may go away at
    some point.

    C++ includes: location_to_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _geocal.delete_LocationToFile
LocationToFile_swigregister = _geocal.LocationToFile_swigregister
LocationToFile_swigregister(LocationToFile)

class RayIntersect(object):
    """
    This finds the point closest intersection of two look vector.

    Note that in generate two look vectors don't intersect, we find the
    point closest to the two look vectors.

    C++ includes: ray_intersect.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::RayIntersect::RayIntersect(const boost::shared_ptr< ImageGroundConnection > Igc1, const
        boost::shared_ptr< ImageGroundConnection > Igc2)

        """
        _geocal.RayIntersect_swiginit(self,_geocal.new_RayIntersect(*args))
    def two_look_vector_intersect(*args):
        """
        void RayIntersect::two_look_vector_intersect(const CartesianFixed &P1, const CartesianFixedLookVector &L1, const
        CartesianFixed &P2, const CartesianFixedLookVector &L2,
        boost::shared_ptr< CartesianFixed > &P, double &Dist)

        """
        return _geocal.RayIntersect_two_look_vector_intersect(*args)

    two_look_vector_intersect = staticmethod(two_look_vector_intersect)
    def two_ray_intersect(self, *args):
        """
        void GeoCal::RayIntersect::two_ray_intersect(const ImageCoordinate &Ic1, const ImageCoordinate &Ic2,
        boost::shared_ptr< CartesianFixed > &P, double &Dist)
        Return intersection of look vector corresponding to two image
        coordinates.

        This is the point closest to both look vectors, along with the
        distance of that point from each look vector. 
        """
        return _geocal.RayIntersect_two_ray_intersect(self, *args)

    def _image_ground_connection1(self):
        """
        boost::shared_ptr<ImageGroundConnection> GeoCal::RayIntersect::image_ground_connection1() const

        """
        return _geocal.RayIntersect__image_ground_connection1(self)

    @property
    def image_ground_connection1(self):
        return self._image_ground_connection1()

    def _image_ground_connection2(self):
        """
        boost::shared_ptr<ImageGroundConnection> GeoCal::RayIntersect::image_ground_connection2() const

        """
        return _geocal.RayIntersect__image_ground_connection2(self)

    @property
    def image_ground_connection2(self):
        return self._image_ground_connection2()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.image_ground_connection1,self.image_ground_connection2)

    __swig_destroy__ = _geocal.delete_RayIntersect
RayIntersect.two_ray_intersect = new_instancemethod(_geocal.RayIntersect_two_ray_intersect,None,RayIntersect)
RayIntersect._image_ground_connection1 = new_instancemethod(_geocal.RayIntersect__image_ground_connection1,None,RayIntersect)
RayIntersect._image_ground_connection2 = new_instancemethod(_geocal.RayIntersect__image_ground_connection2,None,RayIntersect)
RayIntersect_swigregister = _geocal.RayIntersect_swigregister
RayIntersect_swigregister(RayIntersect)

def RayIntersect_two_look_vector_intersect(*args):
  """
    void RayIntersect::two_look_vector_intersect(const CartesianFixed &P1, const CartesianFixedLookVector &L1, const
    CartesianFixed &P2, const CartesianFixedLookVector &L2,
    boost::shared_ptr< CartesianFixed > &P, double &Dist)

    """
  return _geocal.RayIntersect_two_look_vector_intersect(*args)

class DemMatch(object):
    """
    This class does matching between two images, and then finds the
    intersection of these two images.

    This defines a Dem surface.

    I'm not really sure how this class should be arranged. Currently, this
    is used by the python class DemGenerate, and this is just the part
    that we want to have in C++. This may evolve over time, and change
    exactly what we do here.

    C++ includes: dem_match.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::DemMatch::DemMatch(const boost::shared_ptr< ImageToImageMatch > &Match, const
        boost::shared_ptr< RayIntersect > &Ray_intersect, double
        Max_dist_good_point)
        Constructor. 
        """
        _geocal.DemMatch_swiginit(self,_geocal.new_DemMatch(*args))
    def surface_point(self, *args):
        """
        blitz::Array< double, 2 > DemMatch::surface_point(int Lstart, int Sstart, int Lend, int Send, int Lstride=1, int
        Sstride=1) const
        Look through the given range in line and sample for the first image.

        Try image matching, and where it succeeds look at the intersection of
        the points. We allow a little slop, but the intersection need to be
        close to where each image would put the point (e.g., epipolar
        constraint), so we reject any point where the intersection is farther
        than the maximum distance in meters that was passed to the
        constructor.

        We return an array of points that we find. This is a N X 3 array, with
        each row corresponding to a point. The columns are latitude,
        longitude, and height (in degrees and meters). This is a bit odd way
        to return this, but it works well with the python class that uses this
        code. 
        """
        return _geocal.DemMatch_surface_point(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< DemMatch  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.DemMatch___str__(self)

    def _match(self):
        """
        boost::shared_ptr<ImageToImageMatch> GeoCal::DemMatch::match() const

        """
        return _geocal.DemMatch__match(self)

    @property
    def match(self):
        return self._match()

    def _ray_intersect(self):
        """
        boost::shared_ptr<RayIntersect> GeoCal::DemMatch::ray_intersect() const

        """
        return _geocal.DemMatch__ray_intersect(self)

    @property
    def ray_intersect(self):
        return self._ray_intersect()

    def _max_distance(self):
        """
        double GeoCal::DemMatch::max_distance() const

        """
        return _geocal.DemMatch__max_distance(self)

    @property
    def max_distance(self):
        return self._max_distance()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.match,self.ray_intersect,self.max_distance)

    __swig_destroy__ = _geocal.delete_DemMatch
DemMatch.surface_point = new_instancemethod(_geocal.DemMatch_surface_point,None,DemMatch)
DemMatch.__str__ = new_instancemethod(_geocal.DemMatch___str__,None,DemMatch)
DemMatch._match = new_instancemethod(_geocal.DemMatch__match,None,DemMatch)
DemMatch._ray_intersect = new_instancemethod(_geocal.DemMatch__ray_intersect,None,DemMatch)
DemMatch._max_distance = new_instancemethod(_geocal.DemMatch__max_distance,None,DemMatch)
DemMatch_swigregister = _geocal.DemMatch_swigregister
DemMatch_swigregister(DemMatch)

class GdalBase(object):
    """
    Base class of Gdal<T>.

    This contains the portion that doesn't depend on T.

    C++ includes: geocal_gdal.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def _map_info(self, *args):
        """
        virtual void GeoCal::GdalBase::map_info(const MapInfo &M)

        """
        return _geocal.GdalBase__map_info(self, *args)

    @property
    def map_info(self):
        return self._map_info()

    @map_info.setter
    def map_info(self, value):
      self._map_info(value)

    def _raster_band(self):
        """
        const GDALRasterBand& GeoCal::GdalBase::raster_band() const
        The underlying GDALRasterBand object. 
        """
        return _geocal.GdalBase__raster_band(self)

    @property
    def raster_band(self):
        return self._raster_band()

    def close(self):
        """
        void GeoCal::GdalBase::close()

        """
        return _geocal.GdalBase_close(self)

    def _is_closed(self):
        """
        bool GeoCal::GdalBase::is_closed() const

        """
        return _geocal.GdalBase__is_closed(self)

    @property
    def is_closed(self):
        return self._is_closed()

    def flush(self):
        """
        void GeoCal::GdalBase::flush() const
        Flush data to disk. 
        """
        return _geocal.GdalBase_flush(self)

    def _rpc(self):
        """
        void GeoCal::GdalBase::rpc(const Rpc &R)

        """
        return _geocal.GdalBase__rpc(self)

    @property
    def rpc(self):
        return self._rpc()

    def __str__(self):
        """
        std::string GeoCal::Printable< GdalBase  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.GdalBase___str__(self)

    driver_count = staticmethod(_geocal.GdalBase_driver_count)
    driver_short_name = staticmethod(_geocal.GdalBase_driver_short_name)
    driver_long_name = staticmethod(_geocal.GdalBase_driver_long_name)
    driver_help_url = staticmethod(_geocal.GdalBase_driver_help_url)
    driver_option_list = staticmethod(_geocal.GdalBase_driver_option_list)
    def __init__(self): 
        _geocal.GdalBase_swiginit(self,_geocal.new_GdalBase())
    __swig_destroy__ = _geocal.delete_GdalBase
GdalBase._map_info = new_instancemethod(_geocal.GdalBase__map_info,None,GdalBase)
GdalBase._raster_band = new_instancemethod(_geocal.GdalBase__raster_band,None,GdalBase)
GdalBase.close = new_instancemethod(_geocal.GdalBase_close,None,GdalBase)
GdalBase._is_closed = new_instancemethod(_geocal.GdalBase__is_closed,None,GdalBase)
GdalBase.flush = new_instancemethod(_geocal.GdalBase_flush,None,GdalBase)
GdalBase._rpc = new_instancemethod(_geocal.GdalBase__rpc,None,GdalBase)
GdalBase.__str__ = new_instancemethod(_geocal.GdalBase___str__,None,GdalBase)
GdalBase_swigregister = _geocal.GdalBase_swigregister
GdalBase_swigregister(GdalBase)

def GdalBase_driver_count():
  return _geocal.GdalBase_driver_count()
GdalBase_driver_count = _geocal.GdalBase_driver_count

def GdalBase_driver_short_name(*args):
  return _geocal.GdalBase_driver_short_name(*args)
GdalBase_driver_short_name = _geocal.GdalBase_driver_short_name

def GdalBase_driver_long_name(*args):
  return _geocal.GdalBase_driver_long_name(*args)
GdalBase_driver_long_name = _geocal.GdalBase_driver_long_name

def GdalBase_driver_help_url(*args):
  return _geocal.GdalBase_driver_help_url(*args)
GdalBase_driver_help_url = _geocal.GdalBase_driver_help_url

def GdalBase_driver_option_list(*args):
  return _geocal.GdalBase_driver_option_list(*args)
GdalBase_driver_option_list = _geocal.GdalBase_driver_option_list

class GdalRasterImage(RasterImageTiledFile):
    """
    This wraps a Gdal<T> to make a RasterImage.

    The type of T should be one we can convert to and from a int, since
    this is what a RasterImage works in.

    C++ includes: gdal_raster_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Byte = _geocal.GdalRasterImage_Byte
    UInt16 = _geocal.GdalRasterImage_UInt16
    Int16 = _geocal.GdalRasterImage_Int16
    UInt32 = _geocal.GdalRasterImage_UInt32
    Int32 = _geocal.GdalRasterImage_Int32
    Float32 = _geocal.GdalRasterImage_Float32
    Float64 = _geocal.GdalRasterImage_Float64
    def __init__(self, *args): 
        """
        GeoCal::GdalRasterImage::GdalRasterImage(const boost::shared_ptr< Gdal< T > > &Data)
        Constructor. 
        """
        _geocal.GdalRasterImage_swiginit(self,_geocal.new_GdalRasterImage(*args))
    def read_all(*args):
        """
        std::vector< boost::shared_ptr< RasterImage > > GdalRasterImage::read_all(const std::string &Fname)
        For some formats, reading all of the data for all the bands at one
        time is much quicker than reading each band separately (assuming you
        actually want all the data).

        For example, for jpeg reading three separate bands requires
        decompressing the data three times while reading all at once only
        decompresses once. Since almost the entire time reading jpeg is used
        in decompressing the data this means it takes about three times as
        long to read all the bands as to read them all at once.

        This function reads all of the data into memory and returns
        RasterImages that can be used to read the data. 
        """
        return _geocal.GdalRasterImage_read_all(*args)

    read_all = staticmethod(read_all)
    def _gdal_data_base(self):
        """
        boost::shared_ptr<GdalBase> GeoCal::GdalRasterImage::gdal_data_base_ptr() const

        """
        return _geocal.GdalRasterImage__gdal_data_base(self)

    @property
    def gdal_data_base(self):
        return self._gdal_data_base()

    def _data_set(self):
        """
        const boost::shared_ptr<GDALDataset>& GeoCal::GdalRasterImage::data_set() const
        The underlying dataset object. 
        """
        return _geocal.GdalRasterImage__data_set(self)

    @property
    def data_set(self):
        return self._data_set()

    def flush(self):
        """
        virtual void GeoCal::GdalRasterImage::flush() const
        Flush data to disk. 
        """
        return _geocal.GdalRasterImage_flush(self)

    def close(self):
        """
        void GeoCal::GdalRasterImage::close()

        """
        return _geocal.GdalRasterImage_close(self)

    def _is_closed(self):
        """
        bool GeoCal::GdalRasterImage::is_closed() const

        """
        return _geocal.GdalRasterImage__is_closed(self)

    @property
    def is_closed(self):
        return self._is_closed()

    def set_map_info(self, *args):
        """
        void GdalRasterImage::set_map_info(const MapInfo &Mi)
        Set the map info. This overwrites whatever was previously set. 
        """
        return _geocal.GdalRasterImage_set_map_info(self, *args)

    def set_rpc(self, *args):
        """
        void GdalRasterImage::set_rpc(const Rpc &R)
        Set the RPC info. This overwrites whatever was previously set. 
        """
        return _geocal.GdalRasterImage_set_rpc(self, *args)

    def has_metadata(self, *args):
        """
        bool GeoCal::GdalRasterImage::has_metadata(const std::string &Metadata_item, const std::string &Domain="")
        const
        Indicates if a metadata item is found in the file. 
        """
        return _geocal.GdalRasterImage_has_metadata(self, *args)

    def set_metadata(self, *args):
        """
        void GeoCal::GdalRasterImage::set_metadata(const std::string &M, const std::string &Val, const std::string
        &Domain="")
        Write the requested metadata. 
        """
        return _geocal.GdalRasterImage_set_metadata(self, *args)

    def _file_names(self):
        """
        std::vector<std::string> GeoCal::GdalRasterImage::file_names() const

        """
        return _geocal.GdalRasterImage__file_names(self)

    @property
    def file_names(self):
        return self._file_names()

    def _map_info_from_nitf_corner(self):
        """
        boost::shared_ptr< MapInfo > GdalRasterImage::map_info_from_nitf_corner() const
        In AFIDS, we calculate what is called the "nitf corners".

        This gives approximate corner coordinates for an image. Depending on
        the application, it can be useful to treat this as an approximate
        MapInfo.

        This return a null pointer if we don't have the NITF corner metadata.

        """
        return _geocal.GdalRasterImage__map_info_from_nitf_corner(self)

    @property
    def map_info_from_nitf_corner(self):
        return self._map_info_from_nitf_corner()

    def _band_id(self):
        """
        int GeoCal::GdalRasterImage::band_id() const

        """
        return _geocal.GdalRasterImage__band_id(self)

    @property
    def band_id(self):
        return self._band_id()

    def _update(self):
        """
        bool GeoCal::GdalRasterImage::update() const

        """
        return _geocal.GdalRasterImage__update(self)

    @property
    def update(self):
        return self._update()

    def _rpc(self):
        """
        Rpc GeoCal::GdalRasterImage::rpc() const
        Return Rpc for image. 
        """
        return _geocal.GdalRasterImage__rpc(self)

    @property
    def rpc(self):
        return self._rpc()

    def _map_info(self):
        """
        virtual const MapInfo& GeoCal::RasterImageVariable::map_info() const
        MapInfo for image. 
        """
        return _geocal.GdalRasterImage__map_info(self)

    @property
    def map_info(self):
        return self._map_info()

    @rpc.setter
    def rpc(self, val):
       self.set_rpc(val)

    @map_info.setter
    def map_info(self, val):
       self.set_map_info(val)

    def __getitem__(self, key):
        if(isinstance(key, list) or isinstance(key, tuple)):
          domain, ky = key
          return self.metadata(ky, domain)
        else:
          return self.metadata(key)

    def __setitem__(self, key, v):
        if(isinstance(key, list) or isinstance(key, tuple)):
          domain, ky = key
          self.set_metadata(ky, v, domain)
        else:
          self.set_metadata(key, v)

    def __contains__(self, key):
        if(isinstance(key, list) or isinstance(key, tuple)):
          domain, ky = key
          return self.has_metadata(ky, domain)
        else:
          return self.has_metadata(key)
        
      
    def metadata(self, *args):
        """
        S GeoCal::GdalRasterImage::metadata(const std::string &Metadata_item, const std::string &Domain="")
        const
        Read a metadata item and cast it to the given type. 
        """
        return _geocal.GdalRasterImage_metadata(self, *args)

    save_to_file = staticmethod(_geocal.GdalRasterImage_save_to_file)
    def save_to_erdas(*args):
        """
        void GdalRasterImage::save_to_erdas(const std::string &Oname, const RasterImageMultiBand &d, int
        Dt=GDT_Byte, int Fill_value=0)
        Copy the given RasterImages into a new Erdas file.

        This calculates the statistics and image pyramid needed by Erdas also.
        The given Fill_value is excluded from the statistics calculation. 
        """
        return _geocal.GdalRasterImage_save_to_erdas(*args)

    save_to_erdas = staticmethod(save_to_erdas)
    def save(*args):
        """
        void GdalRasterImage::save(const std::string &Oname, const std::string &Driver, const
        std::vector< const RasterImage * > &d, int Dt=GDT_Byte, const
        std::string &Option="", bool Require_copy=false, int
        Fill_value=-1000)
        Copy the given RasterImages into a new file, using the given driver
        and options.

        Some drivers only allow "CreateCopy" rather than "Create",
        requiring us to use an intermediate memory version of Gdal. In that
        case, set "require_copy" to true. 
        """
        return _geocal.GdalRasterImage_save(*args)

    save = staticmethod(save)
    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_names[0],self.band_id,self.number_tile,self.update,self.number_tile_line,self.number_tile_sample)

    __swig_destroy__ = _geocal.delete_GdalRasterImage
GdalRasterImage._gdal_data_base = new_instancemethod(_geocal.GdalRasterImage__gdal_data_base,None,GdalRasterImage)
GdalRasterImage._data_set = new_instancemethod(_geocal.GdalRasterImage__data_set,None,GdalRasterImage)
GdalRasterImage.flush = new_instancemethod(_geocal.GdalRasterImage_flush,None,GdalRasterImage)
GdalRasterImage.close = new_instancemethod(_geocal.GdalRasterImage_close,None,GdalRasterImage)
GdalRasterImage._is_closed = new_instancemethod(_geocal.GdalRasterImage__is_closed,None,GdalRasterImage)
GdalRasterImage.set_map_info = new_instancemethod(_geocal.GdalRasterImage_set_map_info,None,GdalRasterImage)
GdalRasterImage.set_rpc = new_instancemethod(_geocal.GdalRasterImage_set_rpc,None,GdalRasterImage)
GdalRasterImage.has_metadata = new_instancemethod(_geocal.GdalRasterImage_has_metadata,None,GdalRasterImage)
GdalRasterImage.set_metadata = new_instancemethod(_geocal.GdalRasterImage_set_metadata,None,GdalRasterImage)
GdalRasterImage._file_names = new_instancemethod(_geocal.GdalRasterImage__file_names,None,GdalRasterImage)
GdalRasterImage._map_info_from_nitf_corner = new_instancemethod(_geocal.GdalRasterImage__map_info_from_nitf_corner,None,GdalRasterImage)
GdalRasterImage._band_id = new_instancemethod(_geocal.GdalRasterImage__band_id,None,GdalRasterImage)
GdalRasterImage._update = new_instancemethod(_geocal.GdalRasterImage__update,None,GdalRasterImage)
GdalRasterImage._rpc = new_instancemethod(_geocal.GdalRasterImage__rpc,None,GdalRasterImage)
GdalRasterImage._map_info = new_instancemethod(_geocal.GdalRasterImage__map_info,None,GdalRasterImage)
GdalRasterImage.metadata = new_instancemethod(_geocal.GdalRasterImage_metadata,None,GdalRasterImage)
GdalRasterImage_swigregister = _geocal.GdalRasterImage_swigregister
GdalRasterImage_swigregister(GdalRasterImage)

def GdalRasterImage_read_all(*args):
  """
    std::vector< boost::shared_ptr< RasterImage > > GdalRasterImage::read_all(const std::string &Fname)
    For some formats, reading all of the data for all the bands at one
    time is much quicker than reading each band separately (assuming you
    actually want all the data).

    For example, for jpeg reading three separate bands requires
    decompressing the data three times while reading all at once only
    decompresses once. Since almost the entire time reading jpeg is used
    in decompressing the data this means it takes about three times as
    long to read all the bands as to read them all at once.

    This function reads all of the data into memory and returns
    RasterImages that can be used to read the data. 
    """
  return _geocal.GdalRasterImage_read_all(*args)

def GdalRasterImage_save_to_file(*args):
  return _geocal.GdalRasterImage_save_to_file(*args)
GdalRasterImage_save_to_file = _geocal.GdalRasterImage_save_to_file

def GdalRasterImage_save_to_erdas(*args):
  """
    void GdalRasterImage::save_to_erdas(const std::string &Oname, const RasterImageMultiBand &d, int
    Dt=GDT_Byte, int Fill_value=0)
    Copy the given RasterImages into a new Erdas file.

    This calculates the statistics and image pyramid needed by Erdas also.
    The given Fill_value is excluded from the statistics calculation. 
    """
  return _geocal.GdalRasterImage_save_to_erdas(*args)

def GdalRasterImage_save(*args):
  """
    void GdalRasterImage::save(const std::string &Oname, const std::string &Driver, const
    std::vector< const RasterImage * > &d, int Dt=GDT_Byte, const
    std::string &Option="", bool Require_copy=false, int
    Fill_value=-1000)
    Copy the given RasterImages into a new file, using the given driver
    and options.

    Some drivers only allow "CreateCopy" rather than "Create",
    requiring us to use an intermediate memory version of Gdal. In that
    case, set "require_copy" to true. 
    """
  return _geocal.GdalRasterImage_save(*args)

class GdalDatum(Datum):
    """
    This uses a GdalRasterImage to provide a datum.

    This file should have the offset from the datum to reference ellipsoid
    (e.g., WGS-84).

    C++ includes: gdal_datum.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::GdalDatum::GdalDatum(const boost::shared_ptr< GdalRasterImage > &Map_file)

        """
        _geocal.GdalDatum_swiginit(self,_geocal.new_GdalDatum(*args))
    def _map_file(self):
        """
        boost::shared_ptr<GdalRasterImage> GeoCal::GdalDatum::map_file() const

        """
        return _geocal.GdalDatum__map_file(self)

    @property
    def map_file(self):
        return self._map_file()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.map_file)

    __swig_destroy__ = _geocal.delete_GdalDatum
GdalDatum._map_file = new_instancemethod(_geocal.GdalDatum__map_file,None,GdalDatum)
GdalDatum_swigregister = _geocal.GdalDatum_swigregister
GdalDatum_swigregister(GdalDatum)

class GdalDem(DemTiledFile):
    """
    This uses a Gdal<T> as a DEM.

    The type of T should be one we can convert to a double, and should
    give the height in meters above sea level. We do a bilinear
    interpolation to get values between points, and we optionally return a
    height of 0 outside of the range of where we have data (or
    alternatively, throw an exception).

    Right now, the datum needs to be passed in. I don't believe there is
    any information available in the files to let us know which datum to
    use.

    C++ includes: gdal_dem.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GdalDem::GdalDem(const std::string &Fname, const boost::shared_ptr< Datum > &D, int
        Band_id=1, bool Outside_dem_is_error=false, int Number_tile=4, int
        Tile_number_line=-1, int Tile_number_sample=-1)
        Constructor that reads an existing file to get the Dem data.

        The default Datum used if none is supplied is DidDatum, which is
        relative to WGS-84. If Outside_dem_is_error is false, we return a
        height of 0 outside of the range of the data, otherwise an exception
        is thrown when an attempt is made to retrieve an height outside of the
        range.

        You can optionally pass the desired tile size. If you don't pass this
        in, we use the blocking size of the underlying dataset. 
        """
        _geocal.GdalDem_swiginit(self,_geocal.new_GdalDem(*args))
    def elevation(self, *args):
        """
        virtual double GeoCal::DemTiledFile::elevation(int Y_index, int X_index) const
        Return height in meters relative to datum().

        Note that the call is in line, sample order, which means Y and then X.

        """
        return _geocal.GdalDem_elevation(self, *args)

    def _file_name(self):
        """
        const std::string& GeoCal::GdalDem::file_name() const

        """
        return _geocal.GdalDem__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def _band_id(self):
        """
        int GeoCal::GdalDem::band_id() const

        """
        return _geocal.GdalDem__band_id(self)

    @property
    def band_id(self):
        return self._band_id()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name,self.datum,self.band_id,self.outside_dem_is_error,self.number_tile)

    __swig_destroy__ = _geocal.delete_GdalDem
GdalDem.elevation = new_instancemethod(_geocal.GdalDem_elevation,None,GdalDem)
GdalDem._file_name = new_instancemethod(_geocal.GdalDem__file_name,None,GdalDem)
GdalDem._band_id = new_instancemethod(_geocal.GdalDem__band_id,None,GdalDem)
GdalDem_swigregister = _geocal.GdalDem_swigregister
GdalDem_swigregister(GdalDem)

class GdalMultiBand(RasterImageMultiBandVariable):
    """
    This is a set of Gdal RasterImages, one for each band.

    C++ includes: gdal_multi_band.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GdalMultiBand::GdalMultiBand(const std::string &Fname, const std::string &Driver_name, int
        Number_line, int Number_sample, int Number_band, int Dt, const
        std::string &Options="", int Number_tile=4, int Tile_number_line=-1,
        int Tile_number_sample=-1)
        Create a new file.

        All the arguments here are the same as for GdalRasterImage. 
        """
        _geocal.GdalMultiBand_swiginit(self,_geocal.new_GdalMultiBand(*args))
    def set_rpc(self, *args):
        """
        void GeoCal::GdalMultiBand::set_rpc(const Rpc &R)

        """
        return _geocal.GdalMultiBand_set_rpc(self, *args)

    def set_map_info(self, *args):
        """
        void GeoCal::GdalMultiBand::set_map_info(const MapInfo &M)

        """
        return _geocal.GdalMultiBand_set_map_info(self, *args)

    def save(*args):
        """
        void GdalMultiBand::save(const std::string &Oname, const std::string &Driver, const
        RasterImageMultiBand &d, bool Log_progress=false, int Dt=GDT_Byte,
        const std::string &Options="")
        Copy the RasterImageMultiBand into a new file.

        We copy map and RPC information (if found) from the first band in
        RasterImageMultiBand. 
        """
        return _geocal.GdalMultiBand_save(*args)

    save = staticmethod(save)
    def gdal_raster_image(self, *args):
        """
        boost::shared_ptr<GdalRasterImage> GeoCal::GdalMultiBand::gdal_raster_image(int band) const
        RasterImage, cast to GdalRasterImage. 
        """
        return _geocal.GdalMultiBand_gdal_raster_image(self, *args)

    def data_set(self):
        """
        const boost::shared_ptr<GDALDataset>& GeoCal::GdalMultiBand::data_set() const
        The underlying dataset object. 
        """
        return _geocal.GdalMultiBand_data_set(self)

    def flush(self):
        """
        void GdalMultiBand::flush() const
        Flush data to disk for all bands. 
        """
        return _geocal.GdalMultiBand_flush(self)

    def close(self):
        """
        void GdalMultiBand::close() const
        Flush data to disk for all bands and close file.

        You don't normally need to call this directly, since the destructor of
        the files automatically does this. But this can be useful in some
        cases. 
        """
        return _geocal.GdalMultiBand_close(self)

    __swig_destroy__ = _geocal.delete_GdalMultiBand
GdalMultiBand.set_rpc = new_instancemethod(_geocal.GdalMultiBand_set_rpc,None,GdalMultiBand)
GdalMultiBand.set_map_info = new_instancemethod(_geocal.GdalMultiBand_set_map_info,None,GdalMultiBand)
GdalMultiBand.gdal_raster_image = new_instancemethod(_geocal.GdalMultiBand_gdal_raster_image,None,GdalMultiBand)
GdalMultiBand.data_set = new_instancemethod(_geocal.GdalMultiBand_data_set,None,GdalMultiBand)
GdalMultiBand.flush = new_instancemethod(_geocal.GdalMultiBand_flush,None,GdalMultiBand)
GdalMultiBand.close = new_instancemethod(_geocal.GdalMultiBand_close,None,GdalMultiBand)
GdalMultiBand_swigregister = _geocal.GdalMultiBand_swigregister
GdalMultiBand_swigregister(GdalMultiBand)

def GdalMultiBand_save(*args):
  """
    void GdalMultiBand::save(const std::string &Oname, const std::string &Driver, const
    RasterImageMultiBand &d, bool Log_progress=false, int Dt=GDT_Byte,
    const std::string &Options="")
    Copy the RasterImageMultiBand into a new file.

    We copy map and RPC information (if found) from the first band in
    RasterImageMultiBand. 
    """
  return _geocal.GdalMultiBand_save(*args)

class ImagePointDisplay(GdalRasterImage):
    """
    This class is used to generate a display of image points.

    This is useful for example to show the difference between initial and
    final location during image matching

    C++ includes: image_point_display.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::ImagePointDisplay::ImagePointDisplay(const std::string &Fname, const std::string &Driver_name, int
        Number_line, int Number_sample, int Dt, const std::string
        &Options="", int Number_tile=4, int Tile_number_line=-1, int
        Tile_number_sample=-1)
        Constructor to write a new file. 
        """
        _geocal.ImagePointDisplay_swiginit(self,_geocal.new_ImagePointDisplay(*args))
    def image_point(self, *args):
        """
        void GeoCal::ImagePointDisplay::image_point(const GroundCoordinate &Gc, int Cindex)
        Display Point with the given color index. 
        """
        return _geocal.ImagePointDisplay_image_point(self, *args)

    __swig_destroy__ = _geocal.delete_ImagePointDisplay
ImagePointDisplay.image_point = new_instancemethod(_geocal.ImagePointDisplay_image_point,None,ImagePointDisplay)
ImagePointDisplay_swigregister = _geocal.ImagePointDisplay_swigregister
ImagePointDisplay_swigregister(ImagePointDisplay)

class OgrWrapper(object):
    """
    This is a wrapper around the OGRSpatialReference class.

    We hold onto a OGRSpatialReference class and a transformation from
    that coordinate system to the Geodetic coordinate system. This class
    handles the lifetime of these objects. This is separated out from
    OgrCoordinate because typically we'll have lots of OgrCoordinates that
    have the same OgrWrapper.

    C++ includes: ogr_coordinate.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        OgrWrapper::OgrWrapper(const boost::shared_ptr< OGRSpatialReference > &Ogr)
        Constructor, from an existing OGRSpatialReference. 
        """
        _geocal.OgrWrapper_swiginit(self,_geocal.new_OgrWrapper(*args))
    def from_epsg(*args):
        """
        boost::shared_ptr< OgrWrapper > OgrWrapper::from_epsg(int Epsg_id)
        Create a OgrWrapper for a coordinate system given by the EPSG ID.

        You can look the EPSG code up for various coordinate systems
        athttp://www.epsg-registry.org 
        """
        return _geocal.OgrWrapper_from_epsg(*args)

    from_epsg = staticmethod(from_epsg)
    def _ogr(self):
        """
        const boost::shared_ptr<OGRSpatialReference>& GeoCal::OgrWrapper::ogr_ptr() const

        """
        return _geocal.OgrWrapper__ogr(self)

    @property
    def ogr(self):
        return self._ogr()

    def _transform(self):
        """
        const OGRCoordinateTransformation& GeoCal::OgrWrapper::transform() const
        Return transformation that takes us from our coordinate system to
        Geodetic. 
        """
        return _geocal.OgrWrapper__transform(self)

    @property
    def transform(self):
        return self._transform()

    def _inverse_transform(self):
        """
        const OGRCoordinateTransformation& GeoCal::OgrWrapper::inverse_transform() const
        Return inverse of transform().

        This goes from Geodetic to our coordinate system. 
        """
        return _geocal.OgrWrapper__inverse_transform(self)

    @property
    def inverse_transform(self):
        return self._inverse_transform()

    def _projected_cs_type_geo_key(self):
        """
        std::string OgrWrapper::projected_cs_type_geo_key() const
        When converting to the GEOTIFF header format used by VICAR, this is
        the value that the PROJECTEDCSTYPEGEOKEY should have.

        This is just the EPSG id written as text. 
        """
        return _geocal.OgrWrapper__projected_cs_type_geo_key(self)

    @property
    def projected_cs_type_geo_key(self):
        return self._projected_cs_type_geo_key()

    def _pcs_citation_geo_key(self):
        """
        std::string OgrWrapper::pcs_citation_geo_key() const
        When converting to the GEOTIFF header format used by VICAR, this is
        the value that the PCSCitationGeoKey should have.

        This is a short text description of the projection. 
        """
        return _geocal.OgrWrapper__pcs_citation_geo_key(self)

    @property
    def pcs_citation_geo_key(self):
        return self._pcs_citation_geo_key()

    def _wkt(self):
        """
        std::string OgrWrapper::wkt() const
        Write out a the WKT (Well Known Text) for ogr_. 
        """
        return _geocal.OgrWrapper__wkt(self)

    @property
    def wkt(self):
        return self._wkt()

    def _pretty_wkt(self):
        """
        std::string OgrWrapper::pretty_wkt() const
        Write out a prettified version of the WKT for ogr_. 
        """
        return _geocal.OgrWrapper__pretty_wkt(self)

    @property
    def pretty_wkt(self):
        return self._pretty_wkt()

    def __str__(self):
        """
        std::string GeoCal::Printable< OgrWrapper  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.OgrWrapper___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.wkt)

    __swig_destroy__ = _geocal.delete_OgrWrapper
OgrWrapper._ogr = new_instancemethod(_geocal.OgrWrapper__ogr,None,OgrWrapper)
OgrWrapper._transform = new_instancemethod(_geocal.OgrWrapper__transform,None,OgrWrapper)
OgrWrapper._inverse_transform = new_instancemethod(_geocal.OgrWrapper__inverse_transform,None,OgrWrapper)
OgrWrapper._projected_cs_type_geo_key = new_instancemethod(_geocal.OgrWrapper__projected_cs_type_geo_key,None,OgrWrapper)
OgrWrapper._pcs_citation_geo_key = new_instancemethod(_geocal.OgrWrapper__pcs_citation_geo_key,None,OgrWrapper)
OgrWrapper._wkt = new_instancemethod(_geocal.OgrWrapper__wkt,None,OgrWrapper)
OgrWrapper._pretty_wkt = new_instancemethod(_geocal.OgrWrapper__pretty_wkt,None,OgrWrapper)
OgrWrapper.__str__ = new_instancemethod(_geocal.OgrWrapper___str__,None,OgrWrapper)
OgrWrapper_swigregister = _geocal.OgrWrapper_swigregister
OgrWrapper_swigregister(OgrWrapper)

def OgrWrapper_from_epsg(*args):
  """
    boost::shared_ptr< OgrWrapper > OgrWrapper::from_epsg(int Epsg_id)
    Create a OgrWrapper for a coordinate system given by the EPSG ID.

    You can look the EPSG code up for various coordinate systems
    athttp://www.epsg-registry.org 
    """
  return _geocal.OgrWrapper_from_epsg(*args)

class OgrCoordinate(GroundCoordinate):
    """
    This is a ground coordinate, implemented by the OGRSpatialReference
    class supplied with GDAL.

    This class is particularly useful for working with
    GdalMapProjectedImage or VicarMapProjectedImage. The
    OGRSpatialReference can work with a number of ways of describing a
    coordinate system, including Well Known Text format (WKT) of the
    OpenGIS Transformation specification and the EPSG specification. Note
    in particular the EPSG specification is what is used by geotiff, the
    format used by the AFIDS system.

    You can see the documentation for OGRSpatialReference
    athttp://www.gdal.org/ogr/osr_tutorial.html.

    C++ includes: ogr_coordinate.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        OgrCoordinate::OgrCoordinate(const boost::shared_ptr< OgrWrapper > &Ogr, const Geodetic &G)
        Convert from Geodetic to the coordinate system given by Ogr. 
        """
        _geocal.OgrCoordinate_swiginit(self,_geocal.new_OgrCoordinate(*args))
    def to_geodetic(self):
        """
        Geodetic OgrCoordinate::to_geodetic() const
        Convert to Geodetic coordinates. 
        """
        return _geocal.OgrCoordinate_to_geodetic(self)

    def _ogr(self):
        """
        const boost::shared_ptr<OgrWrapper>& GeoCal::OgrCoordinate::ogr_ptr() const
        Underlying OgrWrapper. 
        """
        return _geocal.OgrCoordinate__ogr(self)

    @property
    def ogr(self):
        return self._ogr()

    x = _swig_property(_geocal.OgrCoordinate_x_get, _geocal.OgrCoordinate_x_set)
    y = _swig_property(_geocal.OgrCoordinate_y_get, _geocal.OgrCoordinate_y_set)
    z = _swig_property(_geocal.OgrCoordinate_z_get, _geocal.OgrCoordinate_z_set)
    def to_utm(*args):
        """
        OgrCoordinate OgrCoordinate::to_utm(const Geodetic &Gc, int zone=-999)
        Convert a GroundCoordinate to UTM.

        If desired, you can pass in the zone number (use negative number for
        southern zones), or if left blank we determine the appropriate zone to
        use. 
        """
        return _geocal.OgrCoordinate_to_utm(*args)

    to_utm = staticmethod(to_utm)
    def __reduce__(self):
      return _new_from_init, (self.__class__, self.ogr,self.x,self.y,self.z)

    __swig_destroy__ = _geocal.delete_OgrCoordinate
OgrCoordinate.to_geodetic = new_instancemethod(_geocal.OgrCoordinate_to_geodetic,None,OgrCoordinate)
OgrCoordinate._ogr = new_instancemethod(_geocal.OgrCoordinate__ogr,None,OgrCoordinate)
OgrCoordinate_swigregister = _geocal.OgrCoordinate_swigregister
OgrCoordinate_swigregister(OgrCoordinate)

def OgrCoordinate_to_utm(*args):
  """
    OgrCoordinate OgrCoordinate::to_utm(const Geodetic &Gc, int zone=-999)
    Convert a GroundCoordinate to UTM.

    If desired, you can pass in the zone number (use negative number for
    southern zones), or if left blank we determine the appropriate zone to
    use. 
    """
  return _geocal.OgrCoordinate_to_utm(*args)

class OgrCoordinateConverter(CoordinateConverter):
    """
    This is a CoordinateConverter for working with OgrCoordinates.

    C++ includes: ogr_coordinate.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::OgrCoordinateConverter::OgrCoordinateConverter(const boost::shared_ptr< OgrWrapper > Ogr)
        Constructor. 
        """
        _geocal.OgrCoordinateConverter_swiginit(self,_geocal.new_OgrCoordinateConverter(*args))
    def _ogr(self):
        """
        const boost::shared_ptr<OgrWrapper>& GeoCal::OgrCoordinateConverter::ogr_ptr() const
        Underlying OgrWrapper. 
        """
        return _geocal.OgrCoordinateConverter__ogr(self)

    @property
    def ogr(self):
        return self._ogr()

    def convert_from_coordinate(self, *args):
        """
        virtual boost::shared_ptr<GroundCoordinate> GeoCal::OgrCoordinateConverter::convert_from_coordinate(double X, double Y, double Height=0) const
        Create a OgrCoordinate.

        X, Y, and Height are in whatever X, Y, and Z are for the underlying
        OgrWrapper projection. 
        """
        return _geocal.OgrCoordinateConverter_convert_from_coordinate(self, *args)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.ogr)

    __swig_destroy__ = _geocal.delete_OgrCoordinateConverter
OgrCoordinateConverter._ogr = new_instancemethod(_geocal.OgrCoordinateConverter__ogr,None,OgrCoordinateConverter)
OgrCoordinateConverter.convert_from_coordinate = new_instancemethod(_geocal.OgrCoordinateConverter_convert_from_coordinate,None,OgrCoordinateConverter)
OgrCoordinateConverter_swigregister = _geocal.OgrCoordinateConverter_swigregister
OgrCoordinateConverter_swigregister(OgrCoordinateConverter)

class MemoryMultiBand(RasterImageMultiBandVariable):
    """
    This reads a RasterImageMultiBand into memory, and allow access that
    memory.

    C++ includes: memory_multi_band.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        MemoryMultiBand::MemoryMultiBand(const RasterImageMultiBand &R)
        Read all of the data from the given RasterImageBand into memory, and
        provide access to it.

        Note that we require that all the bands have the same number of lines
        and samples. 
        """
        _geocal.MemoryMultiBand_swiginit(self,_geocal.new_MemoryMultiBand(*args))
    def _data(self):
        """
        const blitz::Array<int, 3>& GeoCal::MemoryMultiBand::data() const
        This the underlying data. This is ordered by band, line, and sample.

        """
        return _geocal.MemoryMultiBand__data(self)

    @property
    def data(self):
        return self._data()

    __swig_destroy__ = _geocal.delete_MemoryMultiBand
MemoryMultiBand._data = new_instancemethod(_geocal.MemoryMultiBand__data,None,MemoryMultiBand)
MemoryMultiBand_swigregister = _geocal.MemoryMultiBand_swigregister
MemoryMultiBand_swigregister(MemoryMultiBand)

class SpiceHelper(object):
    """
    This class centralizes all of the CSPICE calls from the CSPICE library
    (available from NAIF athttp://naif.jpl.nasa.gov/naif/pds.html).

    This class handles initializing CSPICE, and provides one place to
    modify if we ever need to replace the dependency on this library.

    SPICE depends on various kernels. We load the file found at
    $SPICEDATA/geocal.ker. This file in turn loads a number of other
    kernels, you can edit this file to change which kernels are used.

    C++ includes: spice_helper.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def spice_available():
        """
        bool SpiceHelper::spice_available()
        Return true if we have SPICE functionality available, false otherwise.

        """
        return _geocal.SpiceHelper_spice_available()

    spice_available = staticmethod(spice_available)
    def spice_setup(Kernel="geocal.ker"):
        """
        void SpiceHelper::spice_setup(const std::string &Kernel="geocal.ker")
        Set SPICE errors to just return, rather than aborting. 
        """
        return _geocal.SpiceHelper_spice_setup(Kernel)

    spice_setup = staticmethod(spice_setup)
    def __init__(self): 
        _geocal.SpiceHelper_swiginit(self,_geocal.new_SpiceHelper())
    __swig_destroy__ = _geocal.delete_SpiceHelper
SpiceHelper_swigregister = _geocal.SpiceHelper_swigregister
SpiceHelper_swigregister(SpiceHelper)

def SpiceHelper_spice_available():
  """
    bool SpiceHelper::spice_available()
    Return true if we have SPICE functionality available, false otherwise.

    """
  return _geocal.SpiceHelper_spice_available()

def SpiceHelper_spice_setup(Kernel="geocal.ker"):
  """
    void SpiceHelper::spice_setup(const std::string &Kernel="geocal.ker")
    Set SPICE errors to just return, rather than aborting. 
    """
  return _geocal.SpiceHelper_spice_setup(Kernel)

class RawRasterImage(RasterImage):
    """
    This uses libraw to read RAW format.

    This is the format used by some cameras, e.g., Cannon RAW format. You
    can see the details about what can be read athttp://www.libraw.org.

    Note that although this reads the RAW format, the data is in the RAW
    space, the DN values don't mean much without translating them to RGB
    color space. You may want to instead use the program dcraw which
    converts to PPM or Tiff format and includes translating to color plus
    making 8 bit.

    C++ includes: raw_raster_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        RawRasterImage::RawRasterImage(const std::string &Fname, int Band=0)
        Read in the given file with the given Band (0 based). 
        """
        _geocal.RawRasterImage_swiginit(self,_geocal.new_RawRasterImage(*args))
    def read_all(*args):
        """
        std::vector< boost::shared_ptr< RasterImage > > RawRasterImage::read_all(const std::string &Fname)
        These read all three bands of a file at once.

        This is faster than reading each band separately. 
        """
        return _geocal.RawRasterImage_read_all(*args)

    read_all = staticmethod(read_all)
    def _file_name(self):
        """
        const std::string& GeoCal::RawRasterImage::file_name() const

        """
        return _geocal.RawRasterImage__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def _band(self):
        """
        int GeoCal::RawRasterImage::band() const

        """
        return _geocal.RawRasterImage__band(self)

    @property
    def band(self):
        return self._band()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name,self.band)

    __swig_destroy__ = _geocal.delete_RawRasterImage
RawRasterImage._file_name = new_instancemethod(_geocal.RawRasterImage__file_name,None,RawRasterImage)
RawRasterImage._band = new_instancemethod(_geocal.RawRasterImage__band,None,RawRasterImage)
RawRasterImage_swigregister = _geocal.RawRasterImage_swigregister
RawRasterImage_swigregister(RawRasterImage)

def RawRasterImage_read_all(*args):
  """
    std::vector< boost::shared_ptr< RasterImage > > RawRasterImage::read_all(const std::string &Fname)
    These read all three bands of a file at once.

    This is faster than reading each band separately. 
    """
  return _geocal.RawRasterImage_read_all(*args)

class AircraftOrbitData(QuaternionOrbitData):
    """
    This is a single navigation file record for aircraft data.

    This was originally written for data as reported by Applanix ephemeris
    and attitude, but it is likely to be useful for other INU untis.

    Note that we frequently don't have access to a direct measurement of
    the velocity. Rather than trying to do some clever estimate of the
    velocity, we just set it to 0. The velocity is only used for the
    abberation of light calculation, which isn't important for aircraft
    speeds. We can revisit this choice if needed, it wouldn't be too hard
    to use a couple of position measurements at nearby times to estimate
    the velocity.

    C++ includes: aircraft_orbit_data.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        AircraftOrbitData::AircraftOrbitData(const Time &Tm, const GroundCoordinate &Position, const Time &Tm2,
        const GroundCoordinate &Position2, double Roll, double Pitch, double
        Heading)
        Often with Aircraft data we don't have a direct measure of velocity.

        This calculates a simple velocity by taking a second position and a
        different time and assuming a constant velocity between the values. 
        """
        _geocal.AircraftOrbitData_swiginit(self,_geocal.new_AircraftOrbitData(*args))
    def _position_geodetic(self):
        """
        const Geodetic& GeoCal::AircraftOrbitData::position_geodetic() const
        Position of aircraft. 
        """
        return _geocal.AircraftOrbitData__position_geodetic(self)

    @property
    def position_geodetic(self):
        return self._position_geodetic()

    def _roll(self):
        """
        double GeoCal::AircraftOrbitData::roll() const
        Roll, in degrees. 
        """
        return _geocal.AircraftOrbitData__roll(self)

    @property
    def roll(self):
        return self._roll()

    def _pitch(self):
        """
        double GeoCal::AircraftOrbitData::pitch() const
        Pitch, in degrees. 
        """
        return _geocal.AircraftOrbitData__pitch(self)

    @property
    def pitch(self):
        return self._pitch()

    def _heading(self):
        """
        double GeoCal::AircraftOrbitData::heading() const
        Heading, in degrees. 
        """
        return _geocal.AircraftOrbitData__heading(self)

    @property
    def heading(self):
        return self._heading()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.time,self.position_geodetic,self.velocity_cf,self.roll,self.pitch,self.heading)

    __swig_destroy__ = _geocal.delete_AircraftOrbitData
AircraftOrbitData._position_geodetic = new_instancemethod(_geocal.AircraftOrbitData__position_geodetic,None,AircraftOrbitData)
AircraftOrbitData._roll = new_instancemethod(_geocal.AircraftOrbitData__roll,None,AircraftOrbitData)
AircraftOrbitData._pitch = new_instancemethod(_geocal.AircraftOrbitData__pitch,None,AircraftOrbitData)
AircraftOrbitData._heading = new_instancemethod(_geocal.AircraftOrbitData__heading,None,AircraftOrbitData)
AircraftOrbitData_swigregister = _geocal.AircraftOrbitData_swigregister
AircraftOrbitData_swigregister(AircraftOrbitData)

class OrbitQuaternionList(Orbit):
    """
    This is an implementation of an Orbit that is a list of
    QuaternionOrbitData values.

    For times that fall between these values, we interpolate to get the
    OrbitData.

    C++ includes: orbit_quaternion_list.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::OrbitQuaternionList::OrbitQuaternionList(iterator ibeg, iterator iend)
        Constructor that takes a list of QuaternionOrbitData values.

        Note that the data doesn't need to be sorted, we handle sorting as we
        ingest the data. 
        """
        _geocal.OrbitQuaternionList_swiginit(self,_geocal.new_OrbitQuaternionList(*args))
    __swig_destroy__ = _geocal.delete_OrbitQuaternionList
OrbitQuaternionList_swigregister = _geocal.OrbitQuaternionList_swigregister
OrbitQuaternionList_swigregister(OrbitQuaternionList)

class PanSharpen(CalcRasterMultiBand):
    """
    This create a set of pan sharpened images from a pan band and a set of
    multispectral bands (at lower resolution).

    This uses the pan sharpening algorithm described in "WorldView-2 Pan-
    Sharpening" by Chris Padwick et. al. (ASPRS 2010 Annual Conference).

    Because of the way this is calculated, it is most efficient to
    calculate all bands for a given tile at one time. So you should access
    all bands for a particular tile before going to the next tile for this
    object. Nothing bad happens if you don't, it is just slower to access.

    C++ includes: pan_sharpen.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        PanSharpen::PanSharpen(const boost::shared_ptr< RasterImage > &Pan, const
        RasterImageMultiBand &Mul, bool Force_rpc=false, bool
        Log_progress=true, const boost::shared_ptr< RasterImage >
        &Pan_overview=boost::shared_ptr< RasterImage >(), const
        boost::shared_ptr< RasterImageMultiBand >
        &Mul_overview=boost::shared_ptr< RasterImageMultiBand >())
        Constructor.

        This takes in a pan image and a multi spectral image. We subset to the
        area we can calculate PanSharpen over.

        Parameters:
        -----------

        Pan:  The panchromatic image to use

        Mul:  The multispectral images to use

        Force_rpc:  Sometimes an image will have both map information and an
        RPC. In this case, we use the map information by preference, unless
        directed by Force_rpc being true.

        Pan_overview:  Optional overview to use instead of Pan for calculating
        the initial statistics.

        Mul_overview:  Optional overview to use instead of Mul for calculating
        the initial statistics.

        Log_progress:  If true, write progress message to std::cout as we work
        through the data. 
        """
        _geocal.PanSharpen_swiginit(self,_geocal.new_PanSharpen(*args))
    psmooth = _swig_property(_geocal.PanSharpen_psmooth_get, _geocal.PanSharpen_psmooth_set)
    pansub = _swig_property(_geocal.PanSharpen_pansub_get, _geocal.PanSharpen_pansub_set)
    mag = _swig_property(_geocal.PanSharpen_mag_get, _geocal.PanSharpen_mag_set)
    mulsub = _swig_property(_geocal.PanSharpen_mulsub_get, _geocal.PanSharpen_mulsub_set)
    psq_stat = _swig_property(_geocal.PanSharpen_psq_stat_get, _geocal.PanSharpen_psq_stat_set)
    isq_stat = _swig_property(_geocal.PanSharpen_isq_stat_get, _geocal.PanSharpen_isq_stat_set)
    __swig_destroy__ = _geocal.delete_PanSharpen
PanSharpen_swigregister = _geocal.PanSharpen_swigregister
PanSharpen_swigregister(PanSharpen)

class ScaleImage(CalcRaster):
    """
    This is a simple adapter that multiples a underlying image by a scale
    factor.

    C++ includes: scale_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::ScaleImage::ScaleImage(const boost::shared_ptr< RasterImage > &Data, double Scale_factor)

        """
        _geocal.ScaleImage_swiginit(self,_geocal.new_ScaleImage(*args))
    def _raw_data(self):
        """
        const boost::shared_ptr<RasterImage>& GeoCal::ScaleImage::raw_data() const

        """
        return _geocal.ScaleImage__raw_data(self)

    @property
    def raw_data(self):
        return self._raw_data()

    def _scale_factor(self):
        """
        double GeoCal::ScaleImage::scale_factor() const

        """
        return _geocal.ScaleImage__scale_factor(self)

    @property
    def scale_factor(self):
        return self._scale_factor()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.raw_data,self.scale_factor)

    __swig_destroy__ = _geocal.delete_ScaleImage
ScaleImage._raw_data = new_instancemethod(_geocal.ScaleImage__raw_data,None,ScaleImage)
ScaleImage._scale_factor = new_instancemethod(_geocal.ScaleImage__scale_factor,None,ScaleImage)
ScaleImage_swigregister = _geocal.ScaleImage_swigregister
ScaleImage_swigregister(ScaleImage)

class ApplyMask(CalcRaster):
    """
    This applies a mask to a RasterImage.

    The data either passes through the mask, or it set to a value of 0
    (the normal gore value we use) if a second RasterImage indicates that
    this is masked.

    C++ includes: apply_mask.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::ApplyMask::ApplyMask(const boost::shared_ptr< RasterImage > &Data, const
        boost::shared_ptr< RasterImage > &M, int Good_value=0)
        Constructor.

        Parameters:
        -----------

        Data:  Underlying data

        M:   Mask image

        Good_value:  Pixels with this value in the the image M allow 
        """
        _geocal.ApplyMask_swiginit(self,_geocal.new_ApplyMask(*args))
    def _raw_data(self):
        """
        boost::shared_ptr<RasterImage> GeoCal::ApplyMask::raw_data() const

        """
        return _geocal.ApplyMask__raw_data(self)

    @property
    def raw_data(self):
        return self._raw_data()

    def _mask(self):
        """
        boost::shared_ptr<RasterImage> GeoCal::ApplyMask::mask() const

        """
        return _geocal.ApplyMask__mask(self)

    @property
    def mask(self):
        return self._mask()

    def _good_value(self):
        """
        int GeoCal::ApplyMask::good_value() const

        """
        return _geocal.ApplyMask__good_value(self)

    @property
    def good_value(self):
        return self._good_value()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.raw_data,self.mask,self.good_value)

    __swig_destroy__ = _geocal.delete_ApplyMask
ApplyMask._raw_data = new_instancemethod(_geocal.ApplyMask__raw_data,None,ApplyMask)
ApplyMask._mask = new_instancemethod(_geocal.ApplyMask__mask,None,ApplyMask)
ApplyMask._good_value = new_instancemethod(_geocal.ApplyMask__good_value,None,ApplyMask)
ApplyMask_swigregister = _geocal.ApplyMask_swigregister
ApplyMask_swigregister(ApplyMask)

class RpcImageGroundConnection(ImageGroundConnection):
    """
    This is a ImageGroundConnection where the connection is made by a Rpc.

    C++ includes: rpc_image_ground_connection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::RpcImageGroundConnection::RpcImageGroundConnection(const Rpc &R, const boost::shared_ptr< Dem > &D, const
        boost::shared_ptr< RasterImage > &Img, const std::string
        &Title="Image")

        """
        _geocal.RpcImageGroundConnection_swiginit(self,_geocal.new_RpcImageGroundConnection(*args))
    def _rpc(self):
        """
        boost::shared_ptr<Rpc> GeoCal::RpcImageGroundConnection::rpc_ptr() const

        """
        return _geocal.RpcImageGroundConnection__rpc(self)

    @property
    def rpc(self):
        return self._rpc()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.rpc,self.dem,self.image,self.title)

    __swig_destroy__ = _geocal.delete_RpcImageGroundConnection
RpcImageGroundConnection._rpc = new_instancemethod(_geocal.RpcImageGroundConnection__rpc,None,RpcImageGroundConnection)
RpcImageGroundConnection_swigregister = _geocal.RpcImageGroundConnection_swigregister
RpcImageGroundConnection_swigregister(RpcImageGroundConnection)

class IpiImageGroundConnection(ImageGroundConnection):
    """
    This is a ImageGroundConnection where the connection is made by a Ipi.

    C++ includes: ipi_image_ground_connection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::IpiImageGroundConnection::IpiImageGroundConnection(const boost::shared_ptr< Ipi > &I, const boost::shared_ptr< Dem > &D,
        const boost::shared_ptr< RasterImage > &Img, const std::string
        &Title="Image", double Resolution=30, int Band=0, double
        Max_height=9000)

        """
        _geocal.IpiImageGroundConnection_swiginit(self,_geocal.new_IpiImageGroundConnection(*args))
    def _ipi(self):
        """
        const boost::shared_ptr<Ipi>& GeoCal::IpiImageGroundConnection::ipi_ptr() const
        IPI that we are using. 
        """
        return _geocal.IpiImageGroundConnection__ipi(self)

    @property
    def ipi(self):
        return self._ipi()

    def _band(self):
        """
        int GeoCal::IpiImageGroundConnection::band() const
        Band we are working with. 
        """
        return _geocal.IpiImageGroundConnection__band(self)

    @property
    def band(self):
        return self._band()

    def _resolution(self):
        """
        double GeoCal::IpiImageGroundConnection::resolution() const
        Resolution we step through Dem at, in meters. 
        """
        return _geocal.IpiImageGroundConnection__resolution(self)

    @property
    def resolution(self):
        return self._resolution()

    def _maximum_height(self):
        """
        double GeoCal::IpiImageGroundConnection::maximum_height() const
        Maximum height we look through Dem at. 
        """
        return _geocal.IpiImageGroundConnection__maximum_height(self)

    @property
    def maximum_height(self):
        return self._maximum_height()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.ipi,self.dem,self.image,self.title,self.resolution,self.band,self.maximum_height)

    __swig_destroy__ = _geocal.delete_IpiImageGroundConnection
IpiImageGroundConnection._ipi = new_instancemethod(_geocal.IpiImageGroundConnection__ipi,None,IpiImageGroundConnection)
IpiImageGroundConnection._band = new_instancemethod(_geocal.IpiImageGroundConnection__band,None,IpiImageGroundConnection)
IpiImageGroundConnection._resolution = new_instancemethod(_geocal.IpiImageGroundConnection__resolution,None,IpiImageGroundConnection)
IpiImageGroundConnection._maximum_height = new_instancemethod(_geocal.IpiImageGroundConnection__maximum_height,None,IpiImageGroundConnection)
IpiImageGroundConnection_swigregister = _geocal.IpiImageGroundConnection_swigregister
IpiImageGroundConnection_swigregister(IpiImageGroundConnection)

class EciTod(CartesianInertial):
    """
    This is a ECI true of date coordinate.

    This is a dynamic frame that uses the true equator and equinox of a
    particular data.

    C++ includes: eci_tod.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::EciTod::EciTod(const boost::array< double, 3 > &Pos)
        Create an Eci with the given position in meters. 
        """
        _geocal.EciTod_swiginit(self,_geocal.new_EciTod(*args))
    def reference_surface_intersect_approximate(self, *args):
        """
        boost::shared_ptr< CartesianInertial > EciTod::reference_surface_intersect_approximate(const CartesianInertialLookVector &Cl, double
        Height_reference_surface=0) const
        Find the intersection with the surface at the given height starting at
        this point and looking in the given direction.

        The intersection is done in an approximate but quicker manner.

        We find the intersection with the ellipsoid that has the given height
        added to the equatorial and polar axis. This is not the same as the
        figure with a height h above the ellipsoid (which isn't an ellipsoid),
        but for many purposes this is close enough. 
        """
        return _geocal.EciTod_reference_surface_intersect_approximate(self, *args)

    def to_eci(self, *args):
        """
        Eci EciTod::to_eci(const Time &T)

        """
        return _geocal.EciTod_to_eci(self, *args)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.position[0],self.position[1],self.position[2])

    __swig_destroy__ = _geocal.delete_EciTod
EciTod.reference_surface_intersect_approximate = new_instancemethod(_geocal.EciTod_reference_surface_intersect_approximate,None,EciTod)
EciTod.to_eci = new_instancemethod(_geocal.EciTod_to_eci,None,EciTod)
EciTod_swigregister = _geocal.EciTod_swigregister
EciTod_swigregister(EciTod)

class EciTodBurl(CartesianInertial):
    """
    This is a ECI true of date coordinate.

    This is a dynamic frame that uses the true equator and equinox of a
    particular data.

    This implementation uses Mike Burl's code. I believe EciTod is more
    accurate since it accounts for polar drift, but I'm not positive. We
    want to be able to compare between the two, so I'll put this in place.

    C++ includes: eci_tod_burl.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::EciTodBurl::EciTodBurl(const boost::array< double, 3 > &Pos)
        Create an Eci with the given position in meters. 
        """
        _geocal.EciTodBurl_swiginit(self,_geocal.new_EciTodBurl(*args))
    def reference_surface_intersect_approximate(self, *args):
        """
        boost::shared_ptr< CartesianInertial > EciTodBurl::reference_surface_intersect_approximate(const CartesianInertialLookVector &Cl, double
        Height_reference_surface=0) const
        Find the intersection with the surface at the given height starting at
        this point and looking in the given direction.

        The intersection is done in an approximate but quicker manner.

        We find the intersection with the ellipsoid that has the given height
        added to the equatorial and polar axis. This is not the same as the
        figure with a height h above the ellipsoid (which isn't an ellipsoid),
        but for many purposes this is close enough. 
        """
        return _geocal.EciTodBurl_reference_surface_intersect_approximate(self, *args)

    set_delta_ut1 = staticmethod(_geocal.EciTodBurl_set_delta_ut1)
    get_delta_ut1 = staticmethod(_geocal.EciTodBurl_get_delta_ut1)
    def __reduce__(self):
      return _new_from_init, (self.__class__, self.position[0],self.position[1],self.position[2])

    __swig_destroy__ = _geocal.delete_EciTodBurl
EciTodBurl.reference_surface_intersect_approximate = new_instancemethod(_geocal.EciTodBurl_reference_surface_intersect_approximate,None,EciTodBurl)
EciTodBurl_swigregister = _geocal.EciTodBurl_swigregister
EciTodBurl_swigregister(EciTodBurl)

def EciTodBurl_set_delta_ut1(*args):
  return _geocal.EciTodBurl_set_delta_ut1(*args)
EciTodBurl_set_delta_ut1 = _geocal.EciTodBurl_set_delta_ut1

def EciTodBurl_get_delta_ut1():
  return _geocal.EciTodBurl_get_delta_ut1()
EciTodBurl_get_delta_ut1 = _geocal.EciTodBurl_get_delta_ut1

class QuaternionCamera(Camera):
    """
    This is a simple frame camera.

    This doesn't account for any lens distortion, we model this as a
    pinhole camera. The camera has an orientation to the spacecraft frame
    by a given quaternion.

    C++ includes: quaternion_camera.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::QuaternionCamera::QuaternionCamera(boost::math::quaternion< double > frame_to_sc_q, double Number_line,
        double Number_sample, double Line_pitch, double Sample_pitch, double
        Focal_length, const FrameCoordinate &Principal_point, double
        Line_scale=1.0, double Sample_scale=1.0)
        Create a QuaternionCamera.

        The orientation of the camera to the spacecraft to given by the
        quaternion that takes frame coordinates to spacecraft coordinates. The
        size of the camera and the line pitch, sample pitch, and focal length
        are given. By convention, these are given in mm. Finally the
        Principal_point (coordinates at center) are given.

        Note that by convention the quaternion has line going in the +y
        direction and sample in the +x direction. This is different convention
        that we have used in other cameras, but matches the use for the
        initial use we have for this camera. 
        """
        _geocal.QuaternionCamera_swiginit(self,_geocal.new_QuaternionCamera(*args))
    def _focal_length(self):
        """
        double GeoCal::QuaternionCamera::focal_length() const
        Focal length, in mm. 
        """
        return _geocal.QuaternionCamera__focal_length(self)

    @property
    def focal_length(self):
        return self._focal_length()

    def _principal_point(self):
        """
        const FrameCoordinate& GeoCal::QuaternionCamera::principal_point() const
        Principal point of camera. 
        """
        return _geocal.QuaternionCamera__principal_point(self)

    @property
    def principal_point(self):
        return self._principal_point()

    def _line_pitch(self):
        """
        double GeoCal::QuaternionCamera::line_pitch() const
        CCD pitch, in mm. 
        """
        return _geocal.QuaternionCamera__line_pitch(self)

    @property
    def line_pitch(self):
        return self._line_pitch()

    def _sample_pitch(self):
        """
        double GeoCal::QuaternionCamera::sample_pitch() const
        CCD pitch, in mm. 
        """
        return _geocal.QuaternionCamera__sample_pitch(self)

    @property
    def sample_pitch(self):
        return self._sample_pitch()

    def _line_scale(self, *args):
        """
        void GeoCal::QuaternionCamera::line_scale(double Line_scale)

        """
        return _geocal.QuaternionCamera__line_scale(self, *args)

    @property
    def line_scale(self):
        return self._line_scale()

    @line_scale.setter
    def line_scale(self, value):
      self._line_scale(value)

    def _sample_scale(self, *args):
        """
        void GeoCal::QuaternionCamera::sample_scale(double Sample_scale)

        """
        return _geocal.QuaternionCamera__sample_scale(self, *args)

    @property
    def sample_scale(self):
        return self._sample_scale()

    @sample_scale.setter
    def sample_scale(self, value):
      self._sample_scale(value)

    def _frame_to_sc(self):
        """
        const boost::math::quaternion<double>& GeoCal::QuaternionCamera::frame_to_sc() const
        Frame to spacecraft quaternion. 
        """
        return _geocal.QuaternionCamera__frame_to_sc(self)

    @property
    def frame_to_sc(self):
        return self._frame_to_sc()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.frame_to_sc,self.number_line(0),self.number_sample(0),self.line_pitch,self.sample_pitch,self.focal_length,self.principal_point,self.line_scale,self.sample_scale)

    __swig_destroy__ = _geocal.delete_QuaternionCamera
QuaternionCamera._focal_length = new_instancemethod(_geocal.QuaternionCamera__focal_length,None,QuaternionCamera)
QuaternionCamera._principal_point = new_instancemethod(_geocal.QuaternionCamera__principal_point,None,QuaternionCamera)
QuaternionCamera._line_pitch = new_instancemethod(_geocal.QuaternionCamera__line_pitch,None,QuaternionCamera)
QuaternionCamera._sample_pitch = new_instancemethod(_geocal.QuaternionCamera__sample_pitch,None,QuaternionCamera)
QuaternionCamera._line_scale = new_instancemethod(_geocal.QuaternionCamera__line_scale,None,QuaternionCamera)
QuaternionCamera._sample_scale = new_instancemethod(_geocal.QuaternionCamera__sample_scale,None,QuaternionCamera)
QuaternionCamera._frame_to_sc = new_instancemethod(_geocal.QuaternionCamera__frame_to_sc,None,QuaternionCamera)
QuaternionCamera_swigregister = _geocal.QuaternionCamera_swigregister
QuaternionCamera_swigregister(QuaternionCamera)

class Refraction(object):
    """
    This calculates refraction.

    The algorithm used was take from the SDP toolkit. The original code
    was written by Peter Noerdlinger as the SDP toolkit function
    PGS_CSC_SpaceRefract. The algorithm is described in detail in
    "Theoretical Basis of the SDP Toolkit Geolocation Package for the
    ECS".

    This depends on the index of refraction of air at the surface. We
    don't actually know this. There are various approximations, and the
    toolkit uses one described in the "Theoretical Basis of the SDP
    Toolkit Geolocation Package for the ECS".

    This class allows the index of refraction to simple be given. This
    allows us to just fit for this unknown using something like a
    simultanous bundle adjustment. Note that a reasonable range of values
    is something like 1.00026 to 1.00029, so you can vary from the initial
    prediction by a few 1e-5.

    C++ includes: refraction.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        Refraction::Refraction(double Altitude, double Latitude, double Index_refraction_surface=-1)
        This sets up for a Refraction calculation.

        A representative altitude (in meters) and latitude (in degrees) is
        given. This doesn't depend very strongly on altitude and latitude, so
        unless you using widely varying points just using the center of you
        scene should be pretty much sufficient.

        The index of refraction at the surface can be supplied if desired,
        otherwise we calculate an approximate value. 
        """
        _geocal.Refraction_swiginit(self,_geocal.new_Refraction(*args))
    def _altitude(self):
        """
        double GeoCal::Refraction::altitude() const
        Altitude of reference point, in meters. 
        """
        return _geocal.Refraction__altitude(self)

    @property
    def altitude(self):
        return self._altitude()

    def _latitude(self):
        """
        double GeoCal::Refraction::latitude() const
        Latitude of reference point, in degrees. 
        """
        return _geocal.Refraction__latitude(self)

    @property
    def latitude(self):
        return self._latitude()

    def _index_refraction_surface(self, *args):
        """
        void GeoCal::Refraction::index_refraction_surface(double Index_refraction_surface)
        Set the index of refraction. 
        """
        return _geocal.Refraction__index_refraction_surface(self, *args)

    @property
    def index_refraction_surface(self):
        return self._index_refraction_surface()

    @index_refraction_surface.setter
    def index_refraction_surface(self, value):
      self._index_refraction_surface(value)

    def surface_zenith(self, *args):
        """
        double GeoCal::Refraction::surface_zenith(double Space_zenith) const
        Surface zenith angle in radians, given the space zenith angles. 
        """
        return _geocal.Refraction_surface_zenith(self, *args)

    def displacement(self, *args):
        """
        double Refraction::displacement(double Space_zenith) const
        Displacement in meters for given space zenith angle in radians. 
        """
        return _geocal.Refraction_displacement(self, *args)

    def refraction_apply(self, *args):
        """
        boost::shared_ptr< GroundCoordinate > Refraction::refraction_apply(const GroundCoordinate &Spacecraft_pos, const GroundCoordinate
        &Gc_no_refraction) const
        Apply refraction.

        We take the position of the spacecraft and the ground coordinates
        before apply refraction. This return the ground coordinates accounting
        for refraction. 
        """
        return _geocal.Refraction_refraction_apply(self, *args)

    def refraction_reverse(self, *args):
        """
        boost::shared_ptr< GroundCoordinate > Refraction::refraction_reverse(const GroundCoordinate &Spacecraft_pos, const GroundCoordinate
        &Gc_with_refraction) const
        Reverse the refraction calculation.

        This returns a ground coordinate so that when we feed it to
        refraction_apply we get back the original ground coordinate. This is
        useful when trying to go the other way, from the ground to the
        spacecraft, so we remove the effects of refraction and then continue
        with a normal orbit/camera model.

        Note for speed we don't calculate the exact reverse of
        refraction_apply, but a close approximation. For a MISR DF camera, the
        difference is only 2 cm. For most applications, the difference
        shouldn't matter. But if we have an application where this does, we'll
        want to replace this with a more exact calculation. 
        """
        return _geocal.Refraction_refraction_reverse(self, *args)

    def __str__(self):
        """
        std::string GeoCal::Printable< Refraction  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.Refraction___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.altitude,self.latitude,self.index_refraction_surface)

    __swig_destroy__ = _geocal.delete_Refraction
Refraction._altitude = new_instancemethod(_geocal.Refraction__altitude,None,Refraction)
Refraction._latitude = new_instancemethod(_geocal.Refraction__latitude,None,Refraction)
Refraction._index_refraction_surface = new_instancemethod(_geocal.Refraction__index_refraction_surface,None,Refraction)
Refraction.surface_zenith = new_instancemethod(_geocal.Refraction_surface_zenith,None,Refraction)
Refraction.displacement = new_instancemethod(_geocal.Refraction_displacement,None,Refraction)
Refraction.refraction_apply = new_instancemethod(_geocal.Refraction_refraction_apply,None,Refraction)
Refraction.refraction_reverse = new_instancemethod(_geocal.Refraction_refraction_reverse,None,Refraction)
Refraction.__str__ = new_instancemethod(_geocal.Refraction___str__,None,Refraction)
Refraction_swigregister = _geocal.Refraction_swigregister
Refraction_swigregister(Refraction)

class OrbitDataImageGroundConnection(ImageGroundConnection):
    """
    This is a ImageGroundConnection where the connection is made by
    OrbitData and a Camera.

    C++ includes: orbit_data_image_ground_connection.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::OrbitDataImageGroundConnection::OrbitDataImageGroundConnection(const boost::shared_ptr< OrbitData > &Od, const boost::shared_ptr<
        Camera > &Cam, const boost::shared_ptr< Dem > &D, const
        boost::shared_ptr< RasterImage > &Img, const std::string Title="",
        const boost::shared_ptr< Refraction > &Ref=boost::shared_ptr<
        Refraction >(), bool Include_refraction=false, double Resolution=30,
        int Band=0, double Max_height=9000)
        Constructor.

        You can optionally include a approximate refraction correction, the
        default is not to. 
        """
        _geocal.OrbitDataImageGroundConnection_swiginit(self,_geocal.new_OrbitDataImageGroundConnection(*args))
    def _image(self):
        """
        virtual boost::shared_ptr<RasterImage> GeoCal::ImageGroundConnection::image() const
        Underlying image. 
        """
        return _geocal.OrbitDataImageGroundConnection__image(self)

    def _title(self):
        """
        virtual void GeoCal::ImageGroundConnection::title(const std::string &Title)
        Set image title. 
        """
        return _geocal.OrbitDataImageGroundConnection__title(self)

    def _orbit_data(self):
        """
        const boost::shared_ptr<OrbitData>& GeoCal::OrbitDataImageGroundConnection::orbit_data_ptr() const
        Orbit data that we are using. 
        """
        return _geocal.OrbitDataImageGroundConnection__orbit_data(self)

    @property
    def orbit_data(self):
        return self._orbit_data()

    def _camera(self):
        """
        const boost::shared_ptr<Camera>& GeoCal::OrbitDataImageGroundConnection::camera_ptr() const
        Camera that we are using. 
        """
        return _geocal.OrbitDataImageGroundConnection__camera(self)

    @property
    def camera(self):
        return self._camera()

    def _resolution(self):
        """
        double GeoCal::OrbitDataImageGroundConnection::resolution() const
        Resolution in meters that we examine Dem out.

        This affects how long ground_coordinate takes to figure out. It should
        be about the resolution of the Dem 
        """
        return _geocal.OrbitDataImageGroundConnection__resolution(self)

    @property
    def resolution(self):
        return self._resolution()

    def _refraction(self):
        """
        boost::shared_ptr<Refraction> GeoCal::OrbitDataImageGroundConnection::refraction() const
        Refraction object we are using.

        May be null if we aren't including refraction. 
        """
        return _geocal.OrbitDataImageGroundConnection__refraction(self)

    @property
    def refraction(self):
        return self._refraction()

    def _band(self):
        """
        int GeoCal::OrbitDataImageGroundConnection::band() const
        Camera band we are using. 
        """
        return _geocal.OrbitDataImageGroundConnection__band(self)

    @property
    def band(self):
        return self._band()

    def _max_height(self):
        """
        int GeoCal::OrbitDataImageGroundConnection::max_height() const
        Maximum height that we expect to see in the Dem. 
        """
        return _geocal.OrbitDataImageGroundConnection__max_height(self)

    @property
    def max_height(self):
        return self._max_height()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.orbit_data,self.camera,self.dem,self.image,self.title,self.refraction,self.resolution,self.band,self.max_height)

    __swig_destroy__ = _geocal.delete_OrbitDataImageGroundConnection
OrbitDataImageGroundConnection._image = new_instancemethod(_geocal.OrbitDataImageGroundConnection__image,None,OrbitDataImageGroundConnection)
OrbitDataImageGroundConnection._title = new_instancemethod(_geocal.OrbitDataImageGroundConnection__title,None,OrbitDataImageGroundConnection)
OrbitDataImageGroundConnection._orbit_data = new_instancemethod(_geocal.OrbitDataImageGroundConnection__orbit_data,None,OrbitDataImageGroundConnection)
OrbitDataImageGroundConnection._camera = new_instancemethod(_geocal.OrbitDataImageGroundConnection__camera,None,OrbitDataImageGroundConnection)
OrbitDataImageGroundConnection._resolution = new_instancemethod(_geocal.OrbitDataImageGroundConnection__resolution,None,OrbitDataImageGroundConnection)
OrbitDataImageGroundConnection._refraction = new_instancemethod(_geocal.OrbitDataImageGroundConnection__refraction,None,OrbitDataImageGroundConnection)
OrbitDataImageGroundConnection._band = new_instancemethod(_geocal.OrbitDataImageGroundConnection__band,None,OrbitDataImageGroundConnection)
OrbitDataImageGroundConnection._max_height = new_instancemethod(_geocal.OrbitDataImageGroundConnection__max_height,None,OrbitDataImageGroundConnection)
OrbitDataImageGroundConnection_swigregister = _geocal.OrbitDataImageGroundConnection_swigregister
OrbitDataImageGroundConnection_swigregister(OrbitDataImageGroundConnection)

class HdfOrbit_EciTod_TimeAcs(Orbit):
    """
    This is an implementation of an Orbit that reads position, velocity,
    and attitude quaternion from an HDF file.

    For times that fall between the values given in the file, we
    interpolate to get the OrbitData.

    The file should have the following fields:

    <Base group>="">/Attitude/Time - natt in size, time of attitude
    measurement as doubles. <Base group>="">/Attitude/Quaternion - natt
    x 4 in size, quaternion to take same coordinate system as Position
    (e.g., ECI) <Base group>="">/Ephemeris/Time - neph in size, time of
    ephemeris measurement as doubles <Base group>="">/Ephemeris/Position
    - neph x 3 in size, position measurement as doubles in meters <Base
    group>="">/Ephemeris/Velocity - neph x 3 in size, velocity
    measurement as doubles in meter/second

    Because it is useful, we allow the type of position measurement and
    time to be changed. The measurement class is passed in, e.g., Eci, as
    is a small wrapper to give the conversion to Time.

    C++ includes: hdf_orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::HdfOrbit< PositionType, TimeCreatorType >::HdfOrbit(const std::string &Fname, const std::string &Base_group="Orbit")
        Read the given orbit data file.

        You can optional pass the base group of the HDF file, the default is
        "/Orbit" 
        """
        _geocal.HdfOrbit_EciTod_TimeAcs_swiginit(self,_geocal.new_HdfOrbit_EciTod_TimeAcs(*args))
    def _file_name(self):
        """
        const std::string& GeoCal::HdfOrbit< PositionType, TimeCreatorType >::file_name() const
        Return the file name. 
        """
        return _geocal.HdfOrbit_EciTod_TimeAcs__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def _base_group(self):
        """
        const std::string& GeoCal::HdfOrbit< PositionType, TimeCreatorType >::base_group() const
        Return the base group. 
        """
        return _geocal.HdfOrbit_EciTod_TimeAcs__base_group(self)

    @property
    def base_group(self):
        return self._base_group()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name,self.base_group)

    __swig_destroy__ = _geocal.delete_HdfOrbit_EciTod_TimeAcs
HdfOrbit_EciTod_TimeAcs._file_name = new_instancemethod(_geocal.HdfOrbit_EciTod_TimeAcs__file_name,None,HdfOrbit_EciTod_TimeAcs)
HdfOrbit_EciTod_TimeAcs._base_group = new_instancemethod(_geocal.HdfOrbit_EciTod_TimeAcs__base_group,None,HdfOrbit_EciTod_TimeAcs)
HdfOrbit_EciTod_TimeAcs_swigregister = _geocal.HdfOrbit_EciTod_TimeAcs_swigregister
HdfOrbit_EciTod_TimeAcs_swigregister(HdfOrbit_EciTod_TimeAcs)

class HdfOrbit_EciTodBurl_TimeAcs(Orbit):
    """
    This is an implementation of an Orbit that reads position, velocity,
    and attitude quaternion from an HDF file.

    For times that fall between the values given in the file, we
    interpolate to get the OrbitData.

    The file should have the following fields:

    <Base group>="">/Attitude/Time - natt in size, time of attitude
    measurement as doubles. <Base group>="">/Attitude/Quaternion - natt
    x 4 in size, quaternion to take same coordinate system as Position
    (e.g., ECI) <Base group>="">/Ephemeris/Time - neph in size, time of
    ephemeris measurement as doubles <Base group>="">/Ephemeris/Position
    - neph x 3 in size, position measurement as doubles in meters <Base
    group>="">/Ephemeris/Velocity - neph x 3 in size, velocity
    measurement as doubles in meter/second

    Because it is useful, we allow the type of position measurement and
    time to be changed. The measurement class is passed in, e.g., Eci, as
    is a small wrapper to give the conversion to Time.

    C++ includes: hdf_orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::HdfOrbit< PositionType, TimeCreatorType >::HdfOrbit(const std::string &Fname, const std::string &Base_group="Orbit")
        Read the given orbit data file.

        You can optional pass the base group of the HDF file, the default is
        "/Orbit" 
        """
        _geocal.HdfOrbit_EciTodBurl_TimeAcs_swiginit(self,_geocal.new_HdfOrbit_EciTodBurl_TimeAcs(*args))
    def _file_name(self):
        """
        const std::string& GeoCal::HdfOrbit< PositionType, TimeCreatorType >::file_name() const
        Return the file name. 
        """
        return _geocal.HdfOrbit_EciTodBurl_TimeAcs__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def _base_group(self):
        """
        const std::string& GeoCal::HdfOrbit< PositionType, TimeCreatorType >::base_group() const
        Return the base group. 
        """
        return _geocal.HdfOrbit_EciTodBurl_TimeAcs__base_group(self)

    @property
    def base_group(self):
        return self._base_group()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name,self.base_group)

    __swig_destroy__ = _geocal.delete_HdfOrbit_EciTodBurl_TimeAcs
HdfOrbit_EciTodBurl_TimeAcs._file_name = new_instancemethod(_geocal.HdfOrbit_EciTodBurl_TimeAcs__file_name,None,HdfOrbit_EciTodBurl_TimeAcs)
HdfOrbit_EciTodBurl_TimeAcs._base_group = new_instancemethod(_geocal.HdfOrbit_EciTodBurl_TimeAcs__base_group,None,HdfOrbit_EciTodBurl_TimeAcs)
HdfOrbit_EciTodBurl_TimeAcs_swigregister = _geocal.HdfOrbit_EciTodBurl_TimeAcs_swigregister
HdfOrbit_EciTodBurl_TimeAcs_swigregister(HdfOrbit_EciTodBurl_TimeAcs)

class ArgusCamera(Camera):
    """
    A model of the ARGUS camera.

    Right now, this doesn't account for any lens distortion, we model this
    as a pinhole camera. We may need to revisit this.

    C++ includes: argus_camera.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, Yaw=0, Pitch=0, Roll=0, Focal_length=400): 
        """
        ArgusCamera::ArgusCamera(double Yaw=0, double Pitch=0, double Roll=0, double Focal_length=400)
        Create a ARGUS camera.

        We read one of the image jpeg files to get camera metadata used to
        describe the camera. Yaw, Pitch and Roll are in degrees, Focal_length
        is in mm. 
        """
        _geocal.ArgusCamera_swiginit(self,_geocal.new_ArgusCamera(Yaw, Pitch, Roll, Focal_length))
    def _focal_length(self):
        """
        double GeoCal::ArgusCamera::focal_length() const
        Focal length, in mm. 
        """
        return _geocal.ArgusCamera__focal_length(self)

    @property
    def focal_length(self):
        return self._focal_length()

    def _line_pitch(self):
        """
        double GeoCal::ArgusCamera::line_pitch() const
        CCD pitch, in mm. 
        """
        return _geocal.ArgusCamera__line_pitch(self)

    @property
    def line_pitch(self):
        return self._line_pitch()

    def _sample_pitch(self):
        """
        double GeoCal::ArgusCamera::sample_pitch() const
        CCD pitch, in mm. 
        """
        return _geocal.ArgusCamera__sample_pitch(self)

    @property
    def sample_pitch(self):
        return self._sample_pitch()

    def _roll(self):
        """
        double GeoCal::ArgusCamera::roll() const
        Roll angle, in degrees. 
        """
        return _geocal.ArgusCamera__roll(self)

    @property
    def roll(self):
        return self._roll()

    def _pitch(self):
        """
        double GeoCal::ArgusCamera::pitch() const
        Pitch angle, in degrees. 
        """
        return _geocal.ArgusCamera__pitch(self)

    @property
    def pitch(self):
        return self._pitch()

    def _yaw(self):
        """
        double GeoCal::ArgusCamera::yaw() const
        Yaw angle, in degrees. 
        """
        return _geocal.ArgusCamera__yaw(self)

    @property
    def yaw(self):
        return self._yaw()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.yaw,self.pitch,self.roll,self.focal_length)

    __swig_destroy__ = _geocal.delete_ArgusCamera
ArgusCamera._focal_length = new_instancemethod(_geocal.ArgusCamera__focal_length,None,ArgusCamera)
ArgusCamera._line_pitch = new_instancemethod(_geocal.ArgusCamera__line_pitch,None,ArgusCamera)
ArgusCamera._sample_pitch = new_instancemethod(_geocal.ArgusCamera__sample_pitch,None,ArgusCamera)
ArgusCamera._roll = new_instancemethod(_geocal.ArgusCamera__roll,None,ArgusCamera)
ArgusCamera._pitch = new_instancemethod(_geocal.ArgusCamera__pitch,None,ArgusCamera)
ArgusCamera._yaw = new_instancemethod(_geocal.ArgusCamera__yaw,None,ArgusCamera)
ArgusCamera_swigregister = _geocal.ArgusCamera_swigregister
ArgusCamera_swigregister(ArgusCamera)

class ArgusOrbitData(AircraftOrbitData):
    """
    This is a single ARGUS navigation file record.

    In addition to the normal things in an OrbitData class, this contains
    some other metadata. This matches what is stored in the ARGUS CSV
    navigation file. The additional information is the file name of the
    JPEG image file collected by the camera and the camera number.

    Note that we don't have access to a direct measurement of the
    velocity. Rather than trying to do some clever estimate of the
    velocity, we just set it to 0.

    C++ includes: argus_orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::ArgusOrbitData::ArgusOrbitData(const Time &Tm, const std::string &File_name, int Camera_number,
        const Geodetic &Position, const boost::array< double, 3 > &Vel_fixed,
        double Roll, double Pitch, double Heading)
        Constructor. 
        """
        _geocal.ArgusOrbitData_swiginit(self,_geocal.new_ArgusOrbitData(*args))
    def save_ortho(self, *args):
        """
        void ArgusOrbitData::save_ortho(const MapInfo &Mi, const Camera &Cam, const Dem &D, const std::string
        &Fname, const std::string &Type, int Border=10, int Grid_spacing=1)
        const
        Save an three color orthorectified image to the given file.

        The type should be "img", "tif", "tifjpeg" or "vicar" ("tif"
        uses LZW lossless compression, "tifjpeg" uses jpeg lossy
        compression).

        The MapInfo governs the map projection and pixel size used. We however
        only write out the subset of MapInfo that is needed to cover the
        footprint of this orthorectified image.

        To speed up the processing, you can give a Grid_spacing > 1. We
        calculate the position in the input image exactly at the Grid_spacing
        locations, and do a bilinear interpolation in between. If the
        Grid_spacing is 1, then no interpolation is done.

        This is a somewhat specific function, but I had similar functionality
        in Ruby code working with ARGUS data. Ruby is a nice language, but
        just sucks at garbage collection. So we move this functionality into
        this routine where we can control the lifetimes of all of the data
        involved. 
        """
        return _geocal.ArgusOrbitData_save_ortho(self, *args)

    def add_ortho_to_image(self, *args):
        """
        void ArgusOrbitData::add_ortho_to_image(const boost::shared_ptr< RasterImage > &M1, const boost::shared_ptr<
        RasterImage > &M2, const boost::shared_ptr< RasterImage > &M3, const
        Camera &Cam, const Dem &D, int Border=10) const
        Add three color orthorectified image to an existing set of three
        images.

        We currently don't try to do any feathering, instead we simply add
        imagery if it is currently fill (value of 0), or crop the data if it
        already has data. 
        """
        return _geocal.ArgusOrbitData_add_ortho_to_image(self, *args)

    def mosaic(*args):
        """
        void ArgusOrbitData::mosaic(const std::vector< boost::shared_ptr< ArgusOrbitData > > &Od, const
        std::vector< boost::shared_ptr< Camera > > &Cam, const Dem &D, const
        MapInfo &Mi, const std::string &Fname, const std::string &Type, int
        Border=10)
        Generate a mosaic that fits the given MapInfo, sampling each of the
        orbit data.

        We save this to the given file, with the given Type. 
        """
        return _geocal.ArgusOrbitData_mosaic(*args)

    mosaic = staticmethod(mosaic)
    def image(self, band=1):
        """
        GdalRasterImage ArgusOrbitData::image(int band=1) const
        Access image for the given band.

        The band is 1 based, because that is what Gdal uses. 
        """
        return _geocal.ArgusOrbitData_image(self, band)

    def _file_name(self):
        """
        const std::string& GeoCal::ArgusOrbitData::file_name() const
        File with JPEG data. 
        """
        return _geocal.ArgusOrbitData__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def _camera_number(self):
        """
        int GeoCal::ArgusOrbitData::camera_number() const
        Camera number. This is 1 - 13. 
        """
        return _geocal.ArgusOrbitData__camera_number(self)

    @property
    def camera_number(self):
        return self._camera_number()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.time,self.file_name,self.camera_number,self.position_geodetic,self.vector_cf,self.roll,self.pitch,self.heading)

    __swig_destroy__ = _geocal.delete_ArgusOrbitData
ArgusOrbitData.save_ortho = new_instancemethod(_geocal.ArgusOrbitData_save_ortho,None,ArgusOrbitData)
ArgusOrbitData.add_ortho_to_image = new_instancemethod(_geocal.ArgusOrbitData_add_ortho_to_image,None,ArgusOrbitData)
ArgusOrbitData.image = new_instancemethod(_geocal.ArgusOrbitData_image,None,ArgusOrbitData)
ArgusOrbitData._file_name = new_instancemethod(_geocal.ArgusOrbitData__file_name,None,ArgusOrbitData)
ArgusOrbitData._camera_number = new_instancemethod(_geocal.ArgusOrbitData__camera_number,None,ArgusOrbitData)
ArgusOrbitData_swigregister = _geocal.ArgusOrbitData_swigregister
ArgusOrbitData_swigregister(ArgusOrbitData)

def ArgusOrbitData_mosaic(*args):
  """
    void ArgusOrbitData::mosaic(const std::vector< boost::shared_ptr< ArgusOrbitData > > &Od, const
    std::vector< boost::shared_ptr< Camera > > &Cam, const Dem &D, const
    MapInfo &Mi, const std::string &Fname, const std::string &Type, int
    Border=10)
    Generate a mosaic that fits the given MapInfo, sampling each of the
    orbit data.

    We save this to the given file, with the given Type. 
    """
  return _geocal.ArgusOrbitData_mosaic(*args)

class ArgusOrbit(OrbitQuaternionList):
    """
    This read a CSV navigation file and uses it to generate a Orbit.

    We access the data in two ways. The first is the standard time index,
    giving a OrbitData for that time (interpolating if needed). The second
    is by "row" and camera number. All the orbit data for a given row
    were acquired at nearly the same time. A row contains data for 1 or
    more cameras - once the instrument is fully working a row has data for
    cameras 1 through 13. We return a ArgusOrbitData, which in addition to
    having the normal OrbitData stuff has additional metadata information.

    C++ includes: argus_orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        ArgusOrbit::ArgusOrbit(const std::string &Fname)
        Open the given file and use it to provide Orbit information.

        This file should be a CSV file containing one record per line, with
        the fields "File,Camera,Time,Lat,Lon,Alt,Roll,Pitch,Heading". The
        first line is assumed to be a header, and is discarded. The second
        line is the epoch that the times are measured relative to.

        Orbit data, indexed by the Time. This is a multimap because it is
        entirely possible to have multiple entries in the navigation file with
        the same time, e.g., two cameras collect data at the same time. 
        """
        _geocal.ArgusOrbit_swiginit(self,_geocal.new_ArgusOrbit(*args))
    def focal_length(self, *args):
        """
        double ArgusOrbit::focal_length(int camera_num) const
        This finds the first row with orbit and image data for the given
        camera.

        We then read the metadata from the image do determine the reported
        focal length. If we don't have any orbit or image data for the camera,
        we return -1. 
        """
        return _geocal.ArgusOrbit_focal_length(self, *args)

    def _number_row(self):
        """
        int GeoCal::ArgusOrbit::number_row() const
        Number of rows of data we have. 
        """
        return _geocal.ArgusOrbit__number_row(self)

    @property
    def number_row(self):
        return self._number_row()

    def nav(self, *args):
        """
        boost::shared_ptr< ArgusOrbitData > ArgusOrbit::nav(int row, int camera_num) const
        Return the ArgusOrbitData for the given row and camera, or if we don't
        have any data there return a null pointer. 
        """
        return _geocal.ArgusOrbit_nav(self, *args)

    def _file_name(self):
        """
        const std::string& GeoCal::ArgusOrbit::file_name() const

        """
        return _geocal.ArgusOrbit__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name)

    __swig_destroy__ = _geocal.delete_ArgusOrbit
ArgusOrbit.focal_length = new_instancemethod(_geocal.ArgusOrbit_focal_length,None,ArgusOrbit)
ArgusOrbit._number_row = new_instancemethod(_geocal.ArgusOrbit__number_row,None,ArgusOrbit)
ArgusOrbit.nav = new_instancemethod(_geocal.ArgusOrbit_nav,None,ArgusOrbit)
ArgusOrbit._file_name = new_instancemethod(_geocal.ArgusOrbit__file_name,None,ArgusOrbit)
ArgusOrbit_swigregister = _geocal.ArgusOrbit_swigregister
ArgusOrbit_swigregister(ArgusOrbit)

class Vector_ArgusOrbitData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal.Vector_ArgusOrbitData_swiginit(self,_geocal.new_Vector_ArgusOrbitData(*args))
    __swig_destroy__ = _geocal.delete_Vector_ArgusOrbitData
Vector_ArgusOrbitData.iterator = new_instancemethod(_geocal.Vector_ArgusOrbitData_iterator,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.__nonzero__ = new_instancemethod(_geocal.Vector_ArgusOrbitData___nonzero__,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.__bool__ = new_instancemethod(_geocal.Vector_ArgusOrbitData___bool__,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.__len__ = new_instancemethod(_geocal.Vector_ArgusOrbitData___len__,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.pop = new_instancemethod(_geocal.Vector_ArgusOrbitData_pop,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.__getslice__ = new_instancemethod(_geocal.Vector_ArgusOrbitData___getslice__,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.__setslice__ = new_instancemethod(_geocal.Vector_ArgusOrbitData___setslice__,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.__delslice__ = new_instancemethod(_geocal.Vector_ArgusOrbitData___delslice__,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.__delitem__ = new_instancemethod(_geocal.Vector_ArgusOrbitData___delitem__,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.__getitem__ = new_instancemethod(_geocal.Vector_ArgusOrbitData___getitem__,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.__setitem__ = new_instancemethod(_geocal.Vector_ArgusOrbitData___setitem__,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.append = new_instancemethod(_geocal.Vector_ArgusOrbitData_append,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.empty = new_instancemethod(_geocal.Vector_ArgusOrbitData_empty,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.size = new_instancemethod(_geocal.Vector_ArgusOrbitData_size,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.clear = new_instancemethod(_geocal.Vector_ArgusOrbitData_clear,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.swap = new_instancemethod(_geocal.Vector_ArgusOrbitData_swap,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.get_allocator = new_instancemethod(_geocal.Vector_ArgusOrbitData_get_allocator,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.begin = new_instancemethod(_geocal.Vector_ArgusOrbitData_begin,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.end = new_instancemethod(_geocal.Vector_ArgusOrbitData_end,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.rbegin = new_instancemethod(_geocal.Vector_ArgusOrbitData_rbegin,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.rend = new_instancemethod(_geocal.Vector_ArgusOrbitData_rend,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.pop_back = new_instancemethod(_geocal.Vector_ArgusOrbitData_pop_back,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.erase = new_instancemethod(_geocal.Vector_ArgusOrbitData_erase,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.push_back = new_instancemethod(_geocal.Vector_ArgusOrbitData_push_back,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.front = new_instancemethod(_geocal.Vector_ArgusOrbitData_front,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.back = new_instancemethod(_geocal.Vector_ArgusOrbitData_back,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.assign = new_instancemethod(_geocal.Vector_ArgusOrbitData_assign,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.resize = new_instancemethod(_geocal.Vector_ArgusOrbitData_resize,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.insert = new_instancemethod(_geocal.Vector_ArgusOrbitData_insert,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.reserve = new_instancemethod(_geocal.Vector_ArgusOrbitData_reserve,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData.capacity = new_instancemethod(_geocal.Vector_ArgusOrbitData_capacity,None,Vector_ArgusOrbitData)
Vector_ArgusOrbitData_swigregister = _geocal.Vector_ArgusOrbitData_swigregister
Vector_ArgusOrbitData_swigregister(Vector_ArgusOrbitData)

class IbisColumn_byte(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _geocal.IbisColumn_byte_ibis_file(self)

    def column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _geocal.IbisColumn_byte_column_index(self)

    def size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _geocal.IbisColumn_byte_size_byte(self)

    def __str__(self):
        """
        std::string GeoCal::Printable< IbisColumnBase  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.IbisColumn_byte___str__(self)

    data = _swig_property(_geocal.IbisColumn_byte_data_get, _geocal.IbisColumn_byte_data_set)
    update = _swig_property(_geocal.IbisColumn_byte_update_get, _geocal.IbisColumn_byte_update_set)
    __swig_destroy__ = _geocal.delete_IbisColumn_byte
IbisColumn_byte.ibis_file = new_instancemethod(_geocal.IbisColumn_byte_ibis_file,None,IbisColumn_byte)
IbisColumn_byte.column_index = new_instancemethod(_geocal.IbisColumn_byte_column_index,None,IbisColumn_byte)
IbisColumn_byte.size_byte = new_instancemethod(_geocal.IbisColumn_byte_size_byte,None,IbisColumn_byte)
IbisColumn_byte.__str__ = new_instancemethod(_geocal.IbisColumn_byte___str__,None,IbisColumn_byte)
IbisColumn_byte_swigregister = _geocal.IbisColumn_byte_swigregister
IbisColumn_byte_swigregister(IbisColumn_byte)

class IbisColumn_half(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _geocal.IbisColumn_half_ibis_file(self)

    def column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _geocal.IbisColumn_half_column_index(self)

    def size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _geocal.IbisColumn_half_size_byte(self)

    def __str__(self):
        """
        std::string GeoCal::Printable< IbisColumnBase  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.IbisColumn_half___str__(self)

    data = _swig_property(_geocal.IbisColumn_half_data_get, _geocal.IbisColumn_half_data_set)
    update = _swig_property(_geocal.IbisColumn_half_update_get, _geocal.IbisColumn_half_update_set)
    __swig_destroy__ = _geocal.delete_IbisColumn_half
IbisColumn_half.ibis_file = new_instancemethod(_geocal.IbisColumn_half_ibis_file,None,IbisColumn_half)
IbisColumn_half.column_index = new_instancemethod(_geocal.IbisColumn_half_column_index,None,IbisColumn_half)
IbisColumn_half.size_byte = new_instancemethod(_geocal.IbisColumn_half_size_byte,None,IbisColumn_half)
IbisColumn_half.__str__ = new_instancemethod(_geocal.IbisColumn_half___str__,None,IbisColumn_half)
IbisColumn_half_swigregister = _geocal.IbisColumn_half_swigregister
IbisColumn_half_swigregister(IbisColumn_half)

class IbisColumn_full(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _geocal.IbisColumn_full_ibis_file(self)

    def column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _geocal.IbisColumn_full_column_index(self)

    def size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _geocal.IbisColumn_full_size_byte(self)

    def __str__(self):
        """
        std::string GeoCal::Printable< IbisColumnBase  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.IbisColumn_full___str__(self)

    data = _swig_property(_geocal.IbisColumn_full_data_get, _geocal.IbisColumn_full_data_set)
    update = _swig_property(_geocal.IbisColumn_full_update_get, _geocal.IbisColumn_full_update_set)
    __swig_destroy__ = _geocal.delete_IbisColumn_full
IbisColumn_full.ibis_file = new_instancemethod(_geocal.IbisColumn_full_ibis_file,None,IbisColumn_full)
IbisColumn_full.column_index = new_instancemethod(_geocal.IbisColumn_full_column_index,None,IbisColumn_full)
IbisColumn_full.size_byte = new_instancemethod(_geocal.IbisColumn_full_size_byte,None,IbisColumn_full)
IbisColumn_full.__str__ = new_instancemethod(_geocal.IbisColumn_full___str__,None,IbisColumn_full)
IbisColumn_full_swigregister = _geocal.IbisColumn_full_swigregister
IbisColumn_full_swigregister(IbisColumn_full)

class IbisColumn_float(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _geocal.IbisColumn_float_ibis_file(self)

    def column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _geocal.IbisColumn_float_column_index(self)

    def size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _geocal.IbisColumn_float_size_byte(self)

    def __str__(self):
        """
        std::string GeoCal::Printable< IbisColumnBase  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.IbisColumn_float___str__(self)

    data = _swig_property(_geocal.IbisColumn_float_data_get, _geocal.IbisColumn_float_data_set)
    update = _swig_property(_geocal.IbisColumn_float_update_get, _geocal.IbisColumn_float_update_set)
    __swig_destroy__ = _geocal.delete_IbisColumn_float
IbisColumn_float.ibis_file = new_instancemethod(_geocal.IbisColumn_float_ibis_file,None,IbisColumn_float)
IbisColumn_float.column_index = new_instancemethod(_geocal.IbisColumn_float_column_index,None,IbisColumn_float)
IbisColumn_float.size_byte = new_instancemethod(_geocal.IbisColumn_float_size_byte,None,IbisColumn_float)
IbisColumn_float.__str__ = new_instancemethod(_geocal.IbisColumn_float___str__,None,IbisColumn_float)
IbisColumn_float_swigregister = _geocal.IbisColumn_float_swigregister
IbisColumn_float_swigregister(IbisColumn_float)

class IbisColumn_double(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _geocal.IbisColumn_double_ibis_file(self)

    def column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _geocal.IbisColumn_double_column_index(self)

    def size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _geocal.IbisColumn_double_size_byte(self)

    def __str__(self):
        """
        std::string GeoCal::Printable< IbisColumnBase  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.IbisColumn_double___str__(self)

    data = _swig_property(_geocal.IbisColumn_double_data_get, _geocal.IbisColumn_double_data_set)
    update = _swig_property(_geocal.IbisColumn_double_update_get, _geocal.IbisColumn_double_update_set)
    __swig_destroy__ = _geocal.delete_IbisColumn_double
IbisColumn_double.ibis_file = new_instancemethod(_geocal.IbisColumn_double_ibis_file,None,IbisColumn_double)
IbisColumn_double.column_index = new_instancemethod(_geocal.IbisColumn_double_column_index,None,IbisColumn_double)
IbisColumn_double.size_byte = new_instancemethod(_geocal.IbisColumn_double_size_byte,None,IbisColumn_double)
IbisColumn_double.__str__ = new_instancemethod(_geocal.IbisColumn_double___str__,None,IbisColumn_double)
IbisColumn_double_swigregister = _geocal.IbisColumn_double_swigregister
IbisColumn_double_swigregister(IbisColumn_double)

class IbisColumn_string(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _geocal.IbisColumn_string_ibis_file(self)

    def column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _geocal.IbisColumn_string_column_index(self)

    def size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _geocal.IbisColumn_string_size_byte(self)

    def __str__(self):
        """
        std::string GeoCal::Printable< IbisColumnBase  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.IbisColumn_string___str__(self)

    data = _swig_property(_geocal.IbisColumn_string_data_get, _geocal.IbisColumn_string_data_set)
    update = _swig_property(_geocal.IbisColumn_string_update_get, _geocal.IbisColumn_string_update_set)
    __swig_destroy__ = _geocal.delete_IbisColumn_string
IbisColumn_string.ibis_file = new_instancemethod(_geocal.IbisColumn_string_ibis_file,None,IbisColumn_string)
IbisColumn_string.column_index = new_instancemethod(_geocal.IbisColumn_string_column_index,None,IbisColumn_string)
IbisColumn_string.size_byte = new_instancemethod(_geocal.IbisColumn_string_size_byte,None,IbisColumn_string)
IbisColumn_string.__str__ = new_instancemethod(_geocal.IbisColumn_string___str__,None,IbisColumn_string)
IbisColumn_string_swigregister = _geocal.IbisColumn_string_swigregister
IbisColumn_string_swigregister(IbisColumn_string)

class IbisFile(object):
    """
    This provides read and write for a IBIS file.

    IBIS is VICAR format used for tabulating raster format data -
    basically it is a table. This is used to interact with existing VICAR
    routines.

    The ASCII column type is a bit of a special case. For IBIS files, the
    ASCII column type is a fixed number of characters. We access this a
    std::string type. If you attempt to write a string that is too large
    for a column, then we silently truncate the string. Alternatively, we
    could have triggered an error in that case, but after thinking about
    it truncating seemed like the better choice. We can revisit this
    decision if it becomes clear that triggering an error would be better.

    As an implementation detail, the class VicarFile and IbisFile need to
    coordinate in translating file names to unit numbers since the same
    underlying Vicar routine zvunit is used by both. We arbitrarily have
    VicarFile handle this, and IbisFile accesses VicarFile when it needs
    to do this.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    READ = _geocal.IbisFile_READ
    WRITE = _geocal.IbisFile_WRITE
    UPDATE = _geocal.IbisFile_UPDATE
    VICAR_BYTE = _geocal.IbisFile_VICAR_BYTE
    VICAR_HALF = _geocal.IbisFile_VICAR_HALF
    VICAR_FULL = _geocal.IbisFile_VICAR_FULL
    VICAR_FLOAT = _geocal.IbisFile_VICAR_FLOAT
    VICAR_DOUBLE = _geocal.IbisFile_VICAR_DOUBLE
    VICAR_ASCII = _geocal.IbisFile_VICAR_ASCII
    def __init__(self, *args): 
        """
        IbisFile::IbisFile(const std::string &Fname, int Number_row, const std::vector<
        std::string > &Format, const std::string &Organization="COLUMN")
        Create a new IBIS file.

        We pass in the number of rows and the format for each column. The
        format is given as a list of strings, with each string being one of
        the format types taken by the IBIS library - "BYTE", "HALF",
        "FULL", "REAL", "DOUB", "Ann" (e.g., "A10" for 10 character
        ASCII). The organization of the file can be given as "COLUMN" or
        "ROW". 
        """
        _geocal.IbisFile_swiginit(self,_geocal.new_IbisFile(*args))
    def _access(self):
        """
        access_type GeoCal::IbisFile::access() const
        Access type of file. 
        """
        return _geocal.IbisFile__access(self)

    @property
    def access(self):
        return self._access()

    def close(self):
        """
        void IbisFile::close()
        Close a file.

        You don't normally need to call this directly, it is done by the
        destructor. But it is useful to have for use by Ruby. 
        """
        return _geocal.IbisFile_close(self)

    def column_data_type(self, *args):
        """
        data_type GeoCal::IbisFile::column_data_type(int I) const
        Data type for given column.

        Note that this is 0-based rather than 1-based. 
        """
        return _geocal.IbisFile_column_data_type(self, *args)

    def _file_name(self):
        """
        const std::string& GeoCal::IbisFile::file_name() const
        File name. 
        """
        return _geocal.IbisFile__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def _ibis_fh(self):
        """
        int IbisFile::ibis_fh() const
        IBIS file handle number used in IBIS calls. 
        """
        return _geocal.IbisFile__ibis_fh(self)

    @property
    def ibis_fh(self):
        return self._ibis_fh()

    def _number_row(self):
        """
        int GeoCal::IbisFile::number_row() const
        Number of rows in the file. 
        """
        return _geocal.IbisFile__number_row(self)

    @property
    def number_row(self):
        return self._number_row()

    def _number_col(self):
        """
        int GeoCal::IbisFile::number_col() const
        Number of columns in the file. 
        """
        return _geocal.IbisFile__number_col(self)

    @property
    def number_col(self):
        return self._number_col()

    def _unit(self):
        """
        int GeoCal::IbisFile::unit() const
        Unit number for VicarFile. 
        """
        return _geocal.IbisFile__unit(self)

    @property
    def unit(self):
        return self._unit()

    def flush(self):
        """
        void IbisFile::flush()
        Flush data to disk, including any changes.

        This is automatically called by the destructor. 
        """
        return _geocal.IbisFile_flush(self)

    def __str__(self):
        """
        std::string GeoCal::Printable< IbisFile  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.IbisFile___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name,self.access)

    def __getitem__(self, index):
      return self.column(index[1])[index[0]]

    def column(self, cindex):
        '''This return a numpy.array of whatever type the given column is. This
        reads all the data.'''
        t = self.column_data_type(cindex)
        if(t == IbisFile.VICAR_BYTE):
            return np.array(self.column_byte(cindex).data)
        elif(t == IbisFile.VICAR_HALF):
            return np.array(self.column_half(cindex).data)
        elif(t == IbisFile.VICAR_FULL):
            return np.array(self.column_full(cindex).data)
        elif(t == IbisFile.VICAR_FLOAT):
            return np.array(self.column_float(cindex).data)
        elif(t == IbisFile.VICAR_DOUBLE):
            return np.array(self.column_double(cindex).data)
        elif(t == IbisFile.VICAR_STRING):
            return np.array(self.column_string(cindex).data)
        else:
            raise "Unrecognized type %d" % t

    __swig_destroy__ = _geocal.delete_IbisFile
IbisFile._access = new_instancemethod(_geocal.IbisFile__access,None,IbisFile)
IbisFile.close = new_instancemethod(_geocal.IbisFile_close,None,IbisFile)
IbisFile.column_data_type = new_instancemethod(_geocal.IbisFile_column_data_type,None,IbisFile)
IbisFile._file_name = new_instancemethod(_geocal.IbisFile__file_name,None,IbisFile)
IbisFile._ibis_fh = new_instancemethod(_geocal.IbisFile__ibis_fh,None,IbisFile)
IbisFile._number_row = new_instancemethod(_geocal.IbisFile__number_row,None,IbisFile)
IbisFile._number_col = new_instancemethod(_geocal.IbisFile__number_col,None,IbisFile)
IbisFile._unit = new_instancemethod(_geocal.IbisFile__unit,None,IbisFile)
IbisFile.flush = new_instancemethod(_geocal.IbisFile_flush,None,IbisFile)
IbisFile.__str__ = new_instancemethod(_geocal.IbisFile___str__,None,IbisFile)
IbisFile.column_byte = new_instancemethod(_geocal.IbisFile_column_byte,None,IbisFile)
IbisFile.column_half = new_instancemethod(_geocal.IbisFile_column_half,None,IbisFile)
IbisFile.column_full = new_instancemethod(_geocal.IbisFile_column_full,None,IbisFile)
IbisFile.column_float = new_instancemethod(_geocal.IbisFile_column_float,None,IbisFile)
IbisFile.column_double = new_instancemethod(_geocal.IbisFile_column_double,None,IbisFile)
IbisFile.column_string = new_instancemethod(_geocal.IbisFile_column_string,None,IbisFile)
IbisFile_swigregister = _geocal.IbisFile_swigregister
IbisFile_swigregister(IbisFile)

class QuickBirdCamera(PushBroomCamera):
    """
    This class models a the QuickBird camera.

    It is used to convert ScLookVector to FrameCoordinate and vice versa.

    The QuickBird camera is described by metadata supplied with the
    QuickBird data, a ".GEO" file. This is potentially dynamic, and
    potentially accounts for nonlinearities in the optics. However, in
    practice all of the GEO file we have are exactly the same, and all the
    nonlinear terms are set to 0. I'm not sure if this is because the
    camera really is very stable and the optics very linear, or just that
    DigitalGlobe didn't do a very good job at geometric camera
    calibration. In any case, rather than reading in this file we just
    hardwire the coefficients into this class. This is something we can
    revisit in the future if needed.

    This model is for the Panchromatic band only. We could easily extend
    this to other bands, but right now we only work with the Panchromatic
    data.

    C++ includes: quickbird_camera.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        """
        QuickBirdCamera::QuickBirdCamera()
        Constructor.

        At this point, all of the camera coefficients are hardwired in this
        class. We can change this in the future if needed. 
        """
        _geocal.QuickBirdCamera_swiginit(self,_geocal.new_QuickBirdCamera())
    __swig_destroy__ = _geocal.delete_QuickBirdCamera
    def __reduce__(self):
      return _new_from_init, (self.__class__,)
      
QuickBirdCamera_swigregister = _geocal.QuickBirdCamera_swigregister
QuickBirdCamera_swigregister(QuickBirdCamera)

class SpotCamera(PushBroomCamera):
    """
    This class models the SPOT camera.

    The camera parameters are given by an DIMAP file. This file is an XML
    file format. You can find documentation for this format
    athttp://www.spot.com/web/SICORP/452-sicorp-the-dimap-format.php.

    We don't actually read this file format. XML is a bit of a pain to
    deal with in C++, and is much easier to process in Ruby. So we set up
    an interface that just takes the PSI_X and PSI_Y values for each
    pixel. The Afids class Dimap processes the XML file and can use that
    to create an instance of this class.

    The various angles and so forth are described in the "SPOT Geometry
    Handbook", available athttp://www.spotimage.com/automne_modules_files
    /standard/public/p229_0b
    9c0d94a22e77aac09df2b360c73073SPOT_Geometry_Handbook.pdf

    C++ includes: spot_camera.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        SpotCamera::SpotCamera(const std::vector< double > &Psi_x, const std::vector< double >
        &Psi_y)
        Create a spot camera with the given PSI angles.

        Psi_x and Psi_y need to be equal in size, and have at least two
        values.

        The angles should be in radians.

        We require that Psi_y be strictly increasing. 
        """
        _geocal.SpotCamera_swiginit(self,_geocal.new_SpotCamera(*args))
    def _psi_x(self):
        """
        const std::vector<double> GeoCal::SpotCamera::psi_x() const

        """
        return _geocal.SpotCamera__psi_x(self)

    @property
    def psi_x(self):
        return self._psi_x()

    def _psi_y(self):
        """
        const std::vector<double> GeoCal::SpotCamera::psi_y() const

        """
        return _geocal.SpotCamera__psi_y(self)

    @property
    def psi_y(self):
        return self._psi_y()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.psi_x,self.psi_y)

    __swig_destroy__ = _geocal.delete_SpotCamera
SpotCamera._psi_x = new_instancemethod(_geocal.SpotCamera__psi_x,None,SpotCamera)
SpotCamera._psi_y = new_instancemethod(_geocal.SpotCamera__psi_y,None,SpotCamera)
SpotCamera_swigregister = _geocal.SpotCamera_swigregister
SpotCamera_swigregister(SpotCamera)

class SpotOrbit(Orbit):
    """
    This class models the SPOT orbit.

    The orbit parameters are given by an DIMAP file. This file is an XML
    file format. You can find documentation for this format
    athttp://www.spot.com/web/SICORP/452-sicorp-the-dimap-format.php.

    We don't actually read this file format. XML is a bit of a pain to
    deal with in C++, and is much easier to process in Ruby. So we set up
    an interface that just takes the Ephemeris and Attitude measurements.
    The Afids class Dimap processes the XML file and can use that to
    create an instance of this class.

    The various angles and so forth are described in the "SPOT Geometry
    Handbook", available athttp://www.spotimage.com/automne_modules_files
    /standard/public/p229_0b
    9c0d94a22e77aac09df2b360c73073SPOT_Geometry_Handbook.pdf

    A note for a developer working with this class. The definition of
    space craft and orbital coordinate used internally has a different
    sign convention than we've used on other instruments such as MISR.

    We use the conventions spelled out in the "SPOT Geometry Handbook"
    consistently in this class, even though this is different than what is
    used in the MISR ATB. In particular, the Z axis points from earth
    center to spacecraft, not spacecraft to earth center as we've used on
    MISR. This is all accounted for by this class, for the outside user
    everything works as expected. But if you are working internally on
    this class this might seem strange.

    Note also that according to the "SPOT Geometry Handbook" the
    reported attitudes are relative to -X, -Y, and Z axis. This means that
    pitch and roll (but not yaw) have the opposite sign of what you would
    expect. The Ypr given to this routine should match what is supplied by
    SPOT in its DIMAP file - we account for the strange sign in this
    class.

    C++ includes: spot_orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        SpotOrbit::SpotOrbit(const std::vector< Time > &Ephemeris_time, const blitz::Array<
        double, 2 > &Ephemeris, const std::vector< Time > &Attitude_time,
        const blitz::Array< double, 2 > &Ypr)
        Constructor.

        Parameters:
        -----------

        Ephemeris_time:   Time of each ephemeris point

        Ephemeris:  Ephemeris at each time. This is a number_eph_time x 6
        array. Each row has the position x, y, z and velocity x, y, z. This is
        in meters and meter/second, in ECR coordinates.

        Attitude_time:   Time of each attitude point.

        Ypr:  Attitude. This is a number_att_time x 3 array. Each row has the
        yaw, pitch and roll. This is in radians. This is YPR reported by SPOT
        in the DIMAP file, and uses the conventions described in "SPOT
        Geometry Handbook" 
        """
        _geocal.SpotOrbit_swiginit(self,_geocal.new_SpotOrbit(*args))
    __swig_destroy__ = _geocal.delete_SpotOrbit
SpotOrbit_swigregister = _geocal.SpotOrbit_swigregister
SpotOrbit_swigregister(SpotOrbit)

class QuickBirdEphemeris(object):
    """
    This is a low level class that reads a Quickbird ephemeris file.

    You probably don't want to use this directly, but rather use the
    QuickBirdOrbit

    C++ includes: quickbird_orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::QuickBirdEphemeris::QuickBirdEphemeris(const std::string &Fname)
        Read the quickbird ephemeris file. 
        """
        _geocal.QuickBirdEphemeris_swiginit(self,_geocal.new_QuickBirdEphemeris(*args))
    def _min_time(self):
        """
        Time GeoCal::QuickBirdFile< D >::min_time() const
        Start time of data. 
        """
        return _geocal.QuickBirdEphemeris__min_time(self)

    @property
    def min_time(self):
        return self._min_time()

    def _max_time(self):
        """
        Time GeoCal::QuickBirdFile< D >::max_time() const
        End time of data. 
        """
        return _geocal.QuickBirdEphemeris__max_time(self)

    @property
    def max_time(self):
        return self._max_time()

    def _time_spacing(self):
        """
        double GeoCal::QuickBirdFile< D >::time_spacing() const
        Spacing in seconds between points. 
        """
        return _geocal.QuickBirdEphemeris__time_spacing(self)

    @property
    def time_spacing(self):
        return self._time_spacing()

    def _ephemeris(self):
        """
        const std::vector<boost::array<double, 12> >& GeoCal::QuickBirdEphemeris::ephemeris() const
        Ephemeris data.

        This as 12 numbers in each entry. The first 3 are the X, Y, and Z
        position in meters, in ECF (or ECR?) coordinate system. The next 3 are
        the velocity in m/s. The final 6 are the upper right coordinates of
        the position covariance matrix (so order is (1, 1), (1, 2), (1, 3),
        (2, 2), (2,3), (3, 3)). 
        """
        return _geocal.QuickBirdEphemeris__ephemeris(self)

    @property
    def ephemeris(self):
        return self._ephemeris()

    def _file_name(self):
        """
        const std::string& GeoCal::QuickBirdFile< D >::file_name() const
        File name we are reading. 
        """
        return _geocal.QuickBirdEphemeris__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def __str__(self):
        """
        std::string GeoCal::Printable< QuickBirdEphemeris  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.QuickBirdEphemeris___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name)

    __swig_destroy__ = _geocal.delete_QuickBirdEphemeris
QuickBirdEphemeris._min_time = new_instancemethod(_geocal.QuickBirdEphemeris__min_time,None,QuickBirdEphemeris)
QuickBirdEphemeris._max_time = new_instancemethod(_geocal.QuickBirdEphemeris__max_time,None,QuickBirdEphemeris)
QuickBirdEphemeris._time_spacing = new_instancemethod(_geocal.QuickBirdEphemeris__time_spacing,None,QuickBirdEphemeris)
QuickBirdEphemeris._ephemeris = new_instancemethod(_geocal.QuickBirdEphemeris__ephemeris,None,QuickBirdEphemeris)
QuickBirdEphemeris._file_name = new_instancemethod(_geocal.QuickBirdEphemeris__file_name,None,QuickBirdEphemeris)
QuickBirdEphemeris.__str__ = new_instancemethod(_geocal.QuickBirdEphemeris___str__,None,QuickBirdEphemeris)
QuickBirdEphemeris_swigregister = _geocal.QuickBirdEphemeris_swigregister
QuickBirdEphemeris_swigregister(QuickBirdEphemeris)

class QuickBirdAttitude(object):
    """
    This is a low level class that reads a Quickbird attitude file.

    You probably don't want to use this directly, but rather use the
    QuickBirdOrbit.

    Note a possible source of confusion. There are a few different
    conventions about the ordering of the quaternion coefficients. The
    boost library places the real part at the front, so we have a + b i c
    j + d k and the quaternion is 4-tuple (a, b, c, d). The convention
    used by quickbird data is q1 i + q2 j + q3 k + q4 with the 4-tuple is
    (q1, q2, q3, q4). That means when we bring this over to the boost
    library, we need to reorder this to the 4-tuple (q4, q1, q2, q3).

    The code in QuickBirdOrbit accounts for these different conventions,
    but if you are using this class directly you need to be aware of this
    difference.

    C++ includes: quickbird_orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::QuickBirdAttitude::QuickBirdAttitude(const std::string &Fname)
        Read the quickbird attitude file. 
        """
        _geocal.QuickBirdAttitude_swiginit(self,_geocal.new_QuickBirdAttitude(*args))
    def _min_time(self):
        """
        Time GeoCal::QuickBirdFile< D >::min_time() const
        Start time of data. 
        """
        return _geocal.QuickBirdAttitude__min_time(self)

    @property
    def min_time(self):
        return self._min_time()

    def _max_time(self):
        """
        Time GeoCal::QuickBirdFile< D >::max_time() const
        End time of data. 
        """
        return _geocal.QuickBirdAttitude__max_time(self)

    @property
    def max_time(self):
        return self._max_time()

    def _time_spacing(self):
        """
        double GeoCal::QuickBirdFile< D >::time_spacing() const
        Spacing in seconds between points. 
        """
        return _geocal.QuickBirdAttitude__time_spacing(self)

    @property
    def time_spacing(self):
        return self._time_spacing()

    def _attitude(self):
        """
        const std::vector<boost::array<double, 14> >& GeoCal::QuickBirdAttitude::attitude() const
        Attitude data.

        The first 4 parameters are the quaternion parameters (q1, q2, q3, q4).
        The next 10 are the upper right elements of the attitude quaternion
        covariance matrix.

        Make sure to see the class notes for QuickBirdAttitude to see a
        discussion about the difference between the boost and Quickbird
        quaternion conventions. 
        """
        return _geocal.QuickBirdAttitude__attitude(self)

    @property
    def attitude(self):
        return self._attitude()

    def _file_name(self):
        """
        const std::string& GeoCal::QuickBirdFile< D >::file_name() const
        File name we are reading. 
        """
        return _geocal.QuickBirdAttitude__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def __str__(self):
        """
        std::string GeoCal::Printable< QuickBirdAttitude  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.QuickBirdAttitude___str__(self)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name)

    __swig_destroy__ = _geocal.delete_QuickBirdAttitude
QuickBirdAttitude._min_time = new_instancemethod(_geocal.QuickBirdAttitude__min_time,None,QuickBirdAttitude)
QuickBirdAttitude._max_time = new_instancemethod(_geocal.QuickBirdAttitude__max_time,None,QuickBirdAttitude)
QuickBirdAttitude._time_spacing = new_instancemethod(_geocal.QuickBirdAttitude__time_spacing,None,QuickBirdAttitude)
QuickBirdAttitude._attitude = new_instancemethod(_geocal.QuickBirdAttitude__attitude,None,QuickBirdAttitude)
QuickBirdAttitude._file_name = new_instancemethod(_geocal.QuickBirdAttitude__file_name,None,QuickBirdAttitude)
QuickBirdAttitude.__str__ = new_instancemethod(_geocal.QuickBirdAttitude___str__,None,QuickBirdAttitude)
QuickBirdAttitude_swigregister = _geocal.QuickBirdAttitude_swigregister
QuickBirdAttitude_swigregister(QuickBirdAttitude)

class QuickBirdOrbit(Orbit):
    """
    This is a Quickbird Orbit.

    This can be used for a rigorous model of Quickbird.

    Note an important limitation of the rigorous model vs. RPC. We don't
    currently account for atmospheric refraction, while the RPC does.
    Depending on the zenith angle, this can be somewhat important. From
    the approximate atmospheric model described in "Theoretical Basis of
    the SDP Toolkit Geolocation package for the ECS", Table 6-5 the
    linear displacement for a zenith angle of 10 is 0.549 meters, 20
    degress is 1.223 meters, and 30 degrees is 2.221. The typical
    Quickbird scene has something like 10 to 20 degree zenith angles, so
    this is a correction of 1 or 2 pixels.

    We will need to add atmospheric refraction in the future, but this
    hasn't been done yet.

    C++ includes: quickbird_orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        QuickBirdOrbit::QuickBirdOrbit(const std::string &Ephemeris_file, const std::string
        &Attitude_file="")
        Constructor.

        Usually the attitude and ephemeris file have names like blah.EPH and
        blah.ATT. If you supply just the ephemeris name, we fill in the
        attitude by replacing ".EPH" with ".ATT". 
        """
        _geocal.QuickBirdOrbit_swiginit(self,_geocal.new_QuickBirdOrbit(*args))
    def _ephemeris_file_name(self):
        """
        std::string GeoCal::QuickBirdOrbit::ephemeris_file_name() const

        """
        return _geocal.QuickBirdOrbit__ephemeris_file_name(self)

    @property
    def ephemeris_file_name(self):
        return self._ephemeris_file_name()

    def _attitude_file_name(self):
        """
        std::string GeoCal::QuickBirdOrbit::attitude_file_name() const

        """
        return _geocal.QuickBirdOrbit__attitude_file_name(self)

    @property
    def attitude_file_name(self):
        return self._attitude_file_name()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.ephemeris_file_name,self.attitude_file_name)

    __swig_destroy__ = _geocal.delete_QuickBirdOrbit
QuickBirdOrbit._ephemeris_file_name = new_instancemethod(_geocal.QuickBirdOrbit__ephemeris_file_name,None,QuickBirdOrbit)
QuickBirdOrbit._attitude_file_name = new_instancemethod(_geocal.QuickBirdOrbit__attitude_file_name,None,QuickBirdOrbit)
QuickBirdOrbit_swigregister = _geocal.QuickBirdOrbit_swigregister
QuickBirdOrbit_swigregister(QuickBirdOrbit)

class QuickBirdTimeTable(TimeTable):
    """
    This reads a quickbird .IMD file to get time table information.

    Note that Quickbird uses the same convention that we use in our code,
    an integer location is the center of a pixel. So (0, 0) is the center
    of the upper left pixel.

    C++ includes: quickbird_time_table.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        QuickBirdTimeTable::QuickBirdTimeTable(const std::string &Fname)
        Read the given file. 
        """
        _geocal.QuickBirdTimeTable_swiginit(self,_geocal.new_QuickBirdTimeTable(*args))
    def file_name(self):
        """
        const std::string& GeoCal::QuickBirdTimeTable::file_name() const
        Underlying file name. 
        """
        return _geocal.QuickBirdTimeTable_file_name(self)

    __swig_destroy__ = _geocal.delete_QuickBirdTimeTable
QuickBirdTimeTable.file_name = new_instancemethod(_geocal.QuickBirdTimeTable_file_name,None,QuickBirdTimeTable)
QuickBirdTimeTable_swigregister = _geocal.QuickBirdTimeTable_swigregister
QuickBirdTimeTable_swigregister(QuickBirdTimeTable)

class VicarFile(object):
    """
    This handles opening and closing a Vicar file.

    This class doesn't actually read and write data, but is used by other
    classes which do.

    This uses the VICAR RTL, which is documented athttp://www-
    mipl.jpl.nasa.gov/RTL

    If the VICAR RTL library wasn't available when this geocal was built,
    then this class will just throw an exception when we try to do
    anything with a VICAR file.

    As an implementation detail, the class VicarFile and IbisFile need to
    coordinate in translating file names to unit numbers since the same
    underlying Vicar routine zvunit is used by both. We arbitrarily have
    VicarFile handle this, and IbisFile accesses VicarFile when it needs
    to do this.

    Also a note for developers. The Vicar RTL library uses various
    variable argument functions. You need to end the list of arguments
    with "NULL". Note that a cast to a point type is mandatory, you
    can't just say "0". If say "0" then you will get fairly difficult
    to track down errors. Without the cast, this gets passed as an int,
    which the RTL library code will then try to interpret as a char *.
    va_args has undefined behavior when called with the wrong type,
    ranging from seeming to work to core dumping.

    Because of the complication involved, we have separated out the
    functionality of reading and writing MapInfo metadata. This is done by
    the class VicarOgr. This is handled behind the scenes, so for a user
    of this class this separation makes no difference. But if you are
    looking for the code that does this, you'll need to look in VicarOgr.

    The current implementation of the MapInfo metadata requires the GDAL
    library to be available. If this isn't you can still build the GeoCal
    system but any attempt to read or write MapInfo metadata will trigger
    an exception.

    C++ includes: vicar_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    VICAR_INT = _geocal.VicarFile_VICAR_INT
    VICAR_REAL = _geocal.VicarFile_VICAR_REAL
    VICAR_STRING = _geocal.VicarFile_VICAR_STRING
    VICAR_BYTE = _geocal.VicarFile_VICAR_BYTE
    VICAR_HALF = _geocal.VicarFile_VICAR_HALF
    VICAR_FULL = _geocal.VicarFile_VICAR_FULL
    VICAR_FLOAT = _geocal.VicarFile_VICAR_FLOAT
    VICAR_DOUBLE = _geocal.VicarFile_VICAR_DOUBLE
    READ = _geocal.VicarFile_READ
    WRITE = _geocal.VicarFile_WRITE
    UPDATE = _geocal.VicarFile_UPDATE
    NONE = _geocal.VicarFile_NONE
    BASIC = _geocal.VicarFile_BASIC
    BASIC2 = _geocal.VicarFile_BASIC2
    def __init__(self, *args): 
        """
        VicarFile::VicarFile(int Instance, int Number_line, int Number_sample, const std::string
        &Type="BYTE", const std::string &Name="OUT", compression C=NONE)
        Create a new VICAR file with the given size.

        Use the VICAR Name and Instance input (so for example, "INP" and 2
        is the second INP file passed to a VICAR program. 
        """
        _geocal.VicarFile_swiginit(self,_geocal.new_VicarFile(*args))
    __swig_destroy__ = _geocal.delete_VicarFile
    def _access(self):
        """
        access_type GeoCal::VicarFile::access() const
        Access type of file. 
        """
        return _geocal.VicarFile__access(self)

    @property
    def access(self):
        return self._access()

    def _force_area_pixel(self):
        """
        bool GeoCal::VicarFile::force_area_pixel() const
        If true, then force the file to be treated as "pixel is area".

        This is really just meant as a work around for the SRTM data, which
        incorrectly labels the data as "point" rather than "area". Since
        this is a 15 meter difference, it matters for many applications. Most
        users should just ignore this value. 
        """
        return _geocal.VicarFile__force_area_pixel(self)

    @property
    def force_area_pixel(self):
        return self._force_area_pixel()

    def _file_name(self):
        """
        const std::string& GeoCal::VicarFile::file_name() const
        File name. 
        """
        return _geocal.VicarFile__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def is_vicar_file(*args):
        """
        bool VicarFile::is_vicar_file(const std::string &Fname)
        Determine if a given file is a VICAR file or not.

        This looks for the first few characters of the file being "LBLSIZE="

        """
        return _geocal.VicarFile_is_vicar_file(*args)

    is_vicar_file = staticmethod(is_vicar_file)
    def file_name_to_unit(*args):
        """
        int VicarFile::file_name_to_unit(const std::string &Fname)
        Return a VICAR unit number that is tied to the given file name. 
        """
        return _geocal.VicarFile_file_name_to_unit(*args)

    file_name_to_unit = staticmethod(file_name_to_unit)
    def _number_line(self):
        """
        int GeoCal::VicarFile::number_line() const
        Number of lines in file. 
        """
        return _geocal.VicarFile__number_line(self)

    @property
    def number_line(self):
        return self._number_line()

    def _number_sample(self):
        """
        int GeoCal::VicarFile::number_sample() const
        Number of samples in file. 
        """
        return _geocal.VicarFile__number_sample(self)

    @property
    def number_sample(self):
        return self._number_sample()

    def _type(self):
        """
        data_type GeoCal::VicarFile::type() const
        Type of data in file. 
        """
        return _geocal.VicarFile__type(self)

    @property
    def type(self):
        return self._type()

    def _unit(self):
        """
        int GeoCal::VicarFile::unit() const
        Unit number for VicarFile. 
        """
        return _geocal.VicarFile__unit(self)

    @property
    def unit(self):
        return self._unit()

    def _map_info(self, *args):
        """
        void VicarFile::map_info(const MapInfo &M)
        Set metadata for MapInfo. 
        """
        return _geocal.VicarFile__map_info(self, *args)

    @property
    def map_info(self):
        return self._map_info()

    @map_info.setter
    def map_info(self, value):
      self._map_info(value)

    def _rpc(self, *args):
        """
        void VicarFile::rpc(const Rpc &R)
        Set metadata for Rpc. 
        """
        return _geocal.VicarFile__rpc(self, *args)

    @property
    def rpc(self):
        return self._rpc()

    @rpc.setter
    def rpc(self, value):
      self._rpc(value)

    def close(self):
        """
        void VicarFile::close()
        Close file. 
        """
        return _geocal.VicarFile_close(self)

    def flush(self):
        """
        void GeoCal::VicarFile::flush() const
        Flush data to disk. 
        """
        return _geocal.VicarFile_flush(self)

    def __str__(self):
        """
        std::string GeoCal::Printable< VicarFile  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.VicarFile___str__(self)

    def label_delete(self, *args):
        """
        void VicarFile::label_delete(const std::string &F, const std::string &Property="")
        Delete a label from a file. 
        """
        return _geocal.VicarFile_label_delete(self, *args)

    def label_set(self, *args):
        """
        void VicarFile::label_set(const std::string &F, const std::string &Val, const std::string
        &Property="")
        Set the value of a label.

        If the label is already in the file, is is deleted and replaced with
        this new value. Otherwise, it is simply added. Optionally the label
        can be part of a Property. 
        """
        return _geocal.VicarFile_label_set(self, *args)

    def __getitem__(self, key):
        if(isinstance(key, list) or isinstance(key, tuple)):
          prop, ky = key
          tp = self.ltype(prop + " " + ky)
          if(tp == VicarFile.VICAR_INT):
             return self.label_int(ky, prop)
          elif(tp == VicarFile.VICAR_REAL):
             return self.label_float(ky, prop)
          else:
             return self.label_string(ky, prop)
        else:
          tp = self.ltype(key)
          if(tp == VicarFile.VICAR_INT):
             return self.label_int(key)
          elif(tp == VicarFile.VICAR_REAL):
             return self.label_float(key)
          else:
             return self.label_string(key)

    def __setitem__(self, key, v):
        if(isinstance(key, list) or isinstance(key, tuple)):
          prop, ky = key
          self.label_set(ky, v, prop)
        else:
          self.label_set(key, v)
      
    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name,self.access,self.force_area_pixel)

VicarFile._access = new_instancemethod(_geocal.VicarFile__access,None,VicarFile)
VicarFile._force_area_pixel = new_instancemethod(_geocal.VicarFile__force_area_pixel,None,VicarFile)
VicarFile._file_name = new_instancemethod(_geocal.VicarFile__file_name,None,VicarFile)
VicarFile._number_line = new_instancemethod(_geocal.VicarFile__number_line,None,VicarFile)
VicarFile._number_sample = new_instancemethod(_geocal.VicarFile__number_sample,None,VicarFile)
VicarFile._type = new_instancemethod(_geocal.VicarFile__type,None,VicarFile)
VicarFile._unit = new_instancemethod(_geocal.VicarFile__unit,None,VicarFile)
VicarFile._map_info = new_instancemethod(_geocal.VicarFile__map_info,None,VicarFile)
VicarFile._rpc = new_instancemethod(_geocal.VicarFile__rpc,None,VicarFile)
VicarFile.close = new_instancemethod(_geocal.VicarFile_close,None,VicarFile)
VicarFile.flush = new_instancemethod(_geocal.VicarFile_flush,None,VicarFile)
VicarFile.__str__ = new_instancemethod(_geocal.VicarFile___str__,None,VicarFile)
VicarFile.label_delete = new_instancemethod(_geocal.VicarFile_label_delete,None,VicarFile)
VicarFile.label_set = new_instancemethod(_geocal.VicarFile_label_set,None,VicarFile)
VicarFile.ltype = new_instancemethod(_geocal.VicarFile_ltype,None,VicarFile)
VicarFile.label_int = new_instancemethod(_geocal.VicarFile_label_int,None,VicarFile)
VicarFile.label_float = new_instancemethod(_geocal.VicarFile_label_float,None,VicarFile)
VicarFile.label_string = new_instancemethod(_geocal.VicarFile_label_string,None,VicarFile)
VicarFile.label_list = new_instancemethod(_geocal.VicarFile_label_list,None,VicarFile)
VicarFile.property_list = new_instancemethod(_geocal.VicarFile_property_list,None,VicarFile)
VicarFile_swigregister = _geocal.VicarFile_swigregister
VicarFile_swigregister(VicarFile)

def VicarFile_is_vicar_file(*args):
  """
    bool VicarFile::is_vicar_file(const std::string &Fname)
    Determine if a given file is a VICAR file or not.

    This looks for the first few characters of the file being "LBLSIZE="

    """
  return _geocal.VicarFile_is_vicar_file(*args)

def VicarFile_file_name_to_unit(*args):
  """
    int VicarFile::file_name_to_unit(const std::string &Fname)
    Return a VICAR unit number that is tied to the given file name. 
    """
  return _geocal.VicarFile_file_name_to_unit(*args)

class VicarArgument(object):
    """
    This provides access to arguments passed by VICAR.

    Note an important limitation of VICAR, you can only initialize the
    argument handling once. This means that if you try to create multiple
    VicarArgument objects, you'll trigger a TAE error when you try to
    create the second object.

    VICAR uses a somewhat unusual mechanism to pass arguments to a program
    called from the TAE. Rather than putting the arguments on the command
    line to appear in Argv, the arguments get passed down a pipe (usually
    file logical 4) in a compressed format. I'm not sure why exactly it
    does this, probably some historical artifact from when it was
    developed on VMS. In any case, in order to fit into VICAR we need to
    parse arguments the same way.

    This class handles the arguments.

    C++ includes: vicar_argument.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        VicarArgument::VicarArgument(int Argc, char **Argv, bool copy_primary_input_label=false)
        Set up to parse VICAR arguments.

        VICAR arguments are accessed by keywords. This isn't a bad interface,
        but because we also want to support straight unix command line style
        arguments, we have the VicarArgument interface in terms of index
        number (first argument, second argument, etc.). Keyword_list gives the
        list of keywords in order that we want.

        VICAR has the convention that when creating a new file it
        automatically copies over all of the labels from the "primary input"
        - usually the first input file. The idea is that with old VICAR files
        most of the time the output image would have same size, map
        projection, etc. However, this doesn't fit well with the geocal usage
        at all. Much of the time the output file doesn't have any relationship
        to the input file. Also the label reading and writing happens in the
        background anyways, so there isn't a lot gained by the defaults. This
        can often cause problems, such as copying map projection data from an
        input file to an output file that isn't map projected.

        By default, we turn this copying off. You can get the old VICAR
        behavior by setting Copy_primary_input_label to true. 
        """
        _geocal.VicarArgument_swiginit(self,_geocal.new_VicarArgument(*args))
    def write_out(self, *args):
        """
        void VicarArgument::write_out(const std::string &Keyword, const std::string &Val)

        """
        return _geocal.VicarArgument_write_out(self, *args)

    type_string = staticmethod(_geocal.VicarArgument_type_string)
    type_count = staticmethod(_geocal.VicarArgument_type_count)
    arg_str = staticmethod(_geocal.VicarArgument_arg_str)
    arg_int = staticmethod(_geocal.VicarArgument_arg_int)
    arg_real = staticmethod(_geocal.VicarArgument_arg_real)
    def __str__(self):
        """
        std::string GeoCal::Printable< VicarArgument  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.VicarArgument___str__(self)

    def __getitem__(self, key):
      k = str(key).upper()
      t = self.type_string(k)
      if(t == "STRING"):
        r = self.arg_str(k)
      elif(t == "REAL"):
        r = self.arg_real(k)
      elif(t == "INT"):
        r = self.arg_int(k)
      if(self.type_count(k) == 1):
        r = r[0]
      return r

    def __setitem__(self, key, val):
      k = str(key).upper()
      t = self.type_string(k)
      if(t == "STRING"):
        self.write_out(k, str(val))
      elif(t == "REAL"):
        self.write_out(k, float(val))
      elif(t == "INT"):
        self.write_out(k, int(val))


    __swig_destroy__ = _geocal.delete_VicarArgument
VicarArgument.write_out = new_instancemethod(_geocal.VicarArgument_write_out,None,VicarArgument)
VicarArgument.__str__ = new_instancemethod(_geocal.VicarArgument___str__,None,VicarArgument)
VicarArgument_swigregister = _geocal.VicarArgument_swigregister
VicarArgument_swigregister(VicarArgument)

def VicarArgument_type_string(*args):
  return _geocal.VicarArgument_type_string(*args)
VicarArgument_type_string = _geocal.VicarArgument_type_string

def VicarArgument_type_count(*args):
  return _geocal.VicarArgument_type_count(*args)
VicarArgument_type_count = _geocal.VicarArgument_type_count

def VicarArgument_arg_str(*args):
  return _geocal.VicarArgument_arg_str(*args)
VicarArgument_arg_str = _geocal.VicarArgument_arg_str

def VicarArgument_arg_int(*args):
  return _geocal.VicarArgument_arg_int(*args)
VicarArgument_arg_int = _geocal.VicarArgument_arg_int

def VicarArgument_arg_real(*args):
  return _geocal.VicarArgument_arg_real(*args)
VicarArgument_arg_real = _geocal.VicarArgument_arg_real

class VicarDem(DemTiledFile):
    """
    This uses a VicarTiledFile<T> as a DEM.

    The type of T should be one we can convert to a double, and should
    give the height in meters above sea level. We do a bilinear
    interpolation to get values between points, and we optionally return a
    height of 0 outside of the range of where we have data (or
    alternatively, throw an exception).

    The default datum used is NoDatum, e.g., the heights in the VICAR file
    are relative to WGS-84. If desired, a different Datum can be given.

    C++ includes: vicar_dem.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::VicarDem::VicarDem(int Instance, bool Outside_dem_is_error=false, int
        Number_line_per_tile=100, int Number_tile=4, const std::string
        &Name="INP", const boost::shared_ptr< Datum > &D=boost::shared_ptr<
        Datum >(new NoDatum()))
        Open VICAR file as a DEM. 
        """
        _geocal.VicarDem_swiginit(self,_geocal.new_VicarDem(*args))
    def _vicar_file(self):
        """
        boost::shared_ptr<VicarFile> GeoCal::VicarDem::vicar_file_ptr() const

        """
        return _geocal.VicarDem__vicar_file(self)

    @property
    def vicar_file(self):
        return self._vicar_file()

    def elevation(self, *args):
        """
        virtual double GeoCal::DemTiledFile::elevation(int Y_index, int X_index) const
        Return height in meters relative to datum().

        Note that the call is in line, sample order, which means Y and then X.

        """
        return _geocal.VicarDem_elevation(self, *args)

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.vicar_file.file_name,self.outside_dem_is_error,self.number_line_per_tile,self.number_tile,self.datum)

    __swig_destroy__ = _geocal.delete_VicarDem
VicarDem._vicar_file = new_instancemethod(_geocal.VicarDem__vicar_file,None,VicarDem)
VicarDem.elevation = new_instancemethod(_geocal.VicarDem_elevation,None,VicarDem)
VicarDem_swigregister = _geocal.VicarDem_swigregister
VicarDem_swigregister(VicarDem)

class VicarLiteFile(object):
    """
    This handles opening and closing a Vicar file.

    This class doesn't actually read and write data, but is used by other
    classes which do.

    This class is a simple implementation of Vicar. It doesn't use the
    Vicar RTL library, which is the primary attraction of it. We can use
    this to read Vicar files in a context where we don't want to use the
    RTL library, or don't want to be constrained to running in the Vicar
    environment.

    This class does not handle new VICAR features such as compression.

    C++ includes: vicar_lite_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    VICAR_BYTE = _geocal.VicarLiteFile_VICAR_BYTE
    VICAR_HALF = _geocal.VicarLiteFile_VICAR_HALF
    VICAR_FULL = _geocal.VicarLiteFile_VICAR_FULL
    VICAR_FLOAT = _geocal.VicarLiteFile_VICAR_FLOAT
    VICAR_DOUBLE = _geocal.VicarLiteFile_VICAR_DOUBLE
    READ = _geocal.VicarLiteFile_READ
    WRITE = _geocal.VicarLiteFile_WRITE
    UPDATE = _geocal.VicarLiteFile_UPDATE
    def __init__(self, *args): 
        """
        VicarLiteFile::VicarLiteFile(const std::string &Fname, int Number_line, int Number_sample, const
        std::string &Type="BYTE")
        Create a new VICAR file with the given size. 
        """
        _geocal.VicarLiteFile_swiginit(self,_geocal.new_VicarLiteFile(*args))
    __swig_destroy__ = _geocal.delete_VicarLiteFile
    def _access(self):
        """
        access_type GeoCal::VicarLiteFile::access() const
        Access type of file. 
        """
        return _geocal.VicarLiteFile__access(self)

    @property
    def access(self):
        return self._access()

    def _force_area_pixel(self):
        """
        bool GeoCal::VicarLiteFile::force_area_pixel() const
        If true, then force the file to be treated as "pixel is area".

        This is really just meant as a work around for the SRTM data, which
        incorrectly labels the data as "point" rather than "area". Since
        this is a 15 meter difference, it matters for many applications. Most
        users should just ignore this value. 
        """
        return _geocal.VicarLiteFile__force_area_pixel(self)

    @property
    def force_area_pixel(self):
        return self._force_area_pixel()

    def _data_offset(self):
        """
        int GeoCal::VicarLiteFile::data_offset() const
        Offset to where the data starts. 
        """
        return _geocal.VicarLiteFile__data_offset(self)

    @property
    def data_offset(self):
        return self._data_offset()

    def _file_name(self):
        """
        const std::string& GeoCal::VicarLiteFile::file_name() const
        File name. 
        """
        return _geocal.VicarLiteFile__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def is_vicar_file(*args):
        """
        bool VicarLiteFile::is_vicar_file(const std::string &Fname)
        Determine if a given file is a VICAR file or not.

        This looks for the first few characters of the file being "LBLSIZE="

        """
        return _geocal.VicarLiteFile_is_vicar_file(*args)

    is_vicar_file = staticmethod(is_vicar_file)
    def _number_line(self):
        """
        int GeoCal::VicarLiteFile::number_line() const
        Number of lines in file. 
        """
        return _geocal.VicarLiteFile__number_line(self)

    @property
    def number_line(self):
        return self._number_line()

    def _number_sample(self):
        """
        int GeoCal::VicarLiteFile::number_sample() const
        Number of samples in file. 
        """
        return _geocal.VicarLiteFile__number_sample(self)

    @property
    def number_sample(self):
        return self._number_sample()

    def _number_band(self):
        """
        int GeoCal::VicarLiteFile::number_band() const
        Number of bands in file. 
        """
        return _geocal.VicarLiteFile__number_band(self)

    @property
    def number_band(self):
        return self._number_band()

    def _type(self):
        """
        data_type GeoCal::VicarLiteFile::type() const
        Type of data in file. 
        """
        return _geocal.VicarLiteFile__type(self)

    @property
    def type(self):
        return self._type()

    def _map_info(self, *args):
        """
        void VicarLiteFile::map_info(const MapInfo &M)
        Set metadata for MapInfo. 
        """
        return _geocal.VicarLiteFile__map_info(self, *args)

    @property
    def map_info(self):
        return self._map_info()

    @map_info.setter
    def map_info(self, value):
      self._map_info(value)

    def _rpc(self, *args):
        """
        void GeoCal::VicarLiteFile::rpc(const Rpc &R)

        """
        return _geocal.VicarLiteFile__rpc(self, *args)

    @property
    def rpc(self):
        return self._rpc()

    @rpc.setter
    def rpc(self, value):
      self._rpc(value)

    def __str__(self):
        """
        std::string GeoCal::Printable< VicarLiteFile  >::print_to_string() const
        Print to string.

        This is primarily useful for SWIG wrappers to this class, e.g. a to_s
        method in ruby. 
        """
        return _geocal.VicarLiteFile___str__(self)

    def _is_compressed(self):
        """
        bool GeoCal::VicarLiteFile::is_compressed() const
        Indicate if the file is compressed.

        If it is, we can't actually read the data but we can still read all of
        the labels. 
        """
        return _geocal.VicarLiteFile__is_compressed(self)

    @property
    def is_compressed(self):
        return self._is_compressed()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name,self.access,self.force_area_pixel)

VicarLiteFile._access = new_instancemethod(_geocal.VicarLiteFile__access,None,VicarLiteFile)
VicarLiteFile._force_area_pixel = new_instancemethod(_geocal.VicarLiteFile__force_area_pixel,None,VicarLiteFile)
VicarLiteFile._data_offset = new_instancemethod(_geocal.VicarLiteFile__data_offset,None,VicarLiteFile)
VicarLiteFile._file_name = new_instancemethod(_geocal.VicarLiteFile__file_name,None,VicarLiteFile)
VicarLiteFile._number_line = new_instancemethod(_geocal.VicarLiteFile__number_line,None,VicarLiteFile)
VicarLiteFile._number_sample = new_instancemethod(_geocal.VicarLiteFile__number_sample,None,VicarLiteFile)
VicarLiteFile._number_band = new_instancemethod(_geocal.VicarLiteFile__number_band,None,VicarLiteFile)
VicarLiteFile._type = new_instancemethod(_geocal.VicarLiteFile__type,None,VicarLiteFile)
VicarLiteFile._map_info = new_instancemethod(_geocal.VicarLiteFile__map_info,None,VicarLiteFile)
VicarLiteFile._rpc = new_instancemethod(_geocal.VicarLiteFile__rpc,None,VicarLiteFile)
VicarLiteFile.__str__ = new_instancemethod(_geocal.VicarLiteFile___str__,None,VicarLiteFile)
VicarLiteFile._is_compressed = new_instancemethod(_geocal.VicarLiteFile__is_compressed,None,VicarLiteFile)
VicarLiteFile.label_string = new_instancemethod(_geocal.VicarLiteFile_label_string,None,VicarLiteFile)
VicarLiteFile.label_list = new_instancemethod(_geocal.VicarLiteFile_label_list,None,VicarLiteFile)
VicarLiteFile_swigregister = _geocal.VicarLiteFile_swigregister
VicarLiteFile_swigregister(VicarLiteFile)

def VicarLiteFile_is_vicar_file(*args):
  """
    bool VicarLiteFile::is_vicar_file(const std::string &Fname)
    Determine if a given file is a VICAR file or not.

    This looks for the first few characters of the file being "LBLSIZE="

    """
  return _geocal.VicarLiteFile_is_vicar_file(*args)

class VicarLiteRasterImage(RasterImage):
    """
    This uses VicarLiteFile to implement a RasterImage.

    We use a VicarLiteFile to implement a RasterImage.

    C++ includes: vicar_lite_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::VicarLiteRasterImage::VicarLiteRasterImage(const std::string &Fname, access_type Access=VicarLiteFile::READ, int
        Band=0, int Number_tile_line=-1, int Number_tile_sample=-1, bool
        Force_area_pixel=false)
        Constructor.

        The Force_area_pixel forces the file to be treated as "pixel as
        area" rather than "pixel as point". This is really just meant as a
        work around for the SRTM data, which incorrectly labels the data as
        "point" rather than "area". Since this is a 15 meter difference,
        it matters for many applications. Most users should just ignore this
        value. 
        """
        _geocal.VicarLiteRasterImage_swiginit(self,_geocal.new_VicarLiteRasterImage(*args))
    __swig_destroy__ = _geocal.delete_VicarLiteRasterImage
    def _file(self):
        """
        boost::shared_ptr<VicarLiteFile> GeoCal::VicarLiteRasterImage::file_ptr() const

        """
        return _geocal.VicarLiteRasterImage__file(self)

    @property
    def file(self):
        return self._file()

    def _is_compressed(self):
        """
        bool GeoCal::VicarLiteRasterImage::is_compressed() const
        Indicate if the file is compressed.

        If it is, we can't actually read the data but we can still read all of
        the labels. 
        """
        return _geocal.VicarLiteRasterImage__is_compressed(self)

    @property
    def is_compressed(self):
        return self._is_compressed()

    def _band(self):
        """
        int GeoCal::VicarLiteRasterImage::band() const
        Return band number. 
        """
        return _geocal.VicarLiteRasterImage__band(self)

    @property
    def band(self):
        return self._band()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file.file_name,self.file.access,self.band,self.number_tile_line,self.number_tile_sample,self.file.force_area_pixel)

VicarLiteRasterImage._file = new_instancemethod(_geocal.VicarLiteRasterImage__file,None,VicarLiteRasterImage)
VicarLiteRasterImage._is_compressed = new_instancemethod(_geocal.VicarLiteRasterImage__is_compressed,None,VicarLiteRasterImage)
VicarLiteRasterImage._band = new_instancemethod(_geocal.VicarLiteRasterImage__band,None,VicarLiteRasterImage)
VicarLiteRasterImage_swigregister = _geocal.VicarLiteRasterImage_swigregister
VicarLiteRasterImage_swigregister(VicarLiteRasterImage)

class VicarLiteDem(DemMapInfo):
    """
    This uses VicarLiteFile to implement a Dem.

    We use VicarLiteFile to implement a Dem

    C++ includes: vicar_lite_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::VicarLiteDem::VicarLiteDem(const std::string &Fname, bool Outside_dem_is_error=false, const
        boost::shared_ptr< Datum > &D=boost::shared_ptr< Datum >(new
        NoDatum()), int Band=0)
        Constructor.

        If Outside_dem_is_error is true, then calls for Dem data outside of
        the range of the Dem cause an exception to be thrown, otherwise we
        just return a height of 0. 
        """
        _geocal.VicarLiteDem_swiginit(self,_geocal.new_VicarLiteDem(*args))
    __swig_destroy__ = _geocal.delete_VicarLiteDem
    def _file(self):
        """
        boost::shared_ptr<VicarLiteFile> GeoCal::VicarLiteDem::file_ptr() const

        """
        return _geocal.VicarLiteDem__file(self)

    @property
    def file(self):
        return self._file()

    def elevation(self, *args):
        """
        virtual double GeoCal::VicarLiteDem::elevation(int Y_index, int X_index) const
        Return height in meters relative to datum(). 
        """
        return _geocal.VicarLiteDem_elevation(self, *args)

    def _band(self):
        """
        int GeoCal::VicarLiteDem::band() const
        Return band number. 
        """
        return _geocal.VicarLiteDem__band(self)

    @property
    def band(self):
        return self._band()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file.file_name,self.outside_dem_is_error,self.datum,self.band)

VicarLiteDem._file = new_instancemethod(_geocal.VicarLiteDem__file,None,VicarLiteDem)
VicarLiteDem.elevation = new_instancemethod(_geocal.VicarLiteDem_elevation,None,VicarLiteDem)
VicarLiteDem._band = new_instancemethod(_geocal.VicarLiteDem__band,None,VicarLiteDem)
VicarLiteDem_swigregister = _geocal.VicarLiteDem_swigregister
VicarLiteDem_swigregister(VicarLiteDem)

class VicarMultiFile(RasterMultifile):
    """
    This gives read access to some of the larger AFIDS datasets, such as
    CIB and SRTM.

    These larger datasets split into a number of VICAR files. Each one of
    these is a some extent in latitude/longitude, for example 1 x 1 degree
    tiles for the SRTM. There is an index IBIS file that gives a listing
    of all the input datasets and where they are located.

    This class gives an interface to this set of VICAR files that looks
    like one really big RasterImage.

    Note that the files might not cover the full extent of area, for
    example one of the 1x1 degree SRTM tiles might be missing. If we
    attempt to access the area covered by a missing file then an error is
    thrown. We may want to come up with a more robust interface, but for
    now this interface seems to be sufficient.

    C++ includes: vicar_multi_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        VicarMultiFile::VicarMultiFile(const std::string &Db_name, const std::string &Dirbase, const
        std::string &Extension="", int Number_tile_line=10000, int
        Number_tile_sample=10000, int Number_line_per_tile=100000, int
        Number_tile_each_file=4, int Number_file=4, bool
        Favor_memory_mapped=true, bool No_coverage_is_error=true, int
        No_coverage_fill_value=0, bool Force_area_pixel=false)
        Constructor.

        This takes the database file (an IBIS file) and the directory that the
        files pointed to by the database file are located. The directory is
        needed because although the files are often in the same directory as
        the database file they aren't always. The database file doesn't
        contain directory information, just the file name, so we need to pass
        the directory in.

        For some odd reason, the file names also don't always have the
        extension on them. For some databases, you need to add something like
        ".img" to get the actual file name. You can pass any extension that
        is needed.

        There are two kinds of tiling going on. At the top level, we have a
        number of files open at one time, given by Number_file. For each file,
        we read that it tiles with the given Number_line_per_tile and
        Number_tile_each_file tiles.

        There are two strategies that can be used to reading a Vicar file. One
        reads a tile of a given number of lines and store it in memory. The
        other uses memory mapped file io to read data on demand. Often but not
        always the memory mapped file is faster, particularly for small files
        or for files with a large number of samples where only a portion is
        used. You can control which is used by setting Favor_memory_mapped. If
        the underlying data uses VICAR compression, then we always use the
        VICAR IO routines since memory mapping won't work. This class handles
        this case - it checks if the file is compressed before trying to do
        memory mapping.

        The Force_area_pixel forces the file to be treated as "pixel as
        area" rather than "pixel as point". This is really just meant as a
        work around for the SRTM data, which incorrectly labels the data as
        "point" rather than "area". Since this is a 15 meter difference,
        it matters for may applications. Most users should just ignore this
        value. 
        """
        _geocal.VicarMultiFile_swiginit(self,_geocal.new_VicarMultiFile(*args))
    __swig_destroy__ = _geocal.delete_VicarMultiFile
VicarMultiFile_swigregister = _geocal.VicarMultiFile_swigregister
VicarMultiFile_swigregister(VicarMultiFile)

class DatumGeoid96(Datum):
    """
    This class read the EGM 96 geoid data to provide a Datum.

    C++ includes: datum_geoid96.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, Fname=""): 
        """
        DatumGeoid96::DatumGeoid96(const std::string &Fname="")
        Constructor.

        You can pass the datum file to read, but if you leave this as blank we
        use the file ${AFIDS_VDEV_DATA}/EGM96_20_x100.HLF. 
        """
        _geocal.DatumGeoid96_swiginit(self,_geocal.new_DatumGeoid96(Fname))
    def _file_name(self):
        """
        const std::string& GeoCal::DatumGeoid96::file_name() const

        """
        return _geocal.DatumGeoid96__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name)

    __swig_destroy__ = _geocal.delete_DatumGeoid96
DatumGeoid96._file_name = new_instancemethod(_geocal.DatumGeoid96__file_name,None,DatumGeoid96)
DatumGeoid96_swigregister = _geocal.DatumGeoid96_swigregister
DatumGeoid96_swigregister(DatumGeoid96)

class SrtmDem(DemMapInfo):
    """
    This class provides access to the SRTM.

    Note comment from Tom about this data:

    The srtm_filled data were prepared back in 2003. The goal was to
    create a quick and dirty global data set, which means the data came
    from a variety of sources, scales, datums, and accuracy. At that time,
    a half pixel error was well below the threshold of concern (15-30 was
    high resolution back then). So, point and area data were often mixed
    in the void filling process, and some regional areas (not covered by
    srtm) were carved into quadrangles and retained their individual pixel
    types. I know its a mess, but the bottom line is that the data are not
    accurate to half a pixel, which makes the 'point vs. area' discuss not
    really relevant.

    The SRTM VICAR files incorrectly label the data as "pixel is point",
    when really this is "pixel is area". This matters, because it is a
    1/2 pixel shift. The code overrides what the VICAR files says, and
    treats it as "area" rather than "pixel".

    C++ includes: srtm_dem.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        SrtmDem::SrtmDem(const std::string &Db_name="", const std::string &Dirbase="",
        bool Outside_dem_is_error=true, const boost::shared_ptr< Datum >
        &D=boost::shared_ptr< Datum >(new DatumGeoid96()))
        Constructor.

        You can provide the database file to use and the directory where there
        data can be found. If you leave this as a blank string, we use
        ${ELEV_ROOT} as the directory and ${ELEV_ROOT}/L2_dem_db.int as the
        file. 
        """
        _geocal.SrtmDem_swiginit(self,_geocal.new_SrtmDem(*args))
    def elevation(self, *args):
        """
        virtual double GeoCal::SrtmDem::elevation(int Y_index, int X_index) const
        Return height in meters relative to datum(). 
        """
        return _geocal.SrtmDem_elevation(self, *args)

    def _database_name(self):
        """
        const std::string& GeoCal::SrtmDem::database_name() const
        Database name. 
        """
        return _geocal.SrtmDem__database_name(self)

    @property
    def database_name(self):
        return self._database_name()

    def _directory_base(self):
        """
        const std::string& GeoCal::SrtmDem::directory_base() const
        Database base directory. 
        """
        return _geocal.SrtmDem__directory_base(self)

    @property
    def directory_base(self):
        return self._directory_base()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.database_name,self.directory_base,self.outside_dem_is_error,self.datum)

    __swig_destroy__ = _geocal.delete_SrtmDem
SrtmDem.elevation = new_instancemethod(_geocal.SrtmDem_elevation,None,SrtmDem)
SrtmDem._database_name = new_instancemethod(_geocal.SrtmDem__database_name,None,SrtmDem)
SrtmDem._directory_base = new_instancemethod(_geocal.SrtmDem__directory_base,None,SrtmDem)
SrtmDem_swigregister = _geocal.SrtmDem_swigregister
SrtmDem_swigregister(SrtmDem)

class VicarRasterImage(RasterImageTiledFile):
    """
    This wraps a VicarTiledFile<T> to make a RasterImage.

    The type of T should be one we can convert to and from a int, since
    this is what a RasterImage works in.

    C++ includes: vicar_raster_image.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        GeoCal::VicarRasterImage::VicarRasterImage(int Instance, const MapInfo &M, const std::string &Type="BYTE",
        const std::string &Name="OUT", int Number_line_per_tile=100,
        compression C=VicarFile::NONE)
        Create a new VICAR file with the given size.

        Use the VICAR Name and Instance input (so for example, "INP" and 2
        is the second INP file passed to a VICAR program. 
        """
        _geocal.VicarRasterImage_swiginit(self,_geocal.new_VicarRasterImage(*args))
    def _vicar_file(self):
        """
        boost::shared_ptr<VicarFile> GeoCal::VicarRasterImage::vicar_file_ptr() const

        """
        return _geocal.VicarRasterImage__vicar_file(self)

    @property
    def vicar_file(self):
        return self._vicar_file()

    def flush(self):
        """
        virtual void GeoCal::VicarRasterImage::flush() const
        Flush data to disk. 
        """
        return _geocal.VicarRasterImage_flush(self)

    def close(self):
        """
        void GeoCal::VicarRasterImage::close()
        Close a file.

        You don't normally need to call this directly, it is done by the
        destructor. But it is useful to have for use by Ruby. 
        """
        return _geocal.VicarRasterImage_close(self)

    def set_rpc(self, *args):
        """
        void GeoCal::VicarRasterImage::set_rpc(const Rpc &R)
        Set the RPC. 
        """
        return _geocal.VicarRasterImage_set_rpc(self, *args)

    def set_map_info(self, *args):
        """
        void GeoCal::VicarRasterImage::set_map_info(const MapInfo &Mi)
        Set the Map Info. 
        """
        return _geocal.VicarRasterImage_set_map_info(self, *args)

    def _rpc(self):
        """
        virtual Rpc GeoCal::RasterImageVariable::rpc() const
        Rpc for image. 
        """
        return _geocal.VicarRasterImage__rpc(self)

    @property
    def rpc(self):
        return self._rpc()

    def _map_info(self):
        """
        virtual const MapInfo& GeoCal::RasterImageVariable::map_info() const
        MapInfo for image. 
        """
        return _geocal.VicarRasterImage__map_info(self)

    @property
    def map_info(self):
        return self._map_info()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.vicar_file.file_name,self.vicar_file.access,self.number_tile_line,self.number_tile,self.vicar_file.force_area_pixel)

    @rpc.setter
    def rpc(self, val):
       self.set_rpc(val)

    @map_info.setter
    def map_info(self, val):
       self.set_map_info(val)

    def __getitem__(self, key):
        return self.vicar_file[key]

    def __setitem__(self, key, v):
        self.vicar_file[key] = v
        
      
    __swig_destroy__ = _geocal.delete_VicarRasterImage
VicarRasterImage._vicar_file = new_instancemethod(_geocal.VicarRasterImage__vicar_file,None,VicarRasterImage)
VicarRasterImage.flush = new_instancemethod(_geocal.VicarRasterImage_flush,None,VicarRasterImage)
VicarRasterImage.close = new_instancemethod(_geocal.VicarRasterImage_close,None,VicarRasterImage)
VicarRasterImage.set_rpc = new_instancemethod(_geocal.VicarRasterImage_set_rpc,None,VicarRasterImage)
VicarRasterImage.set_map_info = new_instancemethod(_geocal.VicarRasterImage_set_map_info,None,VicarRasterImage)
VicarRasterImage._rpc = new_instancemethod(_geocal.VicarRasterImage__rpc,None,VicarRasterImage)
VicarRasterImage._map_info = new_instancemethod(_geocal.VicarRasterImage__map_info,None,VicarRasterImage)
VicarRasterImage_swigregister = _geocal.VicarRasterImage_swigregister
VicarRasterImage_swigregister(VicarRasterImage)

class PosExportOrbit(OrbitQuaternionList):
    """
    This read a POS export file to supply an Orbit.

    This is a text file that is written by the Applanix POS Export
    Utility.

    Note that the time in the POS export file is in GPS second of the
    week. This starts at midnight UTC time between Saturday and Sunday.
    Presumably if we happen to be flying at this time, the time will
    reset. We don't have any handling in place for this, we'll need to add
    handling if this ever becomes an issue.

    C++ includes: pos_export_orbit.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        PosExportOrbit::PosExportOrbit(const std::string &Fname, const Time &Epoch)
        Read the given text file.

        Note that the time in the Applanix file is in GPS seconds of the week,
        but the actual week isn't in the file. This means we need to pass in
        the Epoch that the times are relative to. 
        """
        _geocal.PosExportOrbit_swiginit(self,_geocal.new_PosExportOrbit(*args))
    def aircraft_orbit_data(self, *args):
        """
        const AircraftOrbitData & PosExportOrbit::aircraft_orbit_data(const Time &T) const
        Return the AircraftOrbitData closest to a given Time.

        This doesn't interpolate, it just return the data point in the file
        closest to the given time. 
        """
        return _geocal.PosExportOrbit_aircraft_orbit_data(self, *args)

    def _file_name(self):
        """
        const std::string& GeoCal::PosExportOrbit::file_name() const

        """
        return _geocal.PosExportOrbit__file_name(self)

    @property
    def file_name(self):
        return self._file_name()

    def _file_epoch(self):
        """
        const Time& GeoCal::PosExportOrbit::file_epoch() const

        """
        return _geocal.PosExportOrbit__file_epoch(self)

    @property
    def file_epoch(self):
        return self._file_epoch()

    def __reduce__(self):
      return _new_from_init, (self.__class__, self.file_name,self.file_epoch)

    __swig_destroy__ = _geocal.delete_PosExportOrbit
PosExportOrbit.aircraft_orbit_data = new_instancemethod(_geocal.PosExportOrbit_aircraft_orbit_data,None,PosExportOrbit)
PosExportOrbit._file_name = new_instancemethod(_geocal.PosExportOrbit__file_name,None,PosExportOrbit)
PosExportOrbit._file_epoch = new_instancemethod(_geocal.PosExportOrbit__file_epoch,None,PosExportOrbit)
PosExportOrbit_swigregister = _geocal.PosExportOrbit_swigregister
PosExportOrbit_swigregister(PosExportOrbit)

class WorldView2CloudMask(CalcRaster):
    """
    This create a cloud mask using WorldView2 mulispectral data.

    This cloud mask has two parts:

    A simple threshold on the coastal blue band to detect clouds.

    A ratio comparision of (band 8 - band 1) / band 1 < threshold to
    detect cloud shadows.

    To help with false positives, we have a minimum cloud size. This is
    used to average the data, and only if the lower resolution data shows
    a cloud or a shadow do we mark a pixel as cloudy or in shadow.

    We use reflectance data. It can be convenient to scale the reflectance
    data (e.g., go from 0 to 32767 to give half word VICAR data). This
    class doesn't care, as long as the Cloud_threshold is scaled the same
    way.

    C++ includes: worldview2_cloudmask.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    CLEAR = _geocal.WorldView2CloudMask_CLEAR
    SHADOW = _geocal.WorldView2CloudMask_SHADOW
    CLOUDY = _geocal.WorldView2CloudMask_CLOUDY
    def __init__(self, *args): 
        """
        WorldView2CloudMask::WorldView2CloudMask(const RasterImageMultiBand &Mul_spec_data, int Min_cloud_size, double
        Cloud_threshold, double Shadow_threshold)
        Constructor. 
        """
        _geocal.WorldView2CloudMask_swiginit(self,_geocal.new_WorldView2CloudMask(*args))
    __swig_destroy__ = _geocal.delete_WorldView2CloudMask
WorldView2CloudMask_swigregister = _geocal.WorldView2CloudMask_swigregister
WorldView2CloudMask_swigregister(WorldView2CloudMask)

class DoughnutAverage(CalcRasterMultiBand):
    """
    This class does a "doughnut average" of an underlying RasterImage.

    This produces the average value of all the pixels in a given window
    size, excluding a smaller doughnut. We exclude all points that a value
    of 0 in the average (e.g., the normal gore used in VICAR images), as
    well as all points that are beyond the edge of the image. We also
    preserve gore, so if a point has a value of 0 in any of the bands then
    we set the doughnut average to 0 for that point.

    Depending on the application, you may or may not want to include
    points that have gore within the doughnut window. You can specify this
    in the constructor. If "Allow_gore" is true, then any point other
    than the center can be gore and we just exclude it from the average.
    If "Allow_gore" is false, we set a value to 0 if any value in the
    window is 0. In all cases, we set a value to 0 if the center is 0.

    This is one of the building block used to do the "cvdnorm", you can
    consult that program for details. But basically this is used to
    examine small features (smaller than the doughnut whole) that are
    significantly different than the nearby background.

    C++ includes: doughnut_average.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        DoughnutAverage::DoughnutAverage(const boost::shared_ptr< RasterImageMultiBand > &Rimg, int
        Window_size=11, int Doughnut_size=5, bool Allow_gore=true, int
        Number_tile_line=-1, int Number_tile_sample=-1, int Number_tile=4)
        Constructor.

        Parameters:
        -----------

        Rimg:  The underlying image we are producing the average for.

        Window_size:  The window size we are averaging. Should be odd number.

        Doughnut_size:  The doughnut we are excluding in the average. Should
        be odd, and < Window_size. 
        """
        _geocal.DoughnutAverage_swiginit(self,_geocal.new_DoughnutAverage(*args))
    def cvdnorm(self, *args):
        """
        Array< double, 2 > DoughnutAverage::cvdnorm(int band, int Lstart, int Sstart, int Number_line, int Number_sample)
        const
        Very closely related in the doughnut average is the cvdnorm for one of
        the bands.

        So we provide the calculation for that. 
        """
        return _geocal.DoughnutAverage_cvdnorm(self, *args)

    def pandif(self, *args):
        """
        blitz::Array< double, 2 > DoughnutAverage::pandif(int Lstart, int Sstart, int Number_line, int Number_sample) const
        This is the difference of the first two cvdnorm bands. 
        """
        return _geocal.DoughnutAverage_pandif(self, *args)

    def cvdnorm_raster_image(self, *args):
        """
        boost::shared_ptr< RasterImage > DoughnutAverage::cvdnorm_raster_image(int band) const
        Present the cvdnorm as a RasterImage. 
        """
        return _geocal.DoughnutAverage_cvdnorm_raster_image(self, *args)

    def _pandif_raster_image(self):
        """
        boost::shared_ptr< RasterImage > DoughnutAverage::pandif_raster_image() const
        Present the pandif as a RasterImage. 
        """
        return _geocal.DoughnutAverage__pandif_raster_image(self)

    @property
    def pandif_raster_image(self):
        return self._pandif_raster_image()

    def _window_size(self):
        """
        int GeoCal::DoughnutAverage::window_size() const
        The window size. 
        """
        return _geocal.DoughnutAverage__window_size(self)

    @property
    def window_size(self):
        return self._window_size()

    def _doughnut_size(self):
        """
        int GeoCal::DoughnutAverage::doughnut_size() const
        The doughnut size. 
        """
        return _geocal.DoughnutAverage__doughnut_size(self)

    @property
    def doughnut_size(self):
        return self._doughnut_size()

    def _allow_gore(self):
        """
        bool GeoCal::DoughnutAverage::allow_gore() const
        If true, we allow gore in a window and just exclude it in the average.

        Otherwise we set a point to 0 if any point in the window is 0. 
        """
        return _geocal.DoughnutAverage__allow_gore(self)

    @property
    def allow_gore(self):
        return self._allow_gore()

    __swig_destroy__ = _geocal.delete_DoughnutAverage
DoughnutAverage.cvdnorm = new_instancemethod(_geocal.DoughnutAverage_cvdnorm,None,DoughnutAverage)
DoughnutAverage.pandif = new_instancemethod(_geocal.DoughnutAverage_pandif,None,DoughnutAverage)
DoughnutAverage.cvdnorm_raster_image = new_instancemethod(_geocal.DoughnutAverage_cvdnorm_raster_image,None,DoughnutAverage)
DoughnutAverage._pandif_raster_image = new_instancemethod(_geocal.DoughnutAverage__pandif_raster_image,None,DoughnutAverage)
DoughnutAverage._window_size = new_instancemethod(_geocal.DoughnutAverage__window_size,None,DoughnutAverage)
DoughnutAverage._doughnut_size = new_instancemethod(_geocal.DoughnutAverage__doughnut_size,None,DoughnutAverage)
DoughnutAverage._allow_gore = new_instancemethod(_geocal.DoughnutAverage__allow_gore,None,DoughnutAverage)
DoughnutAverage_swigregister = _geocal.DoughnutAverage_swigregister
DoughnutAverage_swigregister(DoughnutAverage)

class MaterialDetect(CalcRaster):
    """
    This class is used to do change detection and identify the material
    for pixels that have changed.

    This duplicates what was done in the VICAR proc "detwvpan", and in
    particular the "f2ratio" process.

    We read a IBIS file that describes the thresholds for a number of
    material classes. For each material class, we do the following:

    First, the difference in the pan bands is compared to a threshold. The
    difference is normally calculated by DoughnutAverage, using the
    pandif_raster_image. But something else could be used, all this class
    cares about is having a difference it can compare against a threshold.

    Compare pan data to a shadow threshold. This masks at very dark pixels
    that we assume are in shadow.

    For each point, we calculate the required ratios between the
    multispectral bands, take the difference with the supplied class mean
    and divide by the class sigma.

    We sum the abs value of for each of the band ratios divided by the
    number of band ratios (i.e, we use a L1 norm). This is compared
    against a second threshold.

    We may have more than one class that passes the second threshold. In
    that case, we sort the classes first by a class priority (with the
    lower number being selected first). For ties, we then pick the class
    that has the smallest difference norm.

    C++ includes: material_detect.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        MaterialDetect::MaterialDetect(const boost::shared_ptr< RasterImage > &Pan_data, const
        boost::shared_ptr< RasterImage > &Pan_diff, const boost::shared_ptr<
        RasterImageMultiBand > &Mulspect, const blitz::Array< double, 1 >
        &Pan_diff_threshold, const blitz::Array< double, 1 >
        &Spectral_diff_threshold, const blitz::Array< int, 1 >
        &Class_priority, const std::string &Ibis_fname, double
        Pan_shadow_threshold)
        Constructor.

        This takes the pan difference band (normally pandif_raster_image from
        DoughnutAverage), the multispectral bands, the threshold for each
        material for the pan difference and spectral difference, the class
        priority for eahc class, and the name of the IBIS file to get the
        material information.

        The IBIS file should have at least 5 columns (which is all that we
        read). The first two columns should be full word values, and are the
        band indices (1 based, rather than the 0 based we use elsewhere). The
        third should be double (for no good reason, it just is), which is the
        class id. The fourth and fifth are also double, and are the mean and
        sigma for that band ratio.

        In generate, the class ID doesn't start from 0. We find the minimum
        value in the table, and use that as the index into Pan_diff_threshold
        etc. (so if first id is 8881 then the threshold for 8881 is
        Pan_diff_threshold[0] and 8885 is Pan_diff_threshold[4]). Obviously we
        could have just used a map instead, but this convention fits better
        with the current way we supply this values in the Shiva scripts. 
        """
        _geocal.MaterialDetect_swiginit(self,_geocal.new_MaterialDetect(*args))
    def _closest_material_raster_image(self):
        """
        boost::shared_ptr< RasterImage > MaterialDetect::closest_material_raster_image() const
        This returns an image that gives the distance to the closest material
        (whose class id will vary from pixel to pixel).

        By convention we multiple this difference by 100 so it can be viewed
        more easily in xvd (which prefers integers). 
        """
        return _geocal.MaterialDetect__closest_material_raster_image(self)

    @property
    def closest_material_raster_image(self):
        return self._closest_material_raster_image()

    @property
    def material_raster_image(self):
        return self._material_raster_image()

    def _material_raster_image(self, *args):
        """
        boost::shared_ptr< RasterImage > MaterialDetect::material_raster_image(int Class_id) const
        This returns a set image that gives the distance to the given
        material.

        By convention we multiple this difference by 100 so it can be viewed
        more easily in xvd (which prefers integers). 
        """
        return _geocal.MaterialDetect__material_raster_image(self, *args)

    def closest_material_dif(self, *args):
        """
        blitz::Array< double, 2 > MaterialDetect::closest_material_dif(int Lstart, int Sstart, int Number_line, int Number_sample) const
        Calculate distance for every point from the nearest material.

        By convention we multiple this by 100. 
        """
        return _geocal.MaterialDetect_closest_material_dif(self, *args)

    def material_dif(self, *args):
        """
        blitz::Array< double, 2 > MaterialDetect::material_dif(int Lstart, int Sstart, int Number_line, int Number_sample, int
        Class_id) const
        Calculate the distance for every point from the given material.

        By convention we multiple this by 100. 
        """
        return _geocal.MaterialDetect_material_dif(self, *args)

    __swig_destroy__ = _geocal.delete_MaterialDetect
MaterialDetect._closest_material_raster_image = new_instancemethod(_geocal.MaterialDetect__closest_material_raster_image,None,MaterialDetect)
MaterialDetect._material_raster_image = new_instancemethod(_geocal.MaterialDetect__material_raster_image,None,MaterialDetect)
MaterialDetect.closest_material_dif = new_instancemethod(_geocal.MaterialDetect_closest_material_dif,None,MaterialDetect)
MaterialDetect.material_dif = new_instancemethod(_geocal.MaterialDetect_material_dif,None,MaterialDetect)
MaterialDetect_swigregister = _geocal.MaterialDetect_swigregister
MaterialDetect_swigregister(MaterialDetect)

class PaintClass(CalcRasterMultiBand):
    """
    This takes two images, a image with the class ID and a pan band.

    It then produces a three color image that is either the given pan band
    or a color given by the class ID if the class ID is > 0.

    This duplicates what was done with f2multi. This is a pretty specific
    routine, and is likely to be replaced with something else at some
    point.

    C++ includes: paint_class.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        PaintClass::PaintClass(const boost::shared_ptr< RasterImage > &Class_id_img, const
        boost::shared_ptr< RasterImage > &Pan_img, const blitz::Array< int, 2
        > &Color, int Class_id_first_color=8881)

        """
        _geocal.PaintClass_swiginit(self,_geocal.new_PaintClass(*args))
    __swig_destroy__ = _geocal.delete_PaintClass
PaintClass_swigregister = _geocal.PaintClass_swigregister
PaintClass_swigregister(PaintClass)



