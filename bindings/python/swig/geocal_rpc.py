# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
from ._swig_wrap import _geocal_rpc

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _geocal_rpc.SWIG_PyInstanceMethod_New
_swig_new_static_method = _geocal_rpc.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_MODULE_ALREADY_DONE = _geocal_rpc.SWIG_MODULE_ALREADY_DONE
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _geocal_rpc.delete_SwigPyIterator
    value = _swig_new_instance_method(_geocal_rpc.SwigPyIterator_value)
    incr = _swig_new_instance_method(_geocal_rpc.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_geocal_rpc.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_geocal_rpc.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_geocal_rpc.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_geocal_rpc.SwigPyIterator_copy)
    next = _swig_new_instance_method(_geocal_rpc.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_geocal_rpc.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_geocal_rpc.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_geocal_rpc.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_geocal_rpc.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_geocal_rpc.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_geocal_rpc.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_geocal_rpc.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_geocal_rpc.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_geocal_rpc.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _geocal_rpc:
_geocal_rpc.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _geocal_rpc.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_function.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_function.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.generic_object
import geocal_swig.with_parameter
import geocal_swig.geocal_exception
class Rpc(geocal_swig.generic_object.GenericObject):
    r"""

    This is used to handle RPC (Rational Polynomial Coefficients).

    RPC is an alternative to using a rigorous camera/orbit model to map
    project satellite data.

    This is a common technique, and there are numerous references. One
    reference is Fraser, CS, Dial, G, Grodecki, J "Sensor orientation via
    RPCs" ISPRS J PHOTOGRAMM 60 (3): 182-194 MAY 2006.

    Note that there are two versions of the RPCs, type "A" and type
    "B". The difference is the order of the terms. The military tends to
    use "A" and the rest of the world tends to use "B". This class
    supports both types, based on the setting of the rpc_type variable.

    By definition of RPC, the leading term of the denominator coefficient
    should be 1.0 - so there are 20 degrees of freedom for the numerator
    but only 19 for the denominator. After some debate, I decided to do
    nothing in this class to enforce this restriction, you can assign a
    value other than 1 to the first coefficient of the denominator.
    However, this class will complain when you actually try to use this.

    The definition of line, sample and height offset and scale allow these
    numbers to be floats. However file formats such as geotiff and NITF
    treat these as integers. If you store a RPC into a file with one of
    these formats, the data will be truncated. If you plan on saving to
    one of these formats, you should be aware of this and keep these an
    whole numbers. This limitation is not present in the VICAR file
    format.

    It has never been 100% clear what "line and sample" means according
    to the standard. The best I can determine, the RPC is set up so
    integer values are the center of a pixel, e.g., (0,0) is the center of
    the upper left pixel. This seems to be the convention used by WV-2,
    seehttps://trac.osgeo.org/gdal/ticket/5993. Note that GDAL uses a
    convention where the upper left corner of the bounding box is (0,0)
    (so the center of the pixel is (0.5,0.5)). This is not the convention
    used by ImageCoordinate, so while the referenced ticket mentions a 0.5
    offset being needed we don't actually need to do that in our code.

    C++ includes: geocal_rpc.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __str__ = _swig_new_instance_method(_geocal_rpc.Rpc___str__)
    RPC_A = _geocal_rpc.Rpc_RPC_A
    RPC_B = _geocal_rpc.Rpc_RPC_B
    rpc_type = property(_geocal_rpc.Rpc_rpc_type_get, _geocal_rpc.Rpc_rpc_type_set)
    error_bias = property(_geocal_rpc.Rpc_error_bias_get, _geocal_rpc.Rpc_error_bias_set)
    error_random = property(_geocal_rpc.Rpc_error_random_get, _geocal_rpc.Rpc_error_random_set)
    height_offset = property(_geocal_rpc.Rpc_height_offset_get, _geocal_rpc.Rpc_height_offset_set)
    height_scale = property(_geocal_rpc.Rpc_height_scale_get, _geocal_rpc.Rpc_height_scale_set)
    latitude_offset = property(_geocal_rpc.Rpc_latitude_offset_get, _geocal_rpc.Rpc_latitude_offset_set)
    latitude_scale = property(_geocal_rpc.Rpc_latitude_scale_get, _geocal_rpc.Rpc_latitude_scale_set)
    longitude_offset = property(_geocal_rpc.Rpc_longitude_offset_get, _geocal_rpc.Rpc_longitude_offset_set)
    longitude_scale = property(_geocal_rpc.Rpc_longitude_scale_get, _geocal_rpc.Rpc_longitude_scale_set)
    line_offset = property(_geocal_rpc.Rpc_line_offset_get, _geocal_rpc.Rpc_line_offset_set)
    line_scale = property(_geocal_rpc.Rpc_line_scale_get, _geocal_rpc.Rpc_line_scale_set)
    sample_offset = property(_geocal_rpc.Rpc_sample_offset_get, _geocal_rpc.Rpc_sample_offset_set)
    sample_scale = property(_geocal_rpc.Rpc_sample_scale_get, _geocal_rpc.Rpc_sample_scale_set)
    _v_line_denominator = _swig_new_instance_method(_geocal_rpc.Rpc__v_line_denominator)

    @property
    def line_denominator(self):
        return self._v_line_denominator()

    @line_denominator.setter
    def line_denominator(self, value):
      self._v_line_denominator(value)

    _v_line_numerator = _swig_new_instance_method(_geocal_rpc.Rpc__v_line_numerator)

    @property
    def line_numerator(self):
        return self._v_line_numerator()

    @line_numerator.setter
    def line_numerator(self, value):
      self._v_line_numerator(value)

    _v_sample_denominator = _swig_new_instance_method(_geocal_rpc.Rpc__v_sample_denominator)

    @property
    def sample_denominator(self):
        return self._v_sample_denominator()

    @sample_denominator.setter
    def sample_denominator(self, value):
      self._v_sample_denominator(value)

    _v_sample_numerator = _swig_new_instance_method(_geocal_rpc.Rpc__v_sample_numerator)

    @property
    def sample_numerator(self):
        return self._v_sample_numerator()

    @sample_numerator.setter
    def sample_numerator(self, value):
      self._v_sample_numerator(value)

    _v_fit_line_numerator = _swig_new_instance_method(_geocal_rpc.Rpc__v_fit_line_numerator)

    @property
    def fit_line_numerator(self):
        return self._v_fit_line_numerator()

    @fit_line_numerator.setter
    def fit_line_numerator(self, value):
      self._v_fit_line_numerator(value)

    _v_fit_sample_numerator = _swig_new_instance_method(_geocal_rpc.Rpc__v_fit_sample_numerator)

    @property
    def fit_sample_numerator(self):
        return self._v_fit_sample_numerator()

    @fit_sample_numerator.setter
    def fit_sample_numerator(self, value):
      self._v_fit_sample_numerator(value)

    _v_naif_code = _swig_new_instance_method(_geocal_rpc.Rpc__v_naif_code)

    @property
    def naif_code(self):
        return self._v_naif_code()

    @naif_code.setter
    def naif_code(self, value):
      self._v_naif_code(value)

    coordinate_converter = property(_geocal_rpc.Rpc_coordinate_converter_get, _geocal_rpc.Rpc_coordinate_converter_set)
    resolution_meter = _swig_new_instance_method(_geocal_rpc.Rpc_resolution_meter)
    fit = _swig_new_instance_method(_geocal_rpc.Rpc_fit)
    fit_all = _swig_new_instance_method(_geocal_rpc.Rpc_fit_all)
    generate_rpc = _swig_new_static_method(_geocal_rpc.Rpc_generate_rpc)
    ground_coordinate = _swig_new_instance_method(_geocal_rpc.Rpc_ground_coordinate)
    image_coordinate = _swig_new_instance_method(_geocal_rpc.Rpc_image_coordinate)
    image_coordinate_jac_parm = _swig_new_instance_method(_geocal_rpc.Rpc_image_coordinate_jac_parm)
    image_coordinate_jac = _swig_new_instance_method(_geocal_rpc.Rpc_image_coordinate_jac)
    rpc_project = _swig_new_instance_method(_geocal_rpc.Rpc_rpc_project)
    rpc_type_a = _swig_new_instance_method(_geocal_rpc.Rpc_rpc_type_a)
    rpc_type_b = _swig_new_instance_method(_geocal_rpc.Rpc_rpc_type_b)

    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)


    def __init__(self, *args):
        r"""

        Rpc::Rpc()
        GeoCal::Rpc::Rpc
        Default constructor.
        Initializes fit_line_numerator and fit_sample_numerator to all false.

        """
        _geocal_rpc.Rpc_swiginit(self, _geocal_rpc.new_Rpc(*args))
    __swig_destroy__ = _geocal_rpc.delete_Rpc

# Register Rpc in _geocal_rpc:
_geocal_rpc.Rpc_swigregister(Rpc)

__all__ = ["Rpc"]


