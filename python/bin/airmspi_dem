#! /usr/bin/env python
from afids import *
import os
import logging
import time

version = "October 15, 2013"
usage='''Usage:
  airmspi_dem [options] <image_1> <image_nadir> <image_2> <output_dir>
  airmspi_dem  -h | --help
  airmspi_dem  -v | --version

This generates a AirMSPI DEM. It takes a pair of images (in Level 2 HDF 
format), along with a nadir image. The results are placed in a given output
directory (which is created if it doesn't already exist).

Options:
  -h --help         
       Print this message

  --avg-level=d
       How much to average the 10 meter to for generating the DEM. For
       clear scenes you can just do this at full resolution, but for 
       clouds a value of "3" seems to work well in practice. This is the
       power of 2 to average the data by, so "3" is 2^3 = 8, meaning we
       generate 80m pixels. [default: 0]

  --image1-index=d
       Index to use for the first image in DEM generation. This is in the
       same order the images are listed on the command line. [default: 0]

  --image2-index=d
       Index to use for the second image in DEM generation. This is in the
       same order the images are listed on the command line. [default: 2]

  --max-distance-good-point=f
       How far apart the intersection of the rays from the conjugate points
       can be and we still call this is a good match. You will want to raise
       this number considerable if you are working with clouds, the example
       we've done showed 80.0 as a good number. [default: 2.0]

  --number-process=n
       Number of processors to use. [default: 1]

  --use-dependency
       By default, we just run all steps. It can be useful, particularly 
       when debugging, to only run a step if the input is newer than the
       output (a la Makefile). Select this option of you want that behavior.

  --verbose
       Print more information as we run.

  -v --version      
       Print program version
'''

args = docopt_simple(usage, version=version)
if(args.verbose):
    logging.basicConfig(level = logging.INFO)
log = logging.getLogger("airmspi_dem")
tstart = time.time()

# Right now this is hardcoded. We have this called out, in case we want 
# to change this at some point.
img1_index = args.image1_index
img2_index = args.image2_index
average_factor = int(pow(2, args.avg_level))
dem_resolution = 10 * average_factor

# Get input files
img1_name = os.path.abspath(args.image_1)
img2_name = os.path.abspath(args.image_2)
imgnadir_name = os.path.abspath(args.image_nadir)

# Few things that appear often enough that it is worth stashing.
dbfile = "airmspi_dem.db:"
nproc = "--number-process=%d" % args.number_process

@contextmanager
def timing(txt):
    log.info(txt)
    tstart2 = time.time()
    yield
    log.info("Delta Time: %f" % (time.time() - tstart2))
    log.info("Total Time: %f" % (time.time() - tstart))

def track_dependency(outp, *inp):
    '''Return True if we need to rebuild outp'''
    if(args.use_dependency):
        for i in inp:
            if(not shelve_time_after(outp, i)):
                return True
        log.info("Skipping generation of %s, it is up to date" % outp)
        return False
    return True

# 1. Create the output directory, if it doesn't already exist.
subprocess.check_call(["mkdir", "-p", args.output_dir])
os.chdir(args.output_dir)

# 2. Create initial ImageGroundConnections. These are slow, because they
# are implemented in python
with timing("Initial ImageGroundConnections"):
    if track_dependency(dbfile + "igc1_slow", img1_name):
        subprocess.check_call(["shelve_airmspi_igc", img1_name, "Image 1",
                               dbfile + "igc1_slow"])
    if track_dependency(dbfile + "igc2_slow", img2_name):
        subprocess.check_call(["shelve_airmspi_igc", img2_name, "Image 2",
                               dbfile + "igc2_slow"])
    if track_dependency(dbfile + "igc_nadir_slow", imgnadir_name):
        subprocess.check_call(["shelve_airmspi_igc", imgnadir_name, 
                               "Nadir Image", dbfile + "igc_nadir_slow"])

# 3. Create RPC approximations
with timing("RPC approximations"):
    if track_dependency(dbfile + "igc1", dbfile + "igc1_slow"):
        subprocess.check_call(["igc_to_rpc", "--rpc-line-fit=0", 
                               "--rpc-sample-fit=0",
                               dbfile + "igc1_slow", dbfile + "igc1"])
    if track_dependency(dbfile + "igc2", dbfile + "igc2_slow"):
        subprocess.check_call(["igc_to_rpc", "--rpc-line-fit=0", 
                               "--rpc-sample-fit=0",
                           dbfile + "igc2_slow", dbfile + "igc2"])
    if track_dependency(dbfile + "igc_nadir", dbfile + "igc_nadir_slow"):
        subprocess.check_call(["igc_to_rpc", 
                               dbfile + "igc_nadir_slow", dbfile + "igc_nadir"])

# 4. Put into IgcCollection
with timing("IgcCollection"):
    if track_dependency(dbfile + "igc_initial", dbfile + "igc1",
                        dbfile + "igc2", dbfile + "igc_nadir"):
        subprocess.check_call(["shelve_igccol", "--from-shelve",
                               dbfile + "igc_initial", 
                               dbfile + "igc1", dbfile + "igc_nadir",
                               dbfile + "igc2"])

# 5. Collect tiepoints
with timing("Collect tiepoints"):
    if track_dependency(dbfile + "tpcol", dbfile + "igc_initial"):
        cmd = ["tp_collect", "--max-ground-sigma=300",
               dbfile + "igc_initial", dbfile + "tpcol"]
        if(args.avg_level > 0):
            cmd.append("--avg-level=%d" % args.avg_level)
        subprocess.check_call(cmd)

# 6. Run SBA
# Note really big DEM sigma. We don't actually have functionality in place
# to skip the surface constraint, but the essientially reduces the weight of
# it to almost 0
with timing("SBA"):
    cmd = ["sba","--dem-sigma=10000", dbfile + "igc_initial", dbfile + "tpcol",
           dbfile + "igc_sba", dbfile + "tpcol_sba"]
    if(args.verbose):
        cmd.append("--verbose")
    if track_dependency(dbfile + "igc_sba", dbfile + "tpcol",
                        dbfile + "igc_initial"):
        subprocess.check_call(cmd)

# 7. Project to surface. Note parallel writing doesn't work here, there
# is a bug we haven't tracked down yet in using HDF/GDAL files as input
# for parallel runs.
with timing("Project to surface"):
    if track_dependency(dbfile + "surface_1", dbfile + "igc_sba"):
        subprocess.check_call(["igc_project", "--grid-spacing=10",
                               "--resolution=10", dbfile + "igc_sba",
                               str(img1_index), dbfile + "surface_1_init"])
        subprocess.check_call(["write_image", dbfile + "surface_1_init",
                              "img1_surf.img"])
        subprocess.check_call(["shelve_image", "img1_surf.img", 
                               dbfile + "surface_1"])
    if track_dependency(dbfile + "surface_2", dbfile + "surface_1",
                        dbfile + "igc_sba"):
        subprocess.check_call(["igc_project", "--grid-spacing=10",
                               "--map-info=" + dbfile + "surface_1", 
                               dbfile + "igc_sba",
                               str(img2_index), dbfile + "surface_2_init"])
        subprocess.check_call(["write_image", dbfile + "surface_2_init",
                              "img2_surf.img"])
        subprocess.check_call(["shelve_image", "img2_surf.img", 
                               dbfile + "surface_2"])

# 8. Generate DEM
with timing("Generate DEM"):
    if track_dependency(dbfile + "dem", dbfile + "igc_sba", 
                        dbfile + "surface_1",
                        dbfile + "surface_2"):
        cmd = ["dem_generate", "--resolution=%f" % dem_resolution,
               "--max-distance-good-point=%f" % args.max_distance_good_point,
               "--airmspi-image-match",
               dbfile + "igc_sba", dbfile + "surface_1",
               dbfile + "surface_2", str(img1_index), str(img2_index),
               dbfile + "dem_init"]
        if(average_factor > 1):
            cmd.append("--average=%d" % average_factor)
        subprocess.check_call(cmd)
        cmd = ["write_image", "--vicar-type=DOUB", "--no-data-value=-9999",
               nproc, dbfile + "dem_init",
               "dem_generated_%dm_nofill.img" % dem_resolution,
               "dem_generated_%dm.img" % dem_resolution]
        if(args.verbose):
            cmd.append("--verbose")
        subprocess.check_call(cmd)
        subprocess.check_call(["shelve_dem", 
                               "dem_generated_%dm.img" % dem_resolution,
                               dbfile + "dem"])



