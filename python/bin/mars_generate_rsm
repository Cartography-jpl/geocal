#! /usr/bin/env python
#
# This takes a unprojected PDS file, imports it to VICAR, and adds a
# RSM.

import geocal
import os
import subprocess
import matplotlib.pylab as plt
import matplotlib as mpl
import seaborn as sns
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np

version = "May 16, 2017"
usage='''Usage:
  mars_generate_rsm [options] <pds_image> <output_base_name>
  mars_generate_rsm -h | --help
  mars_generate_rsm -v | --version

mars_generate_rsm takes an unprojected PDS image, imports it to VICAR, 
and adds a RSM.

We do not do any radiance correction (e.g., dark current subtraction),
we just pass through the DNs unchanged. However, for CTX camera the
data is at level 0 is normally SQRT encoded. We do expand that out to 
unencoded data.

Currently the specific forms of the RSM are hard coded based on the 
instrument type.

It is not clear what we should do with masked pixels (e.g., CTX), right 
now, we are just removing them.

We are not currently including camera nonlinearities (e.g., HRSC), this 
is something we could add in the future.

Example:
    mars_generate_rsm /raid26/tllogan/mars/mawrth_vallis/source/unmapped/P16_007388_2049_XI_24N020W.IMG ctx1
    rsm_project --grid-spacing=10 --map-info=ctx1_ref_img.xml --number-process=20 --verbose --process-number-line=1000 --process-number-sample=1000 ctx1.img ctx1_proj.img

Options:
  -h --help         
       Print this message

  --full-igc=f
       For diagnostic purposes, it can be useful to have the full IGC (i.e.,
       the one with the camera model, spice kernel, etc.). This is what we
       are approximating with the RSM.

  --min-height=d
       Minimum DEM height we create RSM for. Note this doesn't need to be
       super accurate, just a reasonable value that is lower than any height
       we will encounter over the area [default: -5000.0]

  --max-height=d
       Maximum DEM height we create RSM for. Note this doesn't need to be
       super accurate, just a reasonable value that is lower than any height
       we will encounter over the area [default: -1500.0]

  --plot-cross-section=f
       To evaluate the quality of the generated RSM, this takes a cross 
       section for all lines, and 5 equally spaced samples and plots the 
       difference between the calculated line and sample vs. what the
       full ImageGroundConnection calculation creates. Output is a PDF
       file.

  --subset=f
       Subset the image. This should be the start line, start sample, number
       line and number sample.
 
  -v --version      
       Print program version
'''

# Mapping between long name and shorter vicar name
long_name_to_vicar = { "pds_image" : "pdsimg",
                       "output_base_name" : "outbase",
                       "full_igc" : "fulligc",
                       "min_height" : "minh",
                       "max_height" : "maxh",
                       "plot_cross_section" : "plot" }

args = geocal.docopt_simple(usage, version=version,
                     long_name_to_vicar=long_name_to_vicar)

def plot_diff(r, igc, fname):
    pdf = PdfPages(fname)
    dem_nominal = (args.max_height + args.min_height) / 2.0
    ln, smp, lncalc, smpcalc = r.compare_igc(igc, igc.number_line, 5,
                                             dem_nominal)
    print("Max line diff:   ", np.nanmax(abs(ln-lncalc)), " at ",
          np.unravel_index(np.nanargmax(abs(ln-lncalc)), ln.shape))
    print("Max sample diff: ", np.nanmax(abs(smp-smpcalc)), " at ",
          np.unravel_index(np.nanargmax(abs(smp-smpcalc)), smp.shape))

    cmap = mpl.colors.ListedColormap(sns.color_palette("RdBu_r", 256))
    plt.clf()
    for i in range(smp.shape[1]):
        plt.plot(ln[:,i], lncalc[:,i] - ln[:,i], label="Sample %d" % smp[0,i])
    plt.legend()
    plt.title("Line diff")
    plt.xlabel("Line")
    plt.ylabel("Diff")
    pdf.savefig()
    plt.clf()
    for i in range(smp.shape[1]):
        plt.plot(ln[:,i], smpcalc[:,i] - smp[:,i], label="Sample %d" % smp[0,i])
    plt.legend()
    plt.title("Sample diff")
    plt.xlabel("Line")
    plt.ylabel("Diff")
    pdf.savefig()
    plt.clf()
    
    pdf.close()

# Note, when adding a new instrument there are a few good sanity things to
# check:
# 1. Check check_rc_assumption, this verifies that we have line, sample, and
#    look directions nearly orthogonal. If you have the camera rotated wrong,
#    you can catch that because the dot products won't be close to 0.
# 2. Compare spice calculation of boresight with the full Igc calculation. This
#    makes sure you have things lined up right.
# 3. It is also worth comparing data projected by our code vs. data that
#    has gone through ISIS. We won't line up exactly, but it should be pretty
#    close. This helps find gross errors in our models, etc.

def igc_for_context(lbl, fname):
    '''Process for context camera'''
    tstart = geocal.Time.parse_time(lbl["START_TIME"])
    bdir = os.environ["MARS_KERNEL"] + "/mro_kernel/"
    kdat = geocal.read_shelve(bdir + "kernel.json")
    # We need better logic here, but for now just set up the kernels we
    # handed
    klist = [bdir + "mro.ker",
             kdat["ck_kernel"].kernel(tstart),
             kdat["spk_kernel"].kernel(tstart)]
    orb = geocal.SpicePlanetOrbit("MRO", "MRO_CTX", klist,
                           geocal.PlanetConstant.MARS_NAIF_CODE)
    img = geocal.GdalRasterImage(fname)
    # We have masked pixels in the L1 data, which we want to chop out
    left_masked = 38
    right_masked = 18
    img = geocal.SubRasterImage(img, 0, left_masked, img.number_line, 5000)
    if(lbl["SAMPLE_BIT_MODE_ID"] == "SQROOT"):
        img = geocal.ContextSqrtDecodeImage(img)
    # The START_TIME is the commanded start time, the actual start time
    # might be different. According to the CTX SIS (available at
    # https://pdsimage2.wr.usgs.gov/archive/mro-m-ctx-2-edr-l0-v1.0/mrox_0452/document/
    #), we should use the SPACECRAFT_CLOCK_START_COUNT instead. Should be
    # pretty close to START_TIME. Note that we use START_TIME first because
    # we need to read the spice kernels before being able to convert SCLK to
    # time.
    tstart = geocal.Time.time_sclk(lbl["SPACECRAFT_CLOCK_START_COUNT"], "MRO")
    # 1e-3 is because LINE_EXPOSURE_DURATION is in milliseconds.
    tspace = float(lbl["LINE_EXPOSURE_DURATION"].split(" ")[0]) * 1e-3
    tt = geocal.ConstantSpacingTimeTable(tstart, tstart + tspace * (img.number_line-1),
                                  tspace)
    dem = geocal.PlanetSimpleDem(geocal.PlanetConstant.MARS_NAIF_CODE)
    orb_cache = geocal.OrbitListCache(orb, tt)
    ipi = geocal.Ipi(orb_cache, geocal.ctx_camera(), 0, tt.min_time, tt.max_time, tt)
    igc = geocal.IpiImageGroundConnection(ipi, dem, img)
    return igc

def rsm_for_context(lbl, fname, subset=None):
    '''This generates a RSM for a MRO Context image. We return the Rsm, 
    and the original igc. This strips off the masked pixels. Not sure if this
    is what we ultimately want or not, but it is what we do here.'''
    igc = igc_for_context(lbl, fname)
    if(subset is not None):
        igc = geocal.OffsetImageGroundConnection(igc, subset[0], subset[1],
                                              subset[2], subset[3])
    # In order for LocalRcParameter to be useful, the look, sample, and line
    # directions need to be mostly orthogonal. So dot product of unit vectors
    # should be close to 0
    if(False):
        geocal.LocalRcParameter.check_rc_assumption(igc)

    # Verify that we calculate nearly the same boresight at SPICE.
    if(False):
        ic = geocal.ImageCoordinate(200, igc.number_sample / 2)
        pts = geocal.SpiceHelper.boresight_and_footprint(igc.pixel_time(ic),
                                         geocal.PlanetConstant.MARS_NAIF_CODE,
                                         "MRO", "MRO_CTX")
        print("Distance spice boresight and IGC: ",
              distance(pts[0], igc.ground_coordinate(ic)))
        print(igc.image_coordinate(pts[0]))

    r = geocal.Rsm(geocal.RsmRpPlusGrid(geocal.RsmRationalPolynomial(5,5,3,1,1,1,5,1,
                                                40, 40, 20, 40),
                          geocal.RsmGrid(3, 1000, 50)),
            geocal.LocalRcConverter(geocal.LocalRcParameter(igc)))
    r.fit(igc, args.min_height, args.max_height)
    return r, igc
    
def igc_for_hrsc(lbl, fname):
    '''Process for HRSC camera'''
    tstart = geocal.Time.parse_time(lbl["START_TIME"])
    tend = geocal.Time.parse_time(lbl["STOP_TIME"])
    if(lbl["DETECTOR_ID"] != "MEX_HRSC_NADIR"):
        raise RuntimeError("Right now we only work with MEX_HRSC_NADIR")
    bdir = os.environ["MARS_KERNEL"] + "/mex_kernel/"
    kdat = geocal.read_shelve(bdir + "kernel.json")
    # We need better logic here, but for now just set up the kernels we
    # handed
    klist = [bdir + "mex.ker",
             kdat["ck_kernel"].kernel(tstart),
             kdat["spk_kernel"].kernel(tstart),
             bdir + "mex_reconstituted.ker"]
    orb = geocal.SpicePlanetOrbit("MEX", "MEX_HRSC_HEAD", klist,
                           geocal.PlanetConstant.MARS_NAIF_CODE)
    img = geocal.GdalRasterImage(fname)
    # The PDS image has a byte label in the front of each line. GDAL
    # doesn't read this (it just skips it), but we can read it directly.
    # The byte label is described in HRSC_LABEL_HEADER.PDF
    # (at ftp://psa.esac.esa.int/pub/mirror/MARS-EXPRESS/HRSC/MEX-M-HRSC-3-RDR-V3.0/DOCUMENT),
    # but basically the first 8 bytes are just a double that gives the J2000
    # time for that line (and we don't care about anything else in the binary
    # label). We read through the data to create our TimeTable.
    record_bytes = int(lbl['RECORD_BYTES'])
    # This is 1 based, convert to 0 based with -1
    istart = int(lbl['^IMAGE']) - 1
    tlist = geocal.Vector_Time()
    with open(fname, "rb") as f:
        for i in range(istart, istart + img.number_line):
            f.seek(i * record_bytes, 0)
            tlist.push_back(geocal.Time.time_et(struct.unpack("d", f.read(8))[0]))
    tt = geocal.MeasuredTimeTable(tlist)
    dem = geocal.PlanetSimpleDem(geocal.PlanetConstant.MARS_NAIF_CODE)
    orb_cache = geocal.OrbitListCache(orb, tt)
    ipi = geocal.Ipi(orb_cache, geocal.hrsc_camera(), 0, tt.min_time, tt.max_time, tt)
    igc = geocal.IpiImageGroundConnection(ipi, dem, img)
    return igc

def rsm_for_hrsc(lbl, fname, subset=None):
    '''This generates a RSM for a MRO Context image. We return the Rsm, 
    and the original igc. This strips off the masked pixels. Not sure if this
    is what we ultimately want or not, but it is what we do here.
    '''
    igc = igc_for_hrsc(lbl, fname)
    if(subset is not None):
        igc = geocal.OffsetImageGroundConnection(igc, subset[0], subset[1],
                                          subset[2], subset[3])
    # In order for LocalRcParameter to be useful, the look, sample, and line
    # directions need to be mostly orthogonal. So dot product of unit vectors
    # should be close to 0
    if(False):
        geocal.LocalRcParameter.check_rc_assumption(igc)

    # Verify that we calculate nearly the same boresight at SPICE.
    if(False):
        ic = geocal.ImageCoordinate(200, igc.number_sample / 2.0)
        pts = geocal.SpiceHelper.boresight_and_footprint(igc.pixel_time(ic),
                                                  geocal.PlanetConstant.MARS_NAIF_CODE,
                                                  "MEX", "MEX_HRSC_NADIR")
        print("Distance spice boresight and IGC: ",
              distance(pts[0], igc.ground_coordinate(ic)))
        print(igc.image_coordinate(pts[0]))
    
    # Really big image, so break up into a few sections. We should perhaps have
    # a dynamic way to determine this.
    r = geocal.Rsm(geocal.RsmRpPlusGrid(geocal.RsmMultiSection(igc.number_line,
                                          igc.number_sample, 3, 1,
                                geocal.RsmRationalPolynomial(5,5,3,1,1,1,5,1,
                                                      40, 40, 20, 40, False)),
                          geocal.RsmGrid(3, 5000, 50, False)),
            geocal.LocalRcConverter(geocal.LocalRcParameter(igc)))
    r.fit(igc, args.min_height, args.max_height)
    return r, igc

# Determine the image type
lbl = geocal.pds_label(args.pds_image)
subset = None
if args.subset:
    subset = eval(args.subset)
if(lbl['INSTRUMENT_NAME'] == 'CONTEXT CAMERA'):
    r, igc = rsm_for_context(lbl,args.pds_image, subset)
elif(lbl['INSTRUMENT_NAME'] == 'HIGH RESOLUTION STEREO CAMERA'):
    r, igc = rsm_for_hrsc(lbl,args.pds_image, subset)
else:
    raise RuntimeError("Not a recognized instrument name %s" %
                       lbl['INSTRUMENT_NAME'])

# For right now, output the igc so we have record of it
if(args.full_igc):
    geocal.write_shelve(args.full_igc, igc)
    
# Write out the PDS label, in case there is something we need from it
with open(args.output_base_name + ".lbl", "wb") as fh:
    fh.write(geocal.pds_label_text(args.pds_image))
f = geocal.VicarRasterImage(args.output_base_name + ".img", "HALF",
                     igc.number_line, igc.number_sample)
fin = geocal.GdalRasterImage(args.pds_image)
for k in fin.metadata_list():
    if(not fin[k] == "") :
        f[k] = fin[k]
geocal.copy_raster(igc.image, f, True)
f.close()
geocal.write_shelve(args.output_base_name + ".rsm.xml", r)
if(args.plot_cross_section):
    plot_diff(r, igc, args.plot_cross_section)
    

