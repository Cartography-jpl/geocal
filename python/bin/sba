#! /usr/bin/env python
#
# This runs a simultatenous bundle adjustment to adjust the parameters of
# a image ground connnection collection to more closely fit a given set o
# tiepoints.

from afids import *
import numpy as np
import logging

version = "July 11, 2013"
usage='''Usage: 
  sba [options] <igc_in> <tpcol_in> <igc_out> <tpcol_out>
  sba -h | --help
  sba -v | --version

This runs a simultatenous bundle adjustment to adjust the parameters of
a image ground connnection collection to more closely fit a given set of
tiepoints.

The input igc collection and tie point array, and the final output are
given as sqlite shelve objects. The sqlite shelve objects are in
"file:key" format, e.g., "my_data.db:tp".

We output an updated igc collection, and a tie point array with the
ground location of the tie points updated to the final location used
in the SBA.

This requires a DEM to use. Most commonly the same DEM is used for all the
image ground connections in the collection, and this is the same one we
want to use for the SBA. In this case, you don't need to specify the DEM, we
just grab the DEM from the first image ground connection. You can optionally
specify a different DEM to use.

Options:
  -h --help         
       Print this message

  --dem=shelve
       DEM to use, specified as file:key. If not specified, we use the 
       DEM from the first IGC.

  --dem-height-block-adjust
       For poor quality DEMs, we may find that the whole DEM should be
       shifted up or down. If we select this option, then after running the
       SBA we determine the median difference of all the tiepoints from
       the surface. The DEM for each of the image ground connections are
       then adjusted by this amount.

  --dem-sigma=v
       Weighting to give surface constraint from DEM [default: 10.0]

  --gcp-sigma=v
       Weighting to give GCP constraint [default: 10.0]

  --log-file=f
       File name to use as a log file.

  --tp-epsilon=v
       Epsilon to use during the calculation of the tie point Jacobian.
       [default: 1.0]

  --verbose
       Print more information as we run.

  -v --version      
       Print program version
'''

args = docopt_simple(usage, version=version)
if(args.log_file):
    logging.basicConfig(level = logging.INFO,
                        format = '%(asctime)s %(levelname)s:%(name)s:%(message)s',
                        filename = args.log_file)
    if(args.verbose):
        console = logging.StreamHandler(stream=sys.stdout)
        console.setLevel(logging.INFO)
        console.setFormatter(logging.Formatter('%(levelname)s:%(name)s:%(message)s'))
        logging.getLogger("afids-python").addHandler(console)
elif(args.verbose):
    logging.basicConfig(level = logging.INFO)
log = logging.getLogger("afids-python.sba")

igc = read_shelve(args.igc_in)
tpcol = read_shelve(args.tpcol_in)
if(args.dem):
    dem = read_shelve(args.dem)
else:
    dem = igc.dem(0)

sba = SimultaneousBundleAdjustment(igc, tpcol, dem, dem_sigma=args.dem_sigma,
                                   gcp_sigma=args.gcp_sigma,
                                   tp_epsilon=args.tp_epsilon)
v = sba.sba_eq(sba.parameter)
chisq = np.inner(v, v) / (len(v) - len(sba.parameter))

log.info("Initial Chisq: %f" % chisq)
parm = lm_optimize(sba.sba_eq, sba.parameter, sba.sba_jacobian)
sba.parameter = parm
v = sba.sba_eq(sba.parameter)
chisq = np.inner(v, v) / (len(v) - len(sba.parameter))
log.info("Final Chisq: %f" % chisq)

if(args.dem_height_block_adjust):
    d = sba.igc_coll.dem(0)
    sdiff = [ d.distance_to_surface(sba.ground_location(i)) 
              for i in range(len(tpcol)) ]
    hadj = np.median(sdiff)
    log.info("Doing DEM height block adjustment of %f" % hadj)
    d = DemMapInfoOffset(d, hadj)
    sdiff = [ d.distance_to_surface(sba.ground_location(i)) 
              for i in range(len(tpcol)) ]
    for i in range(sba.igc_coll.number_image):
        sba.igc_coll.image_ground_connection(i).dem = d

write_shelve(args.igc_out, sba.igc_coll)
tpcol = sba.tpcol
for i in range(len(tpcol)):
    tpcol[i].ground_location = sba.ground_location(i)
write_shelve(args.tpcol_out, tpcol)
logging.shutdown()

