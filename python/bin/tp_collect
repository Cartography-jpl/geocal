#! /usr/bin/env python
#
# This collects tie points.

from afids import *
from multiprocessing import Pool
import logging

version = "February 4, 2013"
usage="""Usage: 
  tp_collect [options] <igc> <output>
  tp_collect --gcp [options] <igc> <reference_image> <output>
  tp_collect -h | --help
  tp_collect -v | --version

This program is used to generate a collection of tie points or ground control
points (tie points with the addition of ground truth).

This creates a sqlite shelve object that holds an array of TiePoints. The
output should be in "file:key" format, e.g., "my_data.db:tp". The input is
the IgcCollection to use, also in the same format (which can be in the same
or a different input file).

If you supply a reference image, this should be a "file:key" object.

Options:
  -h --help         
       Print this message

  --add-tp
       The default behavior is to overwrite whatever "file:key" value is
       specified as the output. You can optionally add the TP/GCPs we 
       generate.

  --avg-level=n
       You can specify an averaging level to use. If supplied, we use
       a pyramid image matching scheme, starting at a resolution of 
       2^avg_level, and proceeding down factors of 2 until we fail image
       matching or get all the way down to full resolution data. Useful
       for difficult to match imagery. [default: 0]

  --gcp
       Create GCPs, which requires the additional arguments of a reference
       image.

  --max-ground-sigma=d
       How far off the various matched points can miss when intersecting
       on the surface, in meters. This is used to filter out bad tie-points,
       but you want this large enough you aren't filtering out good points.
       [default: 20.0]

  --number-process=n 
       Number of processors to use. [default: 1]

  --number-x=n      
       Number of grid points in the X direction to try for [default: 100]

  --number-y=n      
       Number of grid points in the Y direction to try for [default: 100]
 
  --reference-dem=shelve
       DEM to use with the reference image specified as file:key. 
       If not specified, we use the DEM from the first IGC.

  --verbose
       Print more information as we run.

  -v --version      
       Print program version
"""

args = docopt_simple(usage, version=version)
if(args.verbose):
    logging.basicConfig(level = logging.INFO)
pool = None
if(args.number_process > 1):
    pool = Pool(args.number_process)

igc = read_shelve(args.igc)
if(args.gcp):
    if(args.reference_dem):
        dem = read_shelve(args.reference_dem)
    else:
        dem = igc.dem(0)
    refimg = read_shelve(args.reference_image)
    tpcollect = GcpTiePointCollect(refimg, dem, igc, 
                                   avg_level = args.avg_level,
                                   max_ground_covariance = 
                                   args.max_ground_sigma ** 2)
else:
    tpcollect = TiePointCollect(igc, avg_level = args.avg_level,
                                max_ground_covariance = 
                                args.max_ground_sigma ** 2)

tparr = tpcollect.tie_point_grid(args.number_x, args.number_y, 
                                 pool = pool)

if(args.add_tp):
    tparr.extend(read_shelve(args.output))

write_shelve(args.output, tparr)


