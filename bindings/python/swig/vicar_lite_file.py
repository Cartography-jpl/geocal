# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _vicar_lite_file.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_vicar_lite_file')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_vicar_lite_file')
    _vicar_lite_file = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_vicar_lite_file', [dirname(__file__)])
        except ImportError:
            import _vicar_lite_file
            return _vicar_lite_file
        try:
            _mod = imp.load_module('_vicar_lite_file', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _vicar_lite_file = swig_import_helper()
    del swig_import_helper
else:
    import _vicar_lite_file
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _vicar_lite_file.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_vicar_lite_file.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_vicar_lite_file.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_vicar_lite_file.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_vicar_lite_file.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_vicar_lite_file.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_vicar_lite_file.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_vicar_lite_file.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_vicar_lite_file.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_vicar_lite_file.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_vicar_lite_file.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_vicar_lite_file.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_vicar_lite_file.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_vicar_lite_file.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_vicar_lite_file.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_vicar_lite_file.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_vicar_lite_file.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _vicar_lite_file.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _vicar_lite_file.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.generic_object
import geocal_swig.raster_image
import geocal_swig.look_vector
import geocal_swig.with_parameter
import geocal_swig.geocal_exception
import geocal_swig.dem_map_info
class VicarLiteFile(geocal_swig.generic_object.GenericObject):
    """

    This handles opening and closing a Vicar file.

    This class doesn't actually read and write data, but is used by other
    classes which do.

    This class is a simple implementation of Vicar. It doesn't use the
    Vicar RTL library, which is the primary attraction of it. We can use
    this to read Vicar files in a context where we don't want to use the
    RTL library, or don't want to be constrained to running in the Vicar
    environment.

    This class does not handle new VICAR features such as compression.

    C++ includes: vicar_lite_file.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    VICAR_BYTE = _vicar_lite_file.VicarLiteFile_VICAR_BYTE
    VICAR_HALF = _vicar_lite_file.VicarLiteFile_VICAR_HALF
    VICAR_FULL = _vicar_lite_file.VicarLiteFile_VICAR_FULL
    VICAR_FLOAT = _vicar_lite_file.VicarLiteFile_VICAR_FLOAT
    VICAR_DOUBLE = _vicar_lite_file.VicarLiteFile_VICAR_DOUBLE
    READ = _vicar_lite_file.VicarLiteFile_READ
    WRITE = _vicar_lite_file.VicarLiteFile_WRITE
    UPDATE = _vicar_lite_file.VicarLiteFile_UPDATE

    def __init__(self, *args):
        """

        VicarLiteFile::VicarLiteFile(const std::string &Fname, int Number_line, int Number_sample, const
        std::string &Type="BYTE")
        Create a new VICAR file with the given size. 
        """
        _vicar_lite_file.VicarLiteFile_swiginit(self, _vicar_lite_file.new_VicarLiteFile(*args))
    __swig_destroy__ = _vicar_lite_file.delete_VicarLiteFile

    def _v_access(self):
        """

        access_type GeoCal::VicarLiteFile::access() const
        Access type of file. 
        """
        return _vicar_lite_file.VicarLiteFile__v_access(self)


    @property
    def access(self):
        return self._v_access()


    def _v_force_area_pixel(self):
        """

        bool GeoCal::VicarLiteFile::force_area_pixel() const
        If true, then force the file to be treated as "pixel is area".

        This is really just meant as a work around for the SRTM data, which
        incorrectly labels the data as "point" rather than "area". Since
        this is a 15 meter difference, it matters for many applications. Most
        users should just ignore this value. 
        """
        return _vicar_lite_file.VicarLiteFile__v_force_area_pixel(self)


    @property
    def force_area_pixel(self):
        return self._v_force_area_pixel()


    def _v_data_offset(self):
        """

        int GeoCal::VicarLiteFile::data_offset() const
        Offset to where the data starts. 
        """
        return _vicar_lite_file.VicarLiteFile__v_data_offset(self)


    @property
    def data_offset(self):
        return self._v_data_offset()


    def _v_file_name(self):
        """

        const std::string& GeoCal::VicarLiteFile::file_name() const
        File name. 
        """
        return _vicar_lite_file.VicarLiteFile__v_file_name(self)


    @property
    def file_name(self):
        return self._v_file_name()


    def is_vicar_file(Fname):
        """

        bool VicarLiteFile::is_vicar_file(const std::string &Fname)
        Determine if a given file is a VICAR file or not.

        This looks for the first few characters of the file being "LBLSIZE="

        """
        return _vicar_lite_file.VicarLiteFile_is_vicar_file(Fname)

    is_vicar_file = staticmethod(is_vicar_file)

    def _v_has_igc_glas_gfm(self):
        """

        bool VicarLiteFile::has_igc_glas_gfm() const
        Return true if the file has a GLAS_GFM_NITF_FILE or GLAS_GFM_XML_FILE
        label in it, indicating it has GLAS/GFM information. 
        """
        return _vicar_lite_file.VicarLiteFile__v_has_igc_glas_gfm(self)


    @property
    def has_igc_glas_gfm(self):
        return self._v_has_igc_glas_gfm()


    def _v_igc_glas_gfm(self):
        """

        boost::shared_ptr< ImageGroundConnection > VicarLiteFile::igc_glas_gfm() const
        Read metadata for GLAS/GFM.

        Note we store this as a separate detached file in either NITF or boost
        serialization XML format. The VICAR file then has a pointer to the
        file. The pointer just has a file name, it is assumed the file is in
        the same directory as the VICAR file. 
        """
        return _vicar_lite_file.VicarLiteFile__v_igc_glas_gfm(self)


    @property
    def igc_glas_gfm(self):
        return self._v_igc_glas_gfm()


    def _v_number_line(self):
        """

        int GeoCal::VicarLiteFile::number_line() const
        Number of lines in file. 
        """
        return _vicar_lite_file.VicarLiteFile__v_number_line(self)


    @property
    def number_line(self):
        return self._v_number_line()


    def _v_number_sample(self):
        """

        int GeoCal::VicarLiteFile::number_sample() const
        Number of samples in file. 
        """
        return _vicar_lite_file.VicarLiteFile__v_number_sample(self)


    @property
    def number_sample(self):
        return self._v_number_sample()


    def _v_number_band(self):
        """

        int GeoCal::VicarLiteFile::number_band() const
        Number of bands in file. 
        """
        return _vicar_lite_file.VicarLiteFile__v_number_band(self)


    @property
    def number_band(self):
        return self._v_number_band()


    def _v_number_line_binary(self):
        """

        int GeoCal::VicarLiteFile::number_line_binary() const
        Number of lines of binary data before the start of the image. 
        """
        return _vicar_lite_file.VicarLiteFile__v_number_line_binary(self)


    @property
    def number_line_binary(self):
        return self._v_number_line_binary()


    def _v_number_byte_binary(self):
        """

        int GeoCal::VicarLiteFile::number_byte_binary() const
        Number of bytes of binary data before the start of each line. 
        """
        return _vicar_lite_file.VicarLiteFile__v_number_byte_binary(self)


    @property
    def number_byte_binary(self):
        return self._v_number_byte_binary()


    def _v_type(self):
        """

        data_type GeoCal::VicarLiteFile::type() const
        Type of data in file. 
        """
        return _vicar_lite_file.VicarLiteFile__v_type(self)


    @property
    def type(self):
        return self._v_type()


    def _v_map_info(self, *args):
        """

        void VicarLiteFile::map_info(const MapInfo &M)
        Set metadata for MapInfo. 
        """
        return _vicar_lite_file.VicarLiteFile__v_map_info(self, *args)


    @property
    def map_info(self):
        return self._v_map_info()

    @map_info.setter
    def map_info(self, value):
      self._v_map_info(value)


    def _v_rpc(self, *args):
        """

        void GeoCal::VicarLiteFile::rpc(const Rpc &R)

        """
        return _vicar_lite_file.VicarLiteFile__v_rpc(self, *args)


    @property
    def rpc(self):
        return self._v_rpc()

    @rpc.setter
    def rpc(self, value):
      self._v_rpc(value)


    def _v_rsm(self, *args):
        """

        void GeoCal::VicarLiteFile::rsm(const boost::shared_ptr< Rsm > &R)

        """
        return _vicar_lite_file.VicarLiteFile__v_rsm(self, *args)


    @property
    def rsm(self):
        return self._v_rsm()

    @rsm.setter
    def rsm(self, value):
      self._v_rsm(value)


    def _v_is_compressed(self):
        """

        bool GeoCal::VicarLiteFile::is_compressed() const
        Indicate if the file is compressed.

        If it is, we can't actually read the data but we can still read all of
        the labels. 
        """
        return _vicar_lite_file.VicarLiteFile__v_is_compressed(self)


    @property
    def is_compressed(self):
        return self._v_is_compressed()


    def label_string(self, N):
        """

        std::string GeoCal::VicarLiteFile::label_string(const std::string &F, const std::string &Property="") const
        Non template form of label, useful in some contexts. 
        """
        return _vicar_lite_file.VicarLiteFile_label_string(self, N)


    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

VicarLiteFile._v_access = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_access, None, VicarLiteFile)
VicarLiteFile._v_force_area_pixel = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_force_area_pixel, None, VicarLiteFile)
VicarLiteFile._v_data_offset = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_data_offset, None, VicarLiteFile)
VicarLiteFile._v_file_name = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_file_name, None, VicarLiteFile)
VicarLiteFile._v_has_igc_glas_gfm = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_has_igc_glas_gfm, None, VicarLiteFile)
VicarLiteFile._v_igc_glas_gfm = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_igc_glas_gfm, None, VicarLiteFile)
VicarLiteFile._v_number_line = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_number_line, None, VicarLiteFile)
VicarLiteFile._v_number_sample = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_number_sample, None, VicarLiteFile)
VicarLiteFile._v_number_band = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_number_band, None, VicarLiteFile)
VicarLiteFile._v_number_line_binary = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_number_line_binary, None, VicarLiteFile)
VicarLiteFile._v_number_byte_binary = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_number_byte_binary, None, VicarLiteFile)
VicarLiteFile._v_type = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_type, None, VicarLiteFile)
VicarLiteFile._v_map_info = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_map_info, None, VicarLiteFile)
VicarLiteFile._v_rpc = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_rpc, None, VicarLiteFile)
VicarLiteFile._v_rsm = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_rsm, None, VicarLiteFile)
VicarLiteFile.__str__ = new_instancemethod(_vicar_lite_file.VicarLiteFile___str__, None, VicarLiteFile)
VicarLiteFile._v_is_compressed = new_instancemethod(_vicar_lite_file.VicarLiteFile__v_is_compressed, None, VicarLiteFile)
VicarLiteFile.label_string = new_instancemethod(_vicar_lite_file.VicarLiteFile_label_string, None, VicarLiteFile)
VicarLiteFile.label_list = new_instancemethod(_vicar_lite_file.VicarLiteFile_label_list, None, VicarLiteFile)
VicarLiteFile_swigregister = _vicar_lite_file.VicarLiteFile_swigregister
VicarLiteFile_swigregister(VicarLiteFile)

def VicarLiteFile_is_vicar_file(Fname):
    """

    bool VicarLiteFile::is_vicar_file(const std::string &Fname)
    Determine if a given file is a VICAR file or not.

    This looks for the first few characters of the file being "LBLSIZE="

    """
    return _vicar_lite_file.VicarLiteFile_is_vicar_file(Fname)

class VicarLiteRasterImage(geocal_swig.raster_image.RasterImage):
    """

    This uses VicarLiteFile to implement a RasterImage.

    We use a VicarLiteFile to implement a RasterImage.

    C++ includes: vicar_lite_file.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        GeoCal::VicarLiteRasterImage::VicarLiteRasterImage(const std::string &Fname, const MapInfo &Mi, int Band_id=1,
        access_type Access=VicarLiteFile::READ, int Number_tile_line=-1, int
        Number_tile_sample=-1, bool Force_area_pixel=false)
        Constructor.

        We force the given map info to apply to the image. This is a
        workaround for pickling mapinfo that VICAR doesn't support yet. 
        """
        _vicar_lite_file.VicarLiteRasterImage_swiginit(self, _vicar_lite_file.new_VicarLiteRasterImage(*args))

    def _v_file(self):
        """

        boost::shared_ptr<VicarLiteFile> GeoCal::VicarLiteRasterImage::file_ptr() const

        """
        return _vicar_lite_file.VicarLiteRasterImage__v_file(self)


    @property
    def file(self):
        return self._v_file()


    def _v_is_compressed(self):
        """

        bool GeoCal::VicarLiteRasterImage::is_compressed() const
        Indicate if the file is compressed.

        If it is, we can't actually read the data but we can still read all of
        the labels. 
        """
        return _vicar_lite_file.VicarLiteRasterImage__v_is_compressed(self)


    @property
    def is_compressed(self):
        return self._v_is_compressed()


    def _v_band_id(self):
        """

        int GeoCal::VicarLiteRasterImage::band_id() const
        Return band number. This is 1 based (like GDAL). 
        """
        return _vicar_lite_file.VicarLiteRasterImage__v_band_id(self)


    @property
    def band_id(self):
        return self._v_band_id()


    def _v_force_map_info(self):
        """

        bool GeoCal::VicarLiteRasterImage::force_map_info() const
        Marker to force a map_info in python pickle.

        This is a work around for map info that VICAR doesn't support writing.

        """
        return _vicar_lite_file.VicarLiteRasterImage__v_force_map_info(self)


    @property
    def force_map_info(self):
        return self._v_force_map_info()


    def _v_has_igc_glas_gfm(self):
        """

        bool GeoCal::VicarLiteRasterImage::has_igc_glas_gfm() const

        """
        return _vicar_lite_file.VicarLiteRasterImage__v_has_igc_glas_gfm(self)


    @property
    def has_igc_glas_gfm(self):
        return self._v_has_igc_glas_gfm()


    def _v_igc_glas_gfm(self):
        """

        boost::shared_ptr<ImageGroundConnection> GeoCal::VicarLiteRasterImage::igc_glas_gfm() const

        """
        return _vicar_lite_file.VicarLiteRasterImage__v_igc_glas_gfm(self)


    @property
    def igc_glas_gfm(self):
        return self._v_igc_glas_gfm()


    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _vicar_lite_file.delete_VicarLiteRasterImage
VicarLiteRasterImage._v_file = new_instancemethod(_vicar_lite_file.VicarLiteRasterImage__v_file, None, VicarLiteRasterImage)
VicarLiteRasterImage._v_is_compressed = new_instancemethod(_vicar_lite_file.VicarLiteRasterImage__v_is_compressed, None, VicarLiteRasterImage)
VicarLiteRasterImage._v_band_id = new_instancemethod(_vicar_lite_file.VicarLiteRasterImage__v_band_id, None, VicarLiteRasterImage)
VicarLiteRasterImage._v_force_map_info = new_instancemethod(_vicar_lite_file.VicarLiteRasterImage__v_force_map_info, None, VicarLiteRasterImage)
VicarLiteRasterImage._v_has_igc_glas_gfm = new_instancemethod(_vicar_lite_file.VicarLiteRasterImage__v_has_igc_glas_gfm, None, VicarLiteRasterImage)
VicarLiteRasterImage._v_igc_glas_gfm = new_instancemethod(_vicar_lite_file.VicarLiteRasterImage__v_igc_glas_gfm, None, VicarLiteRasterImage)
VicarLiteRasterImage_swigregister = _vicar_lite_file.VicarLiteRasterImage_swigregister
VicarLiteRasterImage_swigregister(VicarLiteRasterImage)

class VicarLiteDem(geocal_swig.dem_map_info.DemMapInfo):
    """

    This uses VicarLiteFile to implement a Dem.

    We use VicarLiteFile to implement a Dem

    C++ includes: vicar_lite_file.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        GeoCal::VicarLiteDem::VicarLiteDem(const std::string &Fname, bool Outside_dem_is_error=false, const
        boost::shared_ptr< Datum > &D=boost::shared_ptr< Datum >(new
        NoDatum()), int Band_id=1, int Naif_code=Geodetic::EARTH_NAIF_CODE)
        Constructor.

        If Outside_dem_is_error is true, then calls for Dem data outside of
        the range of the Dem cause an exception to be thrown, otherwise we
        just return a height of 0.

        Probably should have the Naif_code stored as metadata in the file, but
        for now we just explicitly pass this in. 
        """
        _vicar_lite_file.VicarLiteDem_swiginit(self, _vicar_lite_file.new_VicarLiteDem(*args))

    def _v_file(self):
        """

        boost::shared_ptr<VicarLiteFile> GeoCal::VicarLiteDem::file_ptr() const

        """
        return _vicar_lite_file.VicarLiteDem__v_file(self)


    @property
    def file(self):
        return self._v_file()


    def elevation(self, Y_index, X_index):
        """

        virtual double GeoCal::VicarLiteDem::elevation(int Y_index, int X_index) const
        Return height in meters relative to datum(). 
        """
        return _vicar_lite_file.VicarLiteDem_elevation(self, Y_index, X_index)


    def _v_band(self):
        """

        int GeoCal::VicarLiteDem::band() const
        Return band number. 
        """
        return _vicar_lite_file.VicarLiteDem__v_band(self)


    @property
    def band(self):
        return self._v_band()


    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _vicar_lite_file.delete_VicarLiteDem
VicarLiteDem._v_file = new_instancemethod(_vicar_lite_file.VicarLiteDem__v_file, None, VicarLiteDem)
VicarLiteDem.elevation = new_instancemethod(_vicar_lite_file.VicarLiteDem_elevation, None, VicarLiteDem)
VicarLiteDem._v_band = new_instancemethod(_vicar_lite_file.VicarLiteDem__v_band, None, VicarLiteDem)
VicarLiteDem_swigregister = _vicar_lite_file.VicarLiteDem_swigregister
VicarLiteDem_swigregister(VicarLiteDem)


__all__ = ["VicarLiteFile","VicarLiteRasterImage","VicarLiteDem"]



