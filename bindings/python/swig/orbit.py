# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
from ._swig_wrap import _orbit

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _orbit.SWIG_PyInstanceMethod_New
_swig_new_static_method = _orbit.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _orbit.delete_SwigPyIterator
    value = _swig_new_instance_method(_orbit.SwigPyIterator_value)
    incr = _swig_new_instance_method(_orbit.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_orbit.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_orbit.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_orbit.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_orbit.SwigPyIterator_copy)
    next = _swig_new_instance_method(_orbit.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_orbit.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_orbit.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_orbit.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_orbit.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_orbit.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_orbit.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_orbit.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_orbit.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_orbit.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _orbit:
_orbit.SwigPyIterator_swigregister(SwigPyIterator)
SWIG_MODULE_ALREADY_DONE = _orbit.SWIG_MODULE_ALREADY_DONE
SHARED_PTR_DISOWN = _orbit.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_function.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_function.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.generic_object
import geocal_swig.observer
import geocal_swig.with_parameter
import geocal_swig.look_vector
class OrbitData(geocal_swig.generic_object.GenericObject):
    r"""

    This class is used to convert ScLookVector,
    CartesianInertialLookVector and CartesianFixedLookVector to and from
    each other at a given time.

    Note that there are different conventions for the definition of the
    ScLookVector.

    The original MISR convention used +z in the down direction, +x in the
    generally velocity (along track) direction, and +y finished the right
    hand coordinate system.

    Another convention used (by for example sc2rpc) is +x goes in the
    sample direction, +y goes in the line direction, and +z points down.

    C++ includes: orbit.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    resolution_meter = _swig_new_instance_method(_orbit.OrbitData_resolution_meter)
    ci_look_vector = _swig_new_instance_method(_orbit.OrbitData_ci_look_vector)
    cf_look_vector = _swig_new_instance_method(_orbit.OrbitData_cf_look_vector)
    sc_look_vector_with_derivative = _swig_new_instance_method(_orbit.OrbitData_sc_look_vector_with_derivative)
    sc_look_vector = _swig_new_instance_method(_orbit.OrbitData_sc_look_vector)
    frame_coordinate = _swig_new_instance_method(_orbit.OrbitData_frame_coordinate)
    frame_coordinate_with_derivative = _swig_new_instance_method(_orbit.OrbitData_frame_coordinate_with_derivative)
    reference_surface_intersect_approximate = _swig_new_instance_method(_orbit.OrbitData_reference_surface_intersect_approximate)
    _v_position_ci = _swig_new_instance_method(_orbit.OrbitData__v_position_ci)

    @property
    def position_ci(self):
        return self._v_position_ci()

    _v_position_cf = _swig_new_instance_method(_orbit.OrbitData__v_position_cf)

    @property
    def position_cf(self):
        return self._v_position_cf()

    footprint = _swig_new_instance_method(_orbit.OrbitData_footprint)
    surface_intersect = _swig_new_instance_method(_orbit.OrbitData_surface_intersect)
    _velocity_ci = _swig_new_instance_method(_orbit.OrbitData__velocity_ci)
    _velocity_ci_with_derivative = _swig_new_instance_method(_orbit.OrbitData__velocity_ci_with_derivative)
    _position_ci_with_derivative = _swig_new_instance_method(_orbit.OrbitData__position_ci_with_derivative)
    _position_cf_with_derivative = _swig_new_instance_method(_orbit.OrbitData__position_cf_with_derivative)

    @property
    def velocity_ci(self):
        return self._velocity_ci()

    @property
    def velocity_ci_with_derivative(self):
        return self._velocity_ci_with_derivative()

    @property
    def position_ci_with_derivative(self):
        return self._position_ci_with_derivative()

    @property
    def position_cf_with_derivative(self):
        return self._position_cf_with_derivative()

    _velocity_cf = _swig_new_instance_method(_orbit.OrbitData__velocity_cf)
    _velocity_cf_with_derivative = _swig_new_instance_method(_orbit.OrbitData__velocity_cf_with_derivative)

    @property
    def velocity_cf(self):
        return self._velocity_cf()

    @property
    def velocity_cf_with_derivative(self):
        return self._velocity_cf_with_derivative()

    _v_time = _swig_new_instance_method(_orbit.OrbitData__v_time)

    @property
    def time(self):
        return self._v_time()

    _v_time_with_derivative = _swig_new_instance_method(_orbit.OrbitData__v_time_with_derivative)

    @property
    def time_with_derivative(self):
        return self._v_time_with_derivative()

    __str__ = _swig_new_instance_method(_orbit.OrbitData___str__)
    _v_prefer_cf = _swig_new_instance_method(_orbit.OrbitData__v_prefer_cf)

    @property
    def prefer_cf(self):
        return self._v_prefer_cf()

    __swig_destroy__ = _orbit.delete_OrbitData

# Register OrbitData in _orbit:
_orbit.OrbitData_swigregister(OrbitData)
class QuaternionOrbitData(OrbitData):
    r"""

    This class implements the most common way of doing OrbitData
    conversions, which just uses fixed quaternions.

    This accounts for both the orientation of the spacecraft relative to
    the planet, as well as the aberration of light (a small correction due
    to the movement of the spacecraft relative to the planet).

    This does not account for atmospheric refraction. Depending on the
    zenith angle, this can be somewhat important for satellites. From the
    approximate atmospheric model described in "Theoretical Basis of the
    SDP Toolkit Geolocation package for the ECS", Table 6-5 the linear
    displacement for a zenith angle of 10 is 0.549 meters, 20 degrees is
    1.223 meters, and 30 degrees is 2.221.

    The refraction calculation can be handled by an instance of the
    Refraction class (e.g., RefractionMsp). This is handled outside of the
    class - so we return look vectors before correcting for refraction.

    The velocity aberration includes a couple of approximations to enable
    it to run faster:

    We only include the first order terms in v/c.

    We ignore the rotation of the planet for the CartesianFixedLookVector,
    using the velocity_cf() as an approximation to the relative velocity
    of the target.

    This approximation is pretty good, it introduces small ~1m errors for
    a typical orbit on the Earth.

    For high precision work (e.g, 0.5 m pixels of WV-2) this might not be
    sufficient. For those cases, you can request that the Orbit not
    perform its approximate velocity aberration correction and then handle
    this correction separately (similar to how Refraction is handled).

    We need to have one of the toolkit available if we want to convert for
    the CartesianFixed coordinates used by this class to
    CartesianInertial. If you stick to working with CartesianFixed only,
    you can avoid the need of using one of these toolkits.

    Note that we allow most pieces of this to be AutoDerivative, useful
    for propagating jacobians. By convention an Orbit uses the
    AutoDerivative if orbit_data is called with a TimeWithDerivative, but
    doesn't if it isn't. This means the AutoDerivative can be available,
    but if not needed we save time by not calculating these.

    C++ includes: orbit.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        QuaternionOrbitData::QuaternionOrbitData(Time Tm, const boost::shared_ptr< CartesianInertial > &pos_ci, const
        boost::array< double, 3 > &vel_inertial, const
        boost::math::quaternion< double > &sc_to_ci_q)
        GeoCal::QuaternionOrbitData::QuaternionOrbitData
        Construct QuaternionOrbitData.
        This takes data in a CartesianInertial coordinate system (e.g., Eci
        coordinates). 
        """
        _orbit.QuaternionOrbitData_swiginit(self, _orbit.new_QuaternionOrbitData(*args))
    ci_look_vector = _swig_new_instance_method(_orbit.QuaternionOrbitData_ci_look_vector)
    interpolate = _swig_new_static_method(_orbit.QuaternionOrbitData_interpolate)
    _v_sc_to_ci = _swig_new_instance_method(_orbit.QuaternionOrbitData__v_sc_to_ci)

    @property
    def sc_to_ci(self):
        return self._v_sc_to_ci()

    @sc_to_ci.setter
    def sc_to_ci(self, value):
      self._v_sc_to_ci(value)

    _v_sc_to_ci_with_derivative = _swig_new_instance_method(_orbit.QuaternionOrbitData__v_sc_to_ci_with_derivative)

    @property
    def sc_to_ci_with_derivative(self):
        return self._v_sc_to_ci_with_derivative()

    @sc_to_ci_with_derivative.setter
    def sc_to_ci_with_derivative(self, value):
      self._v_sc_to_ci_with_derivative(value)

    _v_sc_to_cf = _swig_new_instance_method(_orbit.QuaternionOrbitData__v_sc_to_cf)

    @property
    def sc_to_cf(self):
        return self._v_sc_to_cf()

    @sc_to_cf.setter
    def sc_to_cf(self, value):
      self._v_sc_to_cf(value)

    _v_sc_to_cf_with_derivative = _swig_new_instance_method(_orbit.QuaternionOrbitData__v_sc_to_cf_with_derivative)

    @property
    def sc_to_cf_with_derivative(self):
        return self._v_sc_to_cf_with_derivative()

    @sc_to_cf_with_derivative.setter
    def sc_to_cf_with_derivative(self, value):
      self._v_sc_to_cf_with_derivative(value)

    _v_from_cf = _swig_new_instance_method(_orbit.QuaternionOrbitData__v_from_cf)

    @property
    def from_cf(self):
        return self._v_from_cf()


    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)

    __swig_destroy__ = _orbit.delete_QuaternionOrbitData

# Register QuaternionOrbitData in _orbit:
_orbit.QuaternionOrbitData_swigregister(QuaternionOrbitData)
class ObservableOrbit(geocal_swig.generic_object.GenericObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _orbit.delete_ObservableOrbit
    add_observer_and_keep_reference = _swig_new_instance_method(_orbit.ObservableOrbit_add_observer_and_keep_reference)
    add_observer = _swig_new_instance_method(_orbit.ObservableOrbit_add_observer)
    remove_observer = _swig_new_instance_method(_orbit.ObservableOrbit_remove_observer)

# Register ObservableOrbit in _orbit:
_orbit.ObservableOrbit_swigregister(ObservableOrbit)
class ObserverOrbit(geocal_swig.generic_object.GenericObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _orbit.ObserverOrbit_swiginit(self, _orbit.new_ObserverOrbit())
    __swig_destroy__ = _orbit.delete_ObserverOrbit
    notify_update = _swig_new_instance_method(_orbit.ObserverOrbit_notify_update)
    notify_add = _swig_new_instance_method(_orbit.ObserverOrbit_notify_add)
    notify_remove = _swig_new_instance_method(_orbit.ObserverOrbit_notify_remove)

# Register ObserverOrbit in _orbit:
_orbit.ObserverOrbit_swigregister(ObserverOrbit)
class Orbit(ObservableOrbit, geocal_swig.with_parameter.WithParameter):
    r"""

    This class is used to model orbit data, allowing conversions from
    spacecraft coordinates to CartesianInertial and CartesianFixed
    coordinates.

    This class is used to return orbit data at a given time. OrbitData is
    a class that is able to convert from spacecraft coordinates to
    CartesianInertial coordinates and vice-versa at a given time, as well
    as giving the platforms position.

    As an optimization, methods for direct conversion from spacecraft
    coordinates to CartesianInertial and vice-versa, which don't use the
    intermediate OrbitData classes, are supplied. The default methods just
    use the OrbitData methods, but derived classes can supply more
    optimized versions of these methods.

    See QuaternionOrbitData for a discussion of Refraction and velocity
    aberration corrections.

    An orbit has a min_time() and a max_time() that orbit data is
    available for. Requesting data outside of this range will cause an
    exception to be thrown. For Time T, we must have min_time() <= T <
    max_time().

    C++ includes: orbit.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        GeoCal::Orbit::Orbit(Time Min_time=Time::min_valid_time, Time
        Max_time=Time::max_valid_time)
        GeoCal::Orbit::Orbit
        Constructor.
        The Orbit is valid for the given range of minimum to maximum time. 
        """
        if self.__class__ == Orbit:
            _self = None
        else:
            _self = self
        _orbit.Orbit_swiginit(self, _orbit.new_Orbit(_self, *args))
    __swig_destroy__ = _orbit.delete_Orbit
    desc = _swig_new_instance_method(_orbit.Orbit_desc)
    add_observer = _swig_new_instance_method(_orbit.Orbit_add_observer)
    remove_observer = _swig_new_instance_method(_orbit.Orbit_remove_observer)
    ci_look_vector = _swig_new_instance_method(_orbit.Orbit_ci_look_vector)
    cf_look_vector = _swig_new_instance_method(_orbit.Orbit_cf_look_vector)
    frame_coordinate = _swig_new_instance_method(_orbit.Orbit_frame_coordinate)
    frame_coordinate_with_derivative = _swig_new_instance_method(_orbit.Orbit_frame_coordinate_with_derivative)
    reference_surface_intersect_approximate = _swig_new_instance_method(_orbit.Orbit_reference_surface_intersect_approximate)
    sc_look_vector = _swig_new_instance_method(_orbit.Orbit_sc_look_vector)
    position_ci = _swig_new_instance_method(_orbit.Orbit_position_ci)
    position_cf = _swig_new_instance_method(_orbit.Orbit_position_cf)
    _v_min_time = _swig_new_instance_method(_orbit.Orbit__v_min_time)

    @property
    def min_time(self):
        return self._v_min_time()

    _v_max_time = _swig_new_instance_method(_orbit.Orbit__v_max_time)

    @property
    def max_time(self):
        return self._v_max_time()

    orbit_data = _swig_new_instance_method(_orbit.Orbit_orbit_data)
    __str__ = _swig_new_instance_method(_orbit.Orbit___str__)
    _v_parameter = _swig_new_instance_method(_orbit.Orbit__v_parameter)

    @property
    def parameter(self):
        return self._v_parameter()

    @parameter.setter
    def parameter(self, value):
      self._v_parameter(value)

    _v_parameter_with_derivative = _swig_new_instance_method(_orbit.Orbit__v_parameter_with_derivative)

    @property
    def parameter_with_derivative(self):
        return self._v_parameter_with_derivative()

    @parameter_with_derivative.setter
    def parameter_with_derivative(self, value):
      self._v_parameter_with_derivative(value)

    _v_parameter_name = _swig_new_instance_method(_orbit.Orbit__v_parameter_name)

    @property
    def parameter_name(self):
        return self._v_parameter_name()

    _v_parameter_subset = _swig_new_instance_method(_orbit.Orbit__v_parameter_subset)

    @property
    def parameter_subset(self):
        return self._v_parameter_subset()

    @parameter_subset.setter
    def parameter_subset(self, value):
      self._v_parameter_subset(value)

    _v_parameter_with_derivative_subset = _swig_new_instance_method(_orbit.Orbit__v_parameter_with_derivative_subset)

    @property
    def parameter_with_derivative_subset(self):
        return self._v_parameter_with_derivative_subset()

    @parameter_with_derivative_subset.setter
    def parameter_with_derivative_subset(self, value):
      self._v_parameter_with_derivative_subset(value)

    _v_parameter_name_subset = _swig_new_instance_method(_orbit.Orbit__v_parameter_name_subset)

    @property
    def parameter_name_subset(self):
        return self._v_parameter_name_subset()

    _v_parameter_mask = _swig_new_instance_method(_orbit.Orbit__v_parameter_mask)

    @property
    def parameter_mask(self):
        return self._v_parameter_mask()

    interpolate = _swig_new_static_method(_orbit.Orbit_interpolate)

    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)

    notify_update_do = _swig_new_instance_method(_orbit.Orbit_notify_update_do)
    def __disown__(self):
        self.this.disown()
        _orbit.disown_Orbit(self)
        return weakref.proxy(self)

# Register Orbit in _orbit:
_orbit.Orbit_swigregister(Orbit)
class KeplerOrbit(Orbit):
    r"""

    This is a simple implementation of an Orbit.

    It just uses Kepler's equations. This is intended primarily for easy
    testing of other classes that need an Orbit, rather than being a
    realistic orbit simulation for real use.

    The default parameters are for a nominal MISR orbit.

    C++ includes: orbit.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        KeplerOrbit::KeplerOrbit(Time Min_time=Time::min_valid_time, Time
        Max_time=Time::max_valid_time, Time
        Epoch=Time::time_pgs(173357492.32), double Semimajor_axis=7086930,
        double Eccentricity=0.001281620, double Inclination=98.199990, double
        Ra_ascending_node=255.355971130, double Ap_at_epoch=69.086962170,
        double Mean_anomaly_at_epoch=290.912925280)
        GeoCal::KeplerOrbit::KeplerOrbit
        Create a Kepler orbit with the given elements, valid over the given
        time range.
        Distances are in meters and angles are in degrees. The Epoch gives the
        Time that the rest of the data is valid for. The default values are a
        nominal orbit for MISR. 
        """
        _orbit.KeplerOrbit_swiginit(self, _orbit.new_KeplerOrbit(*args))
    orbit_data = _swig_new_instance_method(_orbit.KeplerOrbit_orbit_data)
    _v_epoch = _swig_new_instance_method(_orbit.KeplerOrbit__v_epoch)

    @property
    def epoch(self):
        return self._v_epoch()

    @epoch.setter
    def epoch(self, value):
      self._v_epoch(value)

    _v_semimajor_axis = _swig_new_instance_method(_orbit.KeplerOrbit__v_semimajor_axis)

    @property
    def semimajor_axis(self):
        return self._v_semimajor_axis()

    @semimajor_axis.setter
    def semimajor_axis(self, value):
      self._v_semimajor_axis(value)

    _v_argument_of_perigee = _swig_new_instance_method(_orbit.KeplerOrbit__v_argument_of_perigee)

    @property
    def argument_of_perigee(self):
        return self._v_argument_of_perigee()

    @argument_of_perigee.setter
    def argument_of_perigee(self, value):
      self._v_argument_of_perigee(value)

    _v_eccentricity = _swig_new_instance_method(_orbit.KeplerOrbit__v_eccentricity)

    @property
    def eccentricity(self):
        return self._v_eccentricity()

    @eccentricity.setter
    def eccentricity(self, value):
      self._v_eccentricity(value)

    _v_mean_anomoly = _swig_new_instance_method(_orbit.KeplerOrbit__v_mean_anomoly)

    @property
    def mean_anomoly(self):
        return self._v_mean_anomoly()

    @mean_anomoly.setter
    def mean_anomoly(self, value):
      self._v_mean_anomoly(value)

    _v_inclination = _swig_new_instance_method(_orbit.KeplerOrbit__v_inclination)

    @property
    def inclination(self):
        return self._v_inclination()

    @inclination.setter
    def inclination(self, value):
      self._v_inclination(value)

    _v_right_ascension = _swig_new_instance_method(_orbit.KeplerOrbit__v_right_ascension)

    @property
    def right_ascension(self):
        return self._v_right_ascension()

    @right_ascension.setter
    def right_ascension(self, value):
      self._v_right_ascension(value)

    _v_period = _swig_new_instance_method(_orbit.KeplerOrbit__v_period)

    @property
    def period(self):
        return self._v_period()


    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)

    __swig_destroy__ = _orbit.delete_KeplerOrbit

# Register KeplerOrbit in _orbit:
_orbit.KeplerOrbit_swigregister(KeplerOrbit)
class Vector_QuaternionOrbitData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData___nonzero__)
    __bool__ = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData___bool__)
    __len__ = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData___len__)
    __getslice__ = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData___getslice__)
    __setslice__ = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData___setslice__)
    __delslice__ = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData___delslice__)
    __delitem__ = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData___delitem__)
    __getitem__ = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData___getitem__)
    __setitem__ = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData___setitem__)
    pop = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_pop)
    append = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_append)
    empty = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_empty)
    size = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_size)
    swap = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_swap)
    begin = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_begin)
    end = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_end)
    rbegin = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_rbegin)
    rend = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_rend)
    clear = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_clear)
    get_allocator = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_get_allocator)
    pop_back = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_pop_back)
    erase = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_erase)

    def __init__(self, *args):
        _orbit.Vector_QuaternionOrbitData_swiginit(self, _orbit.new_Vector_QuaternionOrbitData(*args))
    push_back = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_push_back)
    front = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_front)
    back = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_back)
    assign = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_assign)
    resize = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_resize)
    insert = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_insert)
    reserve = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_reserve)
    capacity = _swig_new_instance_method(_orbit.Vector_QuaternionOrbitData_capacity)

    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)

    __swig_destroy__ = _orbit.delete_Vector_QuaternionOrbitData

# Register Vector_QuaternionOrbitData in _orbit:
_orbit.Vector_QuaternionOrbitData_swigregister(Vector_QuaternionOrbitData)

__all__ = ["OrbitData","QuaternionOrbitData","Orbit","KeplerOrbit","ObservableOrbit","ObserverOrbit","Vector_QuaternionOrbitData"]


