#! /usr/bin/env python
#
# This takes a pair of mars images and used the first to correct the
# second
import osgeo.gdal as gdal
import math
import tempfile
import subprocess
import sys
import re
from geocal import *

version = "August 26,2016"
usage='''Usage:
  mars_correct_image [options] <ref_image> <ref_base_name> 
            <ref_image_resolution_name> <image> <image_base_name> 
            <image_resolution_name>
  mars_correct_image -h | --help
  mars_correct_image -v | --version

This imports the 2 images into VICAR, resamples the reference image to
the same projection as the second image, and then uses the reference
image to correct the second image. The images are resampled both to the
resolution of the original image as well as the reference image. Names
for the resolution can be anything you like, e.g., "5m", "res1". It is
used for form the output name.

We name the images by the base names. So for example:

  mars_correct_image P14_006644_1747_XI_05S222W_8bit.tif ctx 5m \
      ESP_025012_1745_RED_8bitrender.tif hirise 0.25m

Would result in ctx_5m.img ctx_0.25m.img hirise_corr_5m.img and 
hirise_corr_0.25m.img.

Options:
  -h --help         
       Print this message

  --autofit=d
       Set the FITMIN threshold automatically using the first n correlations.
       [default: 14]

  --band-ref=d
       The band number to use for the reference image (if multiple bands 
       present) [default: 1]

  --band-image=d
       The band number to use for the image we are correcting (if multiple 
       bands present) [default: 1]

  --fftsize=d
       FFT window size. Default should generally work, but sometimes you
       have a narrow overlap and need to settle for a smaller window so 
       you have enough imagery to match (e.g., very different matching size
       such as viking 232 meter data to 50 meter HRSC data).
       [default: 256]

  --fftgrid=s
       How many FFT points to match, in line x sample order. Note that to
       pass this you need to use quotes, e.g., --fftgrid="(42,42)".
       [default: (42, 42)]

  --hirise-correction
       Hirise imagery in equirectangular appears to have the 
       latitude_of_origin and standard_parallel_1 swapped, at least for
       some data. Not sure how to recognize this, and not sure if this
       always occurs. So this option turns on some heuristics to try to
       identify and correct this. If this is left off, we don't do this
       correction.

  --magnify=f
       We initially magnify the area we try matching on, so we search in
       a larger area to get the initial match points. This gives that
       factor. [default: 4.0]

   --magmin=f
       Once we have a few points matched, we shrink the magnification factor
       we use on the window size to this value. [default: 2.0]

  --nah=d
       Number of grid cells in the sample direction to use warping final image.
       [default: 1000]

  --nav=d
       Number of grid cells in the line direction to use warping final image.
       [default: 1000]

  --polyfit=s
        When warping the image to the reference image to correct it, we 
        can either use triangulation on each matched points, or we can
        constrain the mapping to a LINEAR, KEYSTONE, QUAD, or CUBIC 
        polynomial fit. See the VICAR Proc "tieconv" for more details on
        this. [default: ]

  --redo=d
       At the end of processing, this number of points will be redone.
       [default: 36]   

  --seed=d
       Seed number to use when selecting points to match. Normally you don't
       need to modify this, but if you get bad accuracy results when doing
       a correction you can try selecting a different seed to a different
       set of match points are selected. [default: 562]
   
  --thr-res=f
       Prevent offset correlations further than this value from the 
       predicted location from entering into the model fit of the 
       reference to image we are correcting. This is to prevent gross 
       blunders. Note that this is in the resolution of the reference 
       image (which is typically coarser). [default: 10.0]

  --toler=f
       Tolerance we use when rejected matched points as blunders. 
       [default: 1.5]

  --use-projection=f
       The default is to leave the image in its original projection, so
       we try to minimize what we do with the image. However it can be
       useful to bring everything to a common projection. This option says
       to use the projection found in this file.

  --use-ref-image-projection
       The default is to leave the image in its original projection, so
       we try to minimize what we do with the image. However it can be
       useful to bring everything to a common projection. This option says
       to use the reference image projection rather than image projection.

  -v --version      
       Print program version
'''

# Mapping between long name and shorter vicar name
long_name_to_vicar = { "ref_image" : "refimg",
                       "ref_base_name" : "refbase",
                       "ref_image_resolution_name" : "refresname",
                       "image" : "img",
                       "image_base_name" : "imgbase",
                       "image_resolution_name" : "imgresname",
                       "band_ref" : "bandref",
                       "band_image" : "bandimg",
                       "hirise_correction" : "hirisecorr",
                       "use_projection" : "useproj",
                       "use_ref_image_projection" : "userefproj"}

args = docopt_simple(usage, version=version,
                     long_name_to_vicar=long_name_to_vicar)

# Small wrapper around running command, so we can print this to screen
def run_cmd(cmd):
    print("Executing command:")
    print("  " + " ".join(cmd))
    sys.stdout.flush()
    subprocess.run(cmd, check=True)
    
# We probably want to add a little bit of padding, but skip that for now.

def resample_proj(fin, fref, fout, resize=False, fit_fref = True):
    '''Project fin to same projection as fref. If resize if False, 
    leave fin in whatever its original resolution is. If resize it 
    True, also resize to the same resolution as fref.'''
    d = gdal.Open(fref, gdal.GA_ReadOnly)
    g = d.GetGeoTransform()
    # Not 100% sure that all data should be Int16, but for now we assume this
    cmd= ["gdalwarp", "-of", "VICAR", "-ot", "Int16"]
    x_size, y_size = d.RasterXSize, d.RasterYSize
    min_x, max_y, pix_size_x, pix_size_y = g[0], g[3], g[1], g[5]
    max_x = min_x + (x_size * pix_size_x)
    min_y = max_y + (y_size * pix_size_y)
    if(fit_fref):
        cmd.extend(["-te", repr(min_x), repr(min_y), repr(max_x), repr(max_y)])
    if(resize):
        cmd.extend(["-tr", repr(pix_size_x), repr(pix_size_y)])
        # Note that we shouldn't have wm larger than 2GB because we get
        # an internal error in gdal with an integer overflow
    cmd.extend(["-r", "bilinear"])
    cmd.extend(["-multi", "-wo", "NUM_THREADS=20", "-wm", "2000"])
    with tempfile.NamedTemporaryFile() as f:
        f.write(d.GetProjection().encode("utf-8"))
        f.flush()
        cmd.append("-t_srs")
        cmd.append(f.name)
        cmd.append("-overwrite")
        cmd.append(fin)
        cmd.append(fout)
        run_cmd(cmd)

def check_same_projection(f1, f2):
    '''Check  that the 2 images have identical projection and resolution.'''
    gf1 = GdalRasterImage(f1)
    gf2 = GdalRasterImage(f2)
    if(not gf1.map_info.coordinate_converter.is_same(gf2.map_info.coordinate_converter)):
        return False
    if(not (gf1.map_info.transform == gf2.map_info.transform).all()):
        return False
    return True

def check_intersection(f1, f2):
    '''Returns True if there is some overlap between the 2 images, False 
    otherwise. This is purposely coarse, we just check the corners of the 
    image. So if this returns False the images definitely don't overlap,
    but True might still not overlap if it happens that all the intersection
    is in the gore of an image.'''
    t = GdalRasterImage(f1).map_info.intersection(GdalRasterImage(f2).map_info)
    if(t.number_x_pixel == 0 or t.number_y_pixel == 0):
        return False
    return True

def import_file(fin, fout):
    '''Import an image into vicar format, leaving in original projection.'''
    # Not 100% sure that all data should be Int16, but for now we assume this
    cmd = ["gdal_translate", "-of", "VICAR", "-ot", "Int16", fin, fout]
    run_cmd(cmd)

# Not sure about triangulation. Maybe try quad
def gtpwarp(fin, fref, fref_res, fout):
    '''gtpwarp, using Tom's usual parameters.'''
    cmd = ["vicarb", "gtpwarp", fin, fout, fref, fref_res,
                    "nav=%d" % args.nav, "nah=%d" % args.nah,
                    "fftgrid=%s" % args.fftgrid,
                    "fftsize=%d" % args.fftsize,
                    "magnify=%f" % args.magnify,
                    "magmin=%f" % args.magmin,
                    "toler=%f" % args.toler, 
                    "polyfit=\"%s\"" % args.polyfit,
                    "autofit=%d" % args.autofit,
                    'ref_lowres=y',
                    "redo=%d" % args.redo,
                    "ffthalf=2",
                    "seed=%d" % args.seed, 
                    "accoff=y", "'bilin", 
                    "'coverref",
                    "thr_res=%f" % args.thr_res,
                    "ref_res=%s" % fref_res,
                    ]
    run_cmd(cmd)
    # For some reason, gtpwarp doesn't set all the geotiff metadata. Not
    # sure why, we may try fixing this at some point. But for now, just
    # update this. Note this is pretty much the same as a gtgenup call, just
    # easier to do this in python here.
    t = VicarRasterImage(fout, 1, VicarFile.UPDATE)
    t.set_map_info(VicarRasterImage(fin).map_info)
    t.close()

def accck(fin,fref):
    '''Run accuracy check. We assume stuff in is in the same projection
    (e.g., all geodetic)'''
    cmd = ["vicarb", "accck", fin, fref, "wmask=n",
           "fftsize=%d" % args.fftsize,
           "magnif=%f" % args.magmin, "remap=n", "echo=no",
           "zerolim=10.0", "zerolim2=10.0"]
    run_cmd(cmd)

def fix_projection(fin, fout, band):
    '''There are potential issues with some of the map projections with 
    Mars, errors or missing pieces. This create a VRT file that fixes any 
    of these problems.'''
    cmd = ["gdal_translate", "-of", "VRT", "-b", str(band), fin, fout]
    run_cmd(cmd)
    f = gdal.Open(fout, gdal.GA_Update)
    p = str(f.GetProjectionRef())
    # The PolarSterographic can have the wrong scale factor of 0. This
    # appears to be an error in ISIS, they don't actually set the scale
    # factor and assume it defaults to 1, when actually it defaults to 0. 
    # See https://trac.osgeo.org/gdal/ticket/4499. Fix this if this is the 
    # projection. 
    if(re.search("Polar_Stereographic", p)):
        p = re.sub('PARAMETER\["scale_factor",0\]', 
                   'PARAMETER["scale_factor",1]', p)
        f.SetProjection(p)
    # The standard_parallel_1 and latitude_of_origin is sometimes swapped for
    # HiRISE. Examples I've seen have standard_parallel_1 0, so also possible
    # this is just a mislabeling of standard_parallel_1 as latitude_of_origin,
    # combined with gdal or some other tool filling in the missing
    # standard_parallel_1 with default value of 0. In any case, we swap
    # both values since this doesn't hurt even if standard_parallel_1 is
    # always zero.
    #
    # Not sure if this swap/misname is always the case, or just with some data.
    # The ticket https://trac.osgeo.org/gdal/ticket/2706 seems to talk about
    # this to some level. We have a heuristic here which checks to a name
    # "Equirectangular MARS" or "Equirectangular_MARS", and if found we swap
    # the standard_parallel_1 and latitude_of_origin. Since I'm not sure that
    # this won't corrupt some actually good data, we only do this if the
    # user selected the --hirise-correction option
    if(args.hirise_correction and
       re.search("Equirectangular[_ ]MARS", p)):
        m1 = re.search('PARAMETER\["latitude_of_origin",([\\d\\.]+)\]', p)
        m2 = re.search('PARAMETER\["standard_parallel_1",([\\d\\.]+)\]', p)
        if(m1 and m2 and m1.group(1) != m2.group(1)):
            print("MSG:----------------------------------------------------\n")
            print("MSG: Doing HiRISE correction of swapping latitude_of_origin and standard_parallel_1 for the Equirectangular projection")
            sys.stdout.flush()
            p = re.sub('PARAMETER\["latitude_of_origin",[\\d\\.]+\]',
                       'PARAMETER["latitude_of_origin",' + m2.group(1) + ']',
                       p)
            p = re.sub('PARAMETER\["standard_parallel_1",[\\d\\.]+\]',
                       'PARAMETER["standard_parallel_1",' + m1.group(1) + ']',
                       p)
            f.SetProjection(p)
            
    # Force close/flush
    f = None

# Various output names
refimg_fixed = "%s.vrt" % (args.ref_base_name)
refimg_res1 = "%s_%s.img" % (args.ref_base_name, args.ref_image_resolution_name)
refimg_res2 = "%s_%s.img" % (args.ref_base_name, args.image_resolution_name)
img_fixed = "%s.vrt" % (args.image_base_name)
img_res1 = "%s_%s.img" % (args.image_base_name, args.ref_image_resolution_name)
img_res2 = "%s_%s.img" % (args.image_base_name, args.image_resolution_name)
cimg_res1 = "%s_corr_%s.img" % (args.image_base_name, 
                                args.ref_image_resolution_name)
cimg_res2 = "%s_corr_%s.img" % (args.image_base_name, 
                                args.image_resolution_name)

fix_projection(args.ref_image, refimg_fixed, args.band_ref)
fix_projection(args.image, img_fixed, args.band_image)
if(args.use_projection):
    use_projection_fixed = "%s_proj.vrt" % (args.image_base_name)
    fix_projection(args.use_projection, use_projection_fixed, 1)
if(not check_intersection(refimg_fixed, img_fixed)):
    raise RuntimeError("The two images have no area of intersection")
if(args.use_ref_image_projection):
    img_fixed_reproj = "%s_reproj.img" % (args.image_base_name)
    resample_proj(img_fixed, refimg_fixed, img_fixed_reproj, fit_fref=False)
    img_fixed = img_fixed_reproj
if(args.use_projection):
    img_fixed_reproj = "%s_reproj.img" % (args.image_base_name)
    resample_proj(img_fixed, use_projection_fixed, img_fixed_reproj,
                  fit_fref=False)
    img_fixed = img_fixed_reproj
resample_proj(refimg_fixed, img_fixed, refimg_res1)
if(args.ref_image_resolution_name != args.image_resolution_name):
    resample_proj(refimg_res1, img_fixed, refimg_res2, resize=True)
import_file(img_fixed, img_res2)
if(args.ref_image_resolution_name != args.image_resolution_name):
    resample_proj(img_res2, refimg_res1, img_res1, resize=True)
# Check that datasets are consistent
if(not check_same_projection(img_res1, refimg_res1) or
   not check_same_projection(img_res2, refimg_res2)):
    raise RuntimeError("The files %s and %s or %s and %s aren't the same projection and/or resolution. This might be because you passed in the same resolution name for the reference image and image but they aren't identical resolution." % (img_res1, refimg_res1, img_res2, refimg_res2))
print("MSG:----------------------------------------------------\n")
print("MSG: Before correcting\n")
print("MSG: Each pixels is %s" % args.ref_image_resolution_name)
sys.stdout.flush()
accck(img_res1, refimg_res1)
gtpwarp(img_res2, refimg_res1, refimg_res2, cimg_res2)
if(args.ref_image_resolution_name != args.image_resolution_name):
    resample_proj(cimg_res2, refimg_res1, cimg_res1, resize=True)
print("MSG:----------------------------------------------------\n")
print("MSG: After correcting\n")
print("MSG: Each pixels is %s" % args.ref_image_resolution_name)
sys.stdout.flush()
accck(cimg_res1, refimg_res1)
print("MSG:----------------------------------------------------\n")
