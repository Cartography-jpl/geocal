#! /usr/bin/env python
#
# This collects tie points.

from geocal import *
from multiprocessing import Pool
import logging

version = "February 4, 2013"
usage="""Usage: 
  tp_collect [options] <igc> <output>
  tp_collect --gcp [options] <igc> <reference_image> <output>
  tp_collect -h | --help
  tp_collect -v | --version

This program is used to generate a collection of tie points or ground control
points (tie points with the addition of ground truth).

This creates a sqlite shelve object that holds an array of TiePoints. The
output should be in "file:key" format, e.g., "my_data.db:tp". The input is
the IgcCollection to use, also in the same format (which can be in the same
or a different input file).

If you supply a reference image, this should be a "file:key" object.

Options:
  -h --help         
       Print this message

  --add-tp
       The default behavior is to overwrite whatever "file:key" value is
       specified as the output. You can optionally add the TP/GCPs we 
       generate.

  --avg-level=n
       You can specify an averaging level to use. If supplied, we use
       a pyramid image matching scheme, starting at a resolution of 
       2^avg_level, and proceeding down factors of 2 until we fail image
       matching or get all the way down to full resolution data. Useful
       for difficult to match imagery. [default: 0]

  --base-image-index=n
       The image to consider the base image in matching. [default: 0]

  --base-image-spacing=n
       If supplied, rather than collecting tiepoints for one base image
       step through all the images in the igc, with the given spacing. We
       always do the edges. So if we have 11 images and spacing of 3, we
       collect tiepoints with images 0, 3, 6, 9, 10 as the base image. If
       you also specify "--gcp", we in addition collect gcps. [default: 0]

  --feature-match
       Use feature matching instead of image matching.

  --gcp
       Create GCPs, which requires the additional arguments of a reference
       image.
   
  --grid-spacing=f
       If we are dong a surface projection, you can supply how frequently
       to do the full ImageGroundConnection. Most of the time there is no
       point in doing this calculation at a high resolution than the 
       underlying DEM. [default: 1]

  --map-info=f
       Use the supplied map information (either a MapInfo, or a RasterImage 
       with a MapInfo). This is used to project to the surface before matching, 
       useful for matching data that is from different enough angles or 
       resolution that matching the raw images will fail. See
       also --project-surface that automatically finds the map info to use.

  --max-ground-sigma=d
       How far off the various matched points can miss when intersecting
       on the surface, in meters. This is used to filter out bad tie-points,
       but you want this large enough you aren't filtering out good points.
       [default: 20.0]

  --number-process=n 
       Number of processors to use. [default: 1]

  --number-x=n      
       Number of grid points in the X direction to try for [default: 100]

  --number-y=n      
       Number of grid points in the Y direction to try for [default: 100]

  --min-grid-size=n
       If we have a smaller image, then reduce the number x and y so the
       grid cell we examine isn't smaller than this size [default: 100]
 
  --reference-dem=shelve
       DEM to use with the reference image specified as file:key. 
       If not specified, we use the DEM from the first IGC.

  --project-surface
       This is used to project to the surface before matching, 
       useful for matching data that is from different enough angles or 
       resolution that matching the raw images will fail. We use a geographic
       projection that matches the resolution of the center pixel of the 
       base image. See also --map-info option.

  --use-intersection 
       This only applies to gcps. There is a trade off between getting
       the largest coverage (by taking a union of all the igc on the
       surface} and the strongest points (by looking at places seen by
       all the cameras). You may want to do both - so generate a set
       of GCPs using the largest coverage first and then the
       intersection second. See "--use-intersection-both" for this.

  --use-intersection-both
       Collect gcps once with the largest coverage, and a second time
       for the strongest points (see "--use-intersection")

  --verbose
       Print more information as we run.

  -v --version      
       Print program version
"""

def image_match_tp_collect(args, igc, mi, pool):
    '''Tp collection is a bit different for image matching vs. feature matching.
    Collect image matching into a single function, that we can call'''
    tpcollect = []
    msg = []
    if(args.gcp):
        if(args.reference_dem):
            dem = read_shelve(args.reference_dem)
        else:
            dem = igc.dem(0)
        refimg = read_shelve(args.reference_image)
        if(args.use_intersection_both):
            tpcollect.append(GcpTiePointCollect(refimg, dem, igc, 
                                                grid_spacing = args.grid_spacing,
                                                avg_level = args.avg_level,
                                                use_intersection = False))
            tpcollect.append(GcpTiePointCollect(refimg, dem, igc, 
                                                grid_spacing = args.grid_spacing,
                                                avg_level = args.avg_level,
                                                use_intersection = True))
            log.info("Adding 2 gcpcollect")
            msg.append("Doing GCP step 1")
            msg.append("Doing GCP step 2")
        else:
            tpcollect.append(GcpTiePointCollect(refimg, dem, igc, 
                                                grid_spacing = args.grid_spacing,
                                                avg_level = args.avg_level,
                                                use_intersection = args.use_intersection))
            log.info("Adding 1 gcpcollect")
            msg.append("Doing GCP")
    
    if(args.base_image_spacing):
        for i in range(0, igc.number_image, args.base_image_spacing):
            log.info("Adding base image %d" % i)
            msg.append("Doing base image %d" % i)
            if(args.project_surface):
                ig_base = igc.image_ground_connection(i)
                mibase = cib01_mapinfo(desired_resolution = ig_base.resolution_meter())
                mi = ig_base.cover(mibase)
            tpcollect.append(TiePointCollect(igc, avg_level = args.avg_level,
                                             map_info = mi,
                                             grid_spacing = args.grid_spacing,
                                             base_image_index = i,
                                             max_ground_covariance = 
                                             args.max_ground_sigma ** 2))
        if(not igc.number_image % args.base_image_spacing == 0):
            log.info("Adding base image %d" % (igc.number_image - 1, ))
            msg.append("Doing base image %d" % (igc.number_image - 1, ))
            if(args.project_surface):
                ig_base = igc.image_ground_connection(igc.number_image - 1)
                mibase = cib01_mapinfo(desired_resolution = ig_base.resolution_meter())
                mi = ig_base.cover(mibase)
            tpcollect.append(TiePointCollect(igc, avg_level = args.avg_level,
                                             map_info = mi,
                                             grid_spacing = args.grid_spacing,
                                             base_image_index = igc.number_image - 1,
                                             max_ground_covariance = 
                                             args.max_ground_sigma ** 2))
    if(not args.gcp and not args.base_image_spacing):
        log.info("Adding base image %d" % args.base_image_index)
        msg.append("Doing base image %d" % args.base_image_index)
        tpcollect.append(TiePointCollect(igc, avg_level = args.avg_level,
                                         map_info = mi,
                                         grid_spacing = args.grid_spacing,
                                         base_image_index = args.base_image_index,
                                         max_ground_covariance = 
                                         args.max_ground_sigma ** 2))
    maxnumx = int(igc.image(0).number_line / args.min_grid_size)
    maxnumy = int(igc.image(0).number_sample / args.min_grid_size)
    numx = min(args.number_x, maxnumx)
    numy = min(args.number_y, maxnumy)
    tparr = TiePointCollection()

    for i, tpcol in enumerate(tpcollect):
        log.info("---------------------------------------------------------")
        log.info(msg[i])
        log.info("---------------------------------------------------------")
        tparr.extend(tpcol.tie_point_grid(numx, numy, pool = pool))
    return tparr

def feature_match_tp_collect(args, igc, pool):
    tp_collect = TiePointCollectFM(igc, max_ground_covariance = 
                                   args.max_ground_sigma ** 2)
    return tp_collect.tie_point_list(pool = pool)
    

args = docopt_simple(usage, version=version)
if(args.verbose):
    logging.basicConfig(level = logging.INFO)
log = logging.getLogger("geocal-python.tp_collect")
pool = None
if(args.number_process > 1):
    pool = Pool(args.number_process)

igc = read_shelve(args.igc)
if(args.map_info):
    m = read_shelve(args.map_info)
    if(isinstance(m, MapInfo)):
        mi = m
    else:
        mi = m.map_info
elif(args.project_surface):
    ig_base = igc.image_ground_connection(args.base_image_index)
    mibase = cib01_mapinfo(desired_resolution = ig_base.resolution_meter())
    mi = ig_base.cover(mibase)
else:
    mi = None


if(args.feature_match):
    if(pool != None):
        log.warning("Parallel processing for feature matching doesn't currently work.")
    pool = None
    tparr = feature_match_tp_collect(args, igc, pool)
else:
    tparr = image_match_tp_collect(args, igc, mi, pool)

try:
    # Ok if this fails, it just means args.output doesn't exist yet
    if(args.add_tp):
        tparr.extend(read_shelve(args.output))
except KeyError:
    pass

write_shelve(args.output, tparr)


