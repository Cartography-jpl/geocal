# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _geocal_time.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_geocal_time', [dirname(__file__)])
        except ImportError:
            import _geocal_time
            return _geocal_time
        if fp is not None:
            try:
                _mod = imp.load_module('_geocal_time', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _geocal_time = swig_import_helper()
    del swig_import_helper
else:
    import _geocal_time
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _geocal_time.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_geocal_time.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_geocal_time.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_geocal_time.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_geocal_time.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_geocal_time.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_geocal_time.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_geocal_time.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_geocal_time.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_geocal_time.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_geocal_time.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_geocal_time.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_geocal_time.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_geocal_time.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_geocal_time.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_geocal_time.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_geocal_time.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _geocal_time.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _geocal_time.SHARED_PTR_DISOWN
def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal.generic_object
import datetime
import time

def _new_time(pgs):
  return Time.time_pgs(pgs)

class Time(geocal.generic_object.GenericObject):
    """
    There are a few reasonable choices for expressing time information.

    We could use TAI, GPS, the PGS toolkit. Each of these time system can
    be related to the other by a constant, since the only difference is
    the Epoch that time is measure against.

    Note that for accurate work we do not want to use something like Unix
    time, because this does not account for leapseconds (POSIX unix time
    is the number of seconds since January 1, 1970 not including
    leapseconds).

    Most code doesn't care what the underlying time representation is, we
    just need to be able to do functions such as comparing two times to
    determine what is later, adding or subtracting a given number of
    seconds to a time, or give the duration between two times.

    This class abstracts out the representation we use for time. We supply
    conversions to the specific time systems for use in the cases that a
    specific system is needed (e.g., calling a PGS toolkit routine).

    We also supply methods for converting to and from a string
    representation of the time. The supported formats of the string
    parsing depends on the underlying toolkit used, but all of them
    support CCSDS format (e.g., "1996-07-03T04:13:57.987654Z").

    If either SPICE or SDP is available, then that toolkit is the one used
    for the conversion. If both are available, we default to SPICE. In
    each case, you can change the default by updating the variable
    Time::toolkit_time_interface.

    If we don't have either SPICE or SDP, then we default to using unix
    time (through the boost date_time library). This isn't ideal, but it
    is better than not supporting time at all. For a number of purposes
    the unix time is fine (e.g., indexing data in a orbit file).

    As an implementation detail, we use PGS time, which has an epoch of
    1993-01-01.

    Note there is a subtle difference between time used for Terrestrial
    uses (such as UTC) and for planetary use. There are two ways used for
    measuring time - International atomic time (TAI) and Barycentric
    Dynamic Time (TDB). The first is the time measured by an atomic clock
    on the earth vs. the second which measures time at the barycenter of
    the solar system. Due to relativistic effects, the two clocks vary by
    something close to a periodic function with a size of about 1 ms over
    the coarse of a year. We measure time durations (e.g., the difference
    between 2 times) in TAI. For most purposes, you can ignore the
    difference between the two systems.

    When calling SPICE routines, we internally convert to and from TAI
    time as needed. This is a bit less efficient than simply keeping
    everything in TDB time, but it gives a cleaner interface. We can
    revisit this if the computer time it takes to do the conversions start
    becoming prohibitive.

    C++ includes: geocal_time.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def time_et(*args):
        """
        Time Time::time_et(double et)
        Return time from given SPICE ET time. 
        """
        return _geocal_time.Time_time_et(*args)

    time_et = staticmethod(time_et)
    def time_pgs(*args):
        """
        static Time GeoCal::Time::time_pgs(double pgs)
        Return time from given PGS toolkit time (epoch of 1993-01-01). 
        """
        return _geocal_time.Time_time_pgs(*args)

    time_pgs = staticmethod(time_pgs)
    def time_j2000(*args):
        """
        static Time GeoCal::Time::time_j2000(double j2000)
        Return time from given J2000 time (epoch of 2000-01-01 12:00:00 TT).

        Note that TT is different than UTC noon by about 64.184 seconds 
        """
        return _geocal_time.Time_time_j2000(*args)

    time_j2000 = staticmethod(time_j2000)
    def time_gps(*args):
        """
        static Time GeoCal::Time::time_gps(double gps)
        Return time from given GPS time (epoch of 1980-01-06). 
        """
        return _geocal_time.Time_time_gps(*args)

    time_gps = staticmethod(time_gps)
    def time_unix(*args):
        """
        static Time GeoCal::Time::time_unix(double unix_time)
        Return time from given Unix time (epoch of 1970-01-01). 
        """
        return _geocal_time.Time_time_unix(*args)

    time_unix = staticmethod(time_unix)
    def time_acs(*args):
        """
        Time Time::time_acs(double acs_time)
        Return time from ACS time.

        ACS time is an odd time system. It is measured in UTC seconds from a
        particular epoch. The choice of UTC seconds means that this cannot
        correctly handle times that occur during a leapsecond, by definition
        the UTC time before and after a leapsecond is the same. The epoch is
        noon January, 1 2000 in UTC. Note that this is 64.184 seconds
        different from terrestrial time J2000. 
        """
        return _geocal_time.Time_time_acs(*args)

    time_acs = staticmethod(time_acs)
    def _v_acs(self):
        """
        double Time::acs() const
        Give ACS time. 
        """
        return _geocal_time.Time__v_acs(self)

    @property
    def acs(self):
        return self._v_acs()

    def _v_pgs(self):
        """
        double GeoCal::Time::pgs() const
        Give time in PGS toolkit time (epoch 1993-01-01). 
        """
        return _geocal_time.Time__v_pgs(self)

    @property
    def pgs(self):
        return self._v_pgs()

    def _v_gps(self):
        """
        double GeoCal::Time::gps() const
        Give time in GPS. 
        """
        return _geocal_time.Time__v_gps(self)

    @property
    def gps(self):
        return self._v_gps()

    def _v_j2000(self):
        """
        double GeoCal::Time::j2000() const
        Give time in j2000. 
        """
        return _geocal_time.Time__v_j2000(self)

    @property
    def j2000(self):
        return self._v_j2000()

    def _v_et(self):
        """
        double Time::et() const
        Give time as SPICE ET time. 
        """
        return _geocal_time.Time__v_et(self)

    @property
    def et(self):
        return self._v_et()

    def parse_time(*args):
        """
        static Time GeoCal::Time::parse_time(const std::string Time_string)
        Parse string to get a Time.

        Uses interface supplied by toolkit_time_interface. 
        """
        return _geocal_time.Time_parse_time(*args)

    parse_time = staticmethod(parse_time)
    def unix_time(self):
        """
        std::time_t GeoCal::Time::unix_time() const
        Give time in unix time.

        Note that this is only accurate to the nearest second. 
        """
        return _geocal_time.Time_unix_time(self)

    def __reduce__(self):
      return _new_time, (self.pgs,)

      
    def __init__(self): 
        _geocal_time.Time_swiginit(self,_geocal_time.new_Time())
    __swig_destroy__ = _geocal_time.delete_Time
Time._v_acs = new_instancemethod(_geocal_time.Time__v_acs,None,Time)
Time._v_pgs = new_instancemethod(_geocal_time.Time__v_pgs,None,Time)
Time._v_gps = new_instancemethod(_geocal_time.Time__v_gps,None,Time)
Time._v_j2000 = new_instancemethod(_geocal_time.Time__v_j2000,None,Time)
Time._v_et = new_instancemethod(_geocal_time.Time__v_et,None,Time)
Time.__str__ = new_instancemethod(_geocal_time.Time___str__,None,Time)
Time.__cmp__ = new_instancemethod(_geocal_time.Time___cmp__,None,Time)
Time.__add__ = new_instancemethod(_geocal_time.Time___add__,None,Time)
Time.__radd__ = new_instancemethod(_geocal_time.Time___radd__,None,Time)
Time.__sub__ = new_instancemethod(_geocal_time.Time___sub__,None,Time)
Time.unix_time = new_instancemethod(_geocal_time.Time_unix_time,None,Time)
Time_swigregister = _geocal_time.Time_swigregister
Time_swigregister(Time)

def Time_time_et(*args):
  """
    Time Time::time_et(double et)
    Return time from given SPICE ET time. 
    """
  return _geocal_time.Time_time_et(*args)

def Time_time_pgs(*args):
  """
    static Time GeoCal::Time::time_pgs(double pgs)
    Return time from given PGS toolkit time (epoch of 1993-01-01). 
    """
  return _geocal_time.Time_time_pgs(*args)

def Time_time_j2000(*args):
  """
    static Time GeoCal::Time::time_j2000(double j2000)
    Return time from given J2000 time (epoch of 2000-01-01 12:00:00 TT).

    Note that TT is different than UTC noon by about 64.184 seconds 
    """
  return _geocal_time.Time_time_j2000(*args)

def Time_time_gps(*args):
  """
    static Time GeoCal::Time::time_gps(double gps)
    Return time from given GPS time (epoch of 1980-01-06). 
    """
  return _geocal_time.Time_time_gps(*args)

def Time_time_unix(*args):
  """
    static Time GeoCal::Time::time_unix(double unix_time)
    Return time from given Unix time (epoch of 1970-01-01). 
    """
  return _geocal_time.Time_time_unix(*args)

def Time_time_acs(*args):
  """
    Time Time::time_acs(double acs_time)
    Return time from ACS time.

    ACS time is an odd time system. It is measured in UTC seconds from a
    particular epoch. The choice of UTC seconds means that this cannot
    correctly handle times that occur during a leapsecond, by definition
    the UTC time before and after a leapsecond is the same. The epoch is
    noon January, 1 2000 in UTC. Note that this is 64.184 seconds
    different from terrestrial time J2000. 
    """
  return _geocal_time.Time_time_acs(*args)

def Time_parse_time(*args):
  """
    static Time GeoCal::Time::parse_time(const std::string Time_string)
    Parse string to get a Time.

    Uses interface supplied by toolkit_time_interface. 
    """
  return _geocal_time.Time_parse_time(*args)
cvar = _geocal_time.cvar
Time.min_valid_time = _geocal_time.cvar.Time_min_valid_time
Time.max_valid_time = _geocal_time.cvar.Time_max_valid_time

class Vector_Time(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _geocal_time.Vector_Time_swiginit(self,_geocal_time.new_Vector_Time(*args))
    __swig_destroy__ = _geocal_time.delete_Vector_Time
Vector_Time.iterator = new_instancemethod(_geocal_time.Vector_Time_iterator,None,Vector_Time)
Vector_Time.__nonzero__ = new_instancemethod(_geocal_time.Vector_Time___nonzero__,None,Vector_Time)
Vector_Time.__bool__ = new_instancemethod(_geocal_time.Vector_Time___bool__,None,Vector_Time)
Vector_Time.__len__ = new_instancemethod(_geocal_time.Vector_Time___len__,None,Vector_Time)
Vector_Time.pop = new_instancemethod(_geocal_time.Vector_Time_pop,None,Vector_Time)
Vector_Time.__getslice__ = new_instancemethod(_geocal_time.Vector_Time___getslice__,None,Vector_Time)
Vector_Time.__setslice__ = new_instancemethod(_geocal_time.Vector_Time___setslice__,None,Vector_Time)
Vector_Time.__delslice__ = new_instancemethod(_geocal_time.Vector_Time___delslice__,None,Vector_Time)
Vector_Time.__delitem__ = new_instancemethod(_geocal_time.Vector_Time___delitem__,None,Vector_Time)
Vector_Time.__getitem__ = new_instancemethod(_geocal_time.Vector_Time___getitem__,None,Vector_Time)
Vector_Time.__setitem__ = new_instancemethod(_geocal_time.Vector_Time___setitem__,None,Vector_Time)
Vector_Time.append = new_instancemethod(_geocal_time.Vector_Time_append,None,Vector_Time)
Vector_Time.empty = new_instancemethod(_geocal_time.Vector_Time_empty,None,Vector_Time)
Vector_Time.size = new_instancemethod(_geocal_time.Vector_Time_size,None,Vector_Time)
Vector_Time.clear = new_instancemethod(_geocal_time.Vector_Time_clear,None,Vector_Time)
Vector_Time.swap = new_instancemethod(_geocal_time.Vector_Time_swap,None,Vector_Time)
Vector_Time.get_allocator = new_instancemethod(_geocal_time.Vector_Time_get_allocator,None,Vector_Time)
Vector_Time.begin = new_instancemethod(_geocal_time.Vector_Time_begin,None,Vector_Time)
Vector_Time.end = new_instancemethod(_geocal_time.Vector_Time_end,None,Vector_Time)
Vector_Time.rbegin = new_instancemethod(_geocal_time.Vector_Time_rbegin,None,Vector_Time)
Vector_Time.rend = new_instancemethod(_geocal_time.Vector_Time_rend,None,Vector_Time)
Vector_Time.pop_back = new_instancemethod(_geocal_time.Vector_Time_pop_back,None,Vector_Time)
Vector_Time.erase = new_instancemethod(_geocal_time.Vector_Time_erase,None,Vector_Time)
Vector_Time.push_back = new_instancemethod(_geocal_time.Vector_Time_push_back,None,Vector_Time)
Vector_Time.front = new_instancemethod(_geocal_time.Vector_Time_front,None,Vector_Time)
Vector_Time.back = new_instancemethod(_geocal_time.Vector_Time_back,None,Vector_Time)
Vector_Time.assign = new_instancemethod(_geocal_time.Vector_Time_assign,None,Vector_Time)
Vector_Time.resize = new_instancemethod(_geocal_time.Vector_Time_resize,None,Vector_Time)
Vector_Time.insert = new_instancemethod(_geocal_time.Vector_Time_insert,None,Vector_Time)
Vector_Time.reserve = new_instancemethod(_geocal_time.Vector_Time_reserve,None,Vector_Time)
Vector_Time.capacity = new_instancemethod(_geocal_time.Vector_Time_capacity,None,Vector_Time)
Vector_Time_swigregister = _geocal_time.Vector_Time_swigregister
Vector_Time_swigregister(Vector_Time)



