#! /usr/bin/env python
#
# This takes a VICAR file with a RSM and projects it to the surface.

import geocal
import numpy as np
import subprocess
import os
import logging

version = "October 2, 2017"
usage='''Usage:
  rsm_project [options] <image> <dem_file> <output>
  rsm_project [options] <image> <dem_file> <datum_file> <output>
  rsm_project --srtm <output>
  rsm_project --constant-dem=h <output>
  rsm_project -h | --help
  rsm_project -v | --version

rsm_project takes a VICAR file with a RSM and projects it to the surface.

Example:
    mars_generate_rsm /raid26/tllogan/mars/mawrth_vallis/source/unmapped/P16_007388_2049_XI_24N020W.IMG ctx1
    rsm_project --grid-spacing=10 --map-info=ctx1_ref_img.xml --number-process=20 --verbose --process-number-line=1000 --process-number-sample=1000 ctx1.img ctx1_proj.img

Options:
  -h --help         
       Print this message

  --outside-dem-not-error
       If a program attempts to read a DEM value outside of the supplied 
       file, this is normally treated as an error. Alternatively, you can
       specify this option and we will return a height of "0" for any
       attempt to read outside the DEM.

  --constant-dem=h
       Use a constant height DEM (a SimpleDem), with the given height.

  --dem-band=b
       The band of the DEM file to use (1 based). [default: 1]

  --datum-band=b
       The band of the Datum file to use (1 based). [default: 1]

  --constant-datum=u
       Use a datum with a constant undulation. This is useful as a quick
       way to add an offset to  DEM file. [default: 0.0]

  --srtm
       Use the SRTM rather than supplying a DEM file.

  --avg-factor=d
       The averaging factor to use on the original data before projecting
       it. If this isn't specified, we match the map resolution to the
       resolution of center pixel of the projected ImageGroundCollection.
       Otherwise, we average by the given factor. [default: -1]

  --bounding-box=f
       Use the given image to supply the bounding box for the output. 
       Note that we use the projection and bounding box, but not the
       resolution of the map info (unlike --map-info). This can be useful
       to for example cover the area of a generated DEM, even if the DEM
       is lower resolution than what we want to project here.

  --cover-image=f
       Use the given image to supply the projection. We calculate the 
       bounding box to cover the image, and use the supplied resolution.
       Compare with bounding-box option, this is useful in the same 
       circumstances where we might not want to cover the entire area of
       the file f.

  --grid-spacing=g
       Grid spacing to exactly calculate the image ground connection
       for, doing a linear interpolation in between. This can greatly
       affect how long the processing takes. If the grid spacing is
       something like the DEM resolution, usually you get almost as
       good output but much faster. [default: 1]

  --map-info=f
       Rather than generating a image to cover the full area, match exactly
       the supplied shelve image or MapInfo. This is useful to when 
       comparing against an existing image/DEM.

  --resolution=r
       Resolution in meters of output. If negative, then we use the center
       resolution of the image. [default: 1.0]

  --number-process=n
       Number of processors to use. [default: 1]

  --process-number-line=n
       Number of lines to include in each tile that we work on. This 
       controls how long each torque/parallel job takes to run.
       [default: 1000]

  --process-number-sample=n
       Number of lines to include in each tile that we work on. This 
       controls how long each torque/parallel job takes to run. 
       [default: 1000]

  --vicar-type=type
       Type of file to generate. This should by BYTE, HALF, FULL, REAL, or
       DOUB. [default: HALF]

  --verbose
       Print more information as we run.

  -v --version      
       Print program version
'''

# Mapping between long name and shorter vicar name
long_name_to_vicar = { "image" : "img",
                       "dem_file" : "dem",
                       "datum_file" : "datum",
                       "output" : "out",
                       "strtm" : "srtm",
                       "constant_dem" : "consdem",
                       "outside_dem_not_error" : "okout",
                       "dem_band" : "demband",
                       "datum_band" : "datumband",
                       "constant_datum" : "consdatum",
                       "avg_factor" : "avgfactor",
                       "bounding_box" : "bbox",
                       "cover_image": "cimage",
                       "grid_spacing" : "gspace",
                       "map_info" : "mapinfo",
                       "resolution" : "res",
                       "number_process" : "nproc",
                       "process_number_line" : "pline",
                       "process_number_sample" : "psamp",
                       "vicar_type" : "vtype",
                       "verbose" : "verbose"
                       }

args = geocal.docopt_simple(usage, version=version,
                     long_name_to_vicar=long_name_to_vicar)

# This is shelve_dem. We will want to come up with a better way of stringing
# these together, but for now just copy this code over.

def create_dem(args):
    dem = None
    if(args.srtm):
        dem = geocal.SrtmDem()
    elif(args.constant_dem and args.constant_dem != -9999.0):
        dem = geocal.SimpleDem(args.constant_dem)
    else:
        if(args.datum_file):
            datum = geocal.GdalDatum(args.datum_file, args.datum_band)
        else:
            datum = geocal.SimpleDatum(args.constant_datum)
        if geocal.VicarLiteFile.is_vicar_file(args.dem_file):
            dem = geocal.VicarLiteDem(args.dem_file, not args.outside_dem_not_error, 
                               datum, args.dem_band)
        else:
            # Check for mola file
            t = subprocess.run(["file", "-b", args.dem_file], stdout=subprocess.PIPE)
            if(t.returncode == 0 and t.stdout.find(b"PDS image data") >= 0):
                if(geocal.pds_label(args.dem_file)["DATA_SET_ID"].find("MOLA") >= 0):
                    dem = geocal.MolaDemFile(args.dem_file, not args.outside_dem_not_error)
            if(dem is None):
                dem = geocal.GdalDem(args.dem_file, datum, args.dem_band, 
                              not args.outside_dem_not_error)
    return dem

def mars_default_mi(desired_resolution = 1):
    owrap = geocal.OgrWrapper(
'''PROJCS["SimpleCylindrical Mars",
     GEOGCS["GCS_Mars",
         DATUM["D_Mars",
             SPHEROID["Mars",3396190,0]],
         PRIMEM["Reference_Meridian",0],
         UNIT["degree",0.0174532925199433]],
     PROJECTION["Equirectangular"],
     PARAMETER["latitude_of_origin",0],
     PARAMETER["central_meridian",0],
     PARAMETER["standard_parallel_1",0],
     PARAMETER["false_easting",0],
     PARAMETER["false_northing",0],
     UNIT["metre",1,
         AUTHORITY["EPSG","9001"]]]''')
    cconv = geocal.OgrCoordinateConverter(owrap)
    mi = geocal.MapInfo(cconv, 0, 0, 10000, 10000, 10000, 10000)
    return mi.scale(desired_resolution, desired_resolution)

def create_igc_map(igc, args):
    resolution = args.resolution
    if(resolution < 0):
        resolution = igc.resolution_meter()
    if(args.map_info):
        mi = geocal.GdalRasterImage(args.map_info).map_info
        if(args.bounding_box or args.cover_image):
            raise RuntimeError("Can only specify one of --map-info, --bounding-box and --cover-mage")
    elif(args.bounding_box):
        mibase = geocal.GdalRasterImage(args.bounding_box).map_info
        resbase = mibase.resolution_meter
        miscale = mibase.scale(resolution / resbase,
                               resolution / resbase)
        mp = geocal.IgcMapProjected(miscale, igc, 1, -1, False)
        mi = mp.map_info
        mp = None
        if(args.cover_image):
            raise RuntimeError("Can only specify one of --map-info, --bounding-box and --cover-mage")
    elif(args.cover_image):
        mibase = geocal.GdalRasterImage(args.cover_image).map_info
        resbase = mibase.resolution_meter
        miscale = mibase.scale(resolution / resbase,
                               resolution / resbase)
        miscale = igc.cover(miscale)
        mp = geocal.IgcMapProjected(miscale, igc, 1, -1, False)
        mi = mp.map_info
        mp = None
    else:
        naif_code = rsm.coordinate_converter.naif_code
        if(naif_code == geocal.Ecr.EARTH_NAIF_CODE):
            mibase = geocal.cib01_mapinfo(desired_resolution = resolution)
        elif(naif_code == geocal.PlanetConstant.MARS_NAIF_CODE):
            mibase = geocal.mars_default_mi(desired_resolution = resolution)
        else:
            raise RuntimeError("Don't currently support NAIF code %d" %
                               naif_code)
        mi = igc.cover(mibase)
        mp = geocal.IgcMapProjected(mi, igc, 1, -1, False)
        mi = mp.map_info
        mp = None
    igc_map = geocal.IgcMapProjected(mi, igc, args.grid_spacing, args.avg_factor,
                              False)
        
    return igc_map
        
dem = create_dem(args)
rsm = geocal.read_shelve(os.path.splitext(args.image)[0] + ".rsm.xml")
if(geocal.VicarLiteFile.is_vicar_file(args.image)):
    img = geocal.VicarLiteRasterImage(args.image)
else:
    img = geocal.GdalRasterImage(args.image)
igc = geocal.RsmImageGroundConnection(rsm, dem, img, "RSM Image")
igc_map = create_igc_map(igc, args)

if(args.verbose):
    logging.basicConfig(level = logging.INFO)
log = logging.getLogger("geocal-python.rsm_project")
if(args.vicar_type == "DOUB"):
    dtype = np.float64
elif(args.vicar_type == "REAL"):
    dtype = np.float32
elif(args.vicar_type == "BYTE"):
    dtype = np.int8
elif(args.vicar_type == "HALF"):
    dtype = np.int16
elif(args.vicar_type == "FULL"):
    dtype = np.int32
else:
    raise RuntimeError("Unknown vicar type %s" % args.vicar_type)
out = geocal.mmap_file(args.output, igc_map.map_info, dtype=dtype)
geocal.parallel_process_image(igc_map, out, args.process_number_line,
                       args.process_number_sample, args.number_process)
