# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _tie_point.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_tie_point', [dirname(__file__)])
        except ImportError:
            import _tie_point
            return _tie_point
        if fp is not None:
            try:
                _mod = imp.load_module('_tie_point', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _tie_point = swig_import_helper()
    del swig_import_helper
else:
    import _tie_point
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tie_point.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_tie_point.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_tie_point.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_tie_point.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_tie_point.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_tie_point.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_tie_point.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_tie_point.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_tie_point.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_tie_point.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_tie_point.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_tie_point.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_tie_point.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_tie_point.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_tie_point.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_tie_point.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_tie_point.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _tie_point.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_tie_point.SHARED_PTR_DISOWN_swigconstant(_tie_point)
SHARED_PTR_DISOWN = _tie_point.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.generic_object
import geocal_swig.look_vector
import geocal_swig.with_parameter
import geocal_swig.geocal_exception
class TiePoint(geocal_swig.generic_object.GenericObject):
    """

    This is a tiepoint.

    This is little more than a structure.

    Note that we previously had TiePoint a python only object, and stored
    it as a python pickled object. The primary motivation for moving this
    to C++ is to be able to use the boost XML serialization, which is more
    stable and can support old versions. If you have an older tiepoint
    data using the old pickle format, you can either rerun the process
    that generated the tie points, or you can run the old version of the
    code, write the tiepoints out as the old MSPI format
    (write_old_mspi_format defined in python), and the read the old MSPI
    format using the new version of the code with the tiepoints in C++.
    This is just a temporary fix, going forward the intention is that the
    tiepoints will use the boost format and will automatically support
    older versions.

    C++ includes: tie_point.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        TiePoint::TiePoint(const TiePoint &Tp)
        Copy constructor. We make a deep copy of everything. 
        """
        _tie_point.TiePoint_swiginit(self, _tie_point.new_TiePoint(*args))

    def _v_id(self, *args):
        """

        void GeoCal::TiePoint::id(int V)

        """
        return _tie_point.TiePoint__v_id(self, *args)


    @property
    def id(self):
        return self._v_id()

    @id.setter
    def id(self, value):
      self._v_id(value)


    def _v_is_gcp(self, *args):
        """

        void GeoCal::TiePoint::is_gcp(bool V)

        """
        return _tie_point.TiePoint__v_is_gcp(self, *args)


    @property
    def is_gcp(self):
        return self._v_is_gcp()

    @is_gcp.setter
    def is_gcp(self, value):
      self._v_is_gcp(value)


    def _v_ground_location(self, *args):
        """

        void GeoCal::TiePoint::ground_location(const boost::shared_ptr< GroundCoordinate > &Gc)

        """
        return _tie_point.TiePoint__v_ground_location(self, *args)


    @property
    def ground_location(self):
        return self._v_ground_location()

    @ground_location.setter
    def ground_location(self, value):
      self._v_ground_location(value)


    def _v_number_image(self):
        """

        int GeoCal::TiePoint::number_image() const
        Number of images covered by the tie point. 
        """
        return _tie_point.TiePoint__v_number_image(self)


    @property
    def number_image(self):
        return self._v_number_image()


    def _v_number_image_location(self):
        """

        int GeoCal::TiePoint::number_image_location() const

        """
        return _tie_point.TiePoint__v_number_image_location(self)


    @property
    def number_image_location(self):
        return self._v_number_image_location()


    def image_coordinate(self, *args):
        """

        void GeoCal::TiePoint::image_coordinate(int Image_index, const boost::shared_ptr< ImageCoordinate > &Ic,
        double Line_sigma=0.1, double Sample_sigma=0.1)

        """
        return _tie_point.TiePoint_image_coordinate(self, *args)


    def line_sigma(self, Image_index):
        """

        double GeoCal::TiePoint::line_sigma(int Image_index) const
        Line sigma. 
        """
        return _tie_point.TiePoint_line_sigma(self, Image_index)


    def sample_sigma(self, Image_index):
        """

        double GeoCal::TiePoint::sample_sigma(int Image_index) const
        Sample sigma. 
        """
        return _tie_point.TiePoint_sample_sigma(self, Image_index)


    def _v_ic(self):
        """

        blitz::Array< double, 2 > TiePoint::ic() const
        This repackages the image_coordinate, in a better way for doing such
        things as plotting.

        We return a 2D array with the first row being the image line and the
        second the image sample. The columns are the image indexes. For image
        locations that are missing, we return a NaN.

        This is really intended for use by python, I'm not sure this would be
        of much use in C++. 
        """
        return _tie_point.TiePoint__v_ic(self)


    @property
    def ic(self):
        return self._v_ic()


    def _v_ic_sigma(self):
        """

        blitz::Array< double, 2 > TiePoint::ic_sigma() const
        Like ic, but return line and sample sigma. 
        """
        return _tie_point.TiePoint__v_ic_sigma(self)


    @property
    def ic_sigma(self):
        return self._v_ic_sigma()


    def ic_pred(self, Igccol):
        """

        blitz::Array< double, 2 > TiePoint::ic_pred(const IgcCollection &Igccol) const
        Like ic, but uses the supplied igccol to predict the image location
        given our current ground position. 
        """
        return _tie_point.TiePoint_ic_pred(self, Igccol)


    def ic_diff(self, Igccol):
        """

        blitz::Array< double, 2 > TiePoint::ic_diff(const IgcCollection &Igccol) const
        Difference between observed and predicted image coordinates. 
        """
        return _tie_point.TiePoint_ic_diff(self, Igccol)


    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _tie_point.delete_TiePoint
TiePoint._v_id = new_instancemethod(_tie_point.TiePoint__v_id, None, TiePoint)
TiePoint._v_is_gcp = new_instancemethod(_tie_point.TiePoint__v_is_gcp, None, TiePoint)
TiePoint._v_ground_location = new_instancemethod(_tie_point.TiePoint__v_ground_location, None, TiePoint)
TiePoint._v_number_image = new_instancemethod(_tie_point.TiePoint__v_number_image, None, TiePoint)
TiePoint._v_number_image_location = new_instancemethod(_tie_point.TiePoint__v_number_image_location, None, TiePoint)
TiePoint.image_coordinate = new_instancemethod(_tie_point.TiePoint_image_coordinate, None, TiePoint)
TiePoint.line_sigma = new_instancemethod(_tie_point.TiePoint_line_sigma, None, TiePoint)
TiePoint.sample_sigma = new_instancemethod(_tie_point.TiePoint_sample_sigma, None, TiePoint)
TiePoint.__str__ = new_instancemethod(_tie_point.TiePoint___str__, None, TiePoint)
TiePoint._v_ic = new_instancemethod(_tie_point.TiePoint__v_ic, None, TiePoint)
TiePoint._v_ic_sigma = new_instancemethod(_tie_point.TiePoint__v_ic_sigma, None, TiePoint)
TiePoint.ic_pred = new_instancemethod(_tie_point.TiePoint_ic_pred, None, TiePoint)
TiePoint.ic_diff = new_instancemethod(_tie_point.TiePoint_ic_diff, None, TiePoint)
TiePoint_swigregister = _tie_point.TiePoint_swigregister
TiePoint_swigregister(TiePoint)

class TiePointVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __init__(self, *args):
        _tie_point.TiePointVector_swiginit(self, _tie_point.new_TiePointVector(*args))
    __swig_destroy__ = _tie_point.delete_TiePointVector
TiePointVector.iterator = new_instancemethod(_tie_point.TiePointVector_iterator, None, TiePointVector)
TiePointVector.__nonzero__ = new_instancemethod(_tie_point.TiePointVector___nonzero__, None, TiePointVector)
TiePointVector.__bool__ = new_instancemethod(_tie_point.TiePointVector___bool__, None, TiePointVector)
TiePointVector.__len__ = new_instancemethod(_tie_point.TiePointVector___len__, None, TiePointVector)
TiePointVector.pop = new_instancemethod(_tie_point.TiePointVector_pop, None, TiePointVector)
TiePointVector.__getslice__ = new_instancemethod(_tie_point.TiePointVector___getslice__, None, TiePointVector)
TiePointVector.__setslice__ = new_instancemethod(_tie_point.TiePointVector___setslice__, None, TiePointVector)
TiePointVector.__delslice__ = new_instancemethod(_tie_point.TiePointVector___delslice__, None, TiePointVector)
TiePointVector.__delitem__ = new_instancemethod(_tie_point.TiePointVector___delitem__, None, TiePointVector)
TiePointVector.__getitem__ = new_instancemethod(_tie_point.TiePointVector___getitem__, None, TiePointVector)
TiePointVector.__setitem__ = new_instancemethod(_tie_point.TiePointVector___setitem__, None, TiePointVector)
TiePointVector.append = new_instancemethod(_tie_point.TiePointVector_append, None, TiePointVector)
TiePointVector.empty = new_instancemethod(_tie_point.TiePointVector_empty, None, TiePointVector)
TiePointVector.size = new_instancemethod(_tie_point.TiePointVector_size, None, TiePointVector)
TiePointVector.clear = new_instancemethod(_tie_point.TiePointVector_clear, None, TiePointVector)
TiePointVector.swap = new_instancemethod(_tie_point.TiePointVector_swap, None, TiePointVector)
TiePointVector.get_allocator = new_instancemethod(_tie_point.TiePointVector_get_allocator, None, TiePointVector)
TiePointVector.begin = new_instancemethod(_tie_point.TiePointVector_begin, None, TiePointVector)
TiePointVector.end = new_instancemethod(_tie_point.TiePointVector_end, None, TiePointVector)
TiePointVector.rbegin = new_instancemethod(_tie_point.TiePointVector_rbegin, None, TiePointVector)
TiePointVector.rend = new_instancemethod(_tie_point.TiePointVector_rend, None, TiePointVector)
TiePointVector.pop_back = new_instancemethod(_tie_point.TiePointVector_pop_back, None, TiePointVector)
TiePointVector.erase = new_instancemethod(_tie_point.TiePointVector_erase, None, TiePointVector)
TiePointVector.push_back = new_instancemethod(_tie_point.TiePointVector_push_back, None, TiePointVector)
TiePointVector.front = new_instancemethod(_tie_point.TiePointVector_front, None, TiePointVector)
TiePointVector.back = new_instancemethod(_tie_point.TiePointVector_back, None, TiePointVector)
TiePointVector.assign = new_instancemethod(_tie_point.TiePointVector_assign, None, TiePointVector)
TiePointVector.resize = new_instancemethod(_tie_point.TiePointVector_resize, None, TiePointVector)
TiePointVector.insert = new_instancemethod(_tie_point.TiePointVector_insert, None, TiePointVector)
TiePointVector.reserve = new_instancemethod(_tie_point.TiePointVector_reserve, None, TiePointVector)
TiePointVector.capacity = new_instancemethod(_tie_point.TiePointVector_capacity, None, TiePointVector)
TiePointVector_swigregister = _tie_point.TiePointVector_swigregister
TiePointVector_swigregister(TiePointVector)

class TiePointCollection(geocal_swig.generic_object.GenericObject, TiePointVector):
    """

    This is a list of TiePoints with a few useful functions added.

    C++ includes: tie_point.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        GeoCal::TiePointCollection::TiePointCollection(const TiePointVector &Tlist)
        Constructor with an initial list of TiePoints. 
        """
        _tie_point.TiePointCollection_swiginit(self, _tie_point.new_TiePointCollection(*args))

    def _v_number_gcp(self):
        """

        int TiePointCollection::number_gcp() const
        Number of gcps. 
        """
        return _tie_point.TiePointCollection__v_number_gcp(self)


    @property
    def number_gcp(self):
        return self._v_number_gcp()


    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _tie_point.delete_TiePointCollection
TiePointCollection._v_number_gcp = new_instancemethod(_tie_point.TiePointCollection__v_number_gcp, None, TiePointCollection)
TiePointCollection.__str__ = new_instancemethod(_tie_point.TiePointCollection___str__, None, TiePointCollection)
TiePointCollection_swigregister = _tie_point.TiePointCollection_swigregister
TiePointCollection_swigregister(TiePointCollection)



