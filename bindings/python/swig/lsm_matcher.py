# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
from ._swig_wrap import _lsm_matcher

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _lsm_matcher.SWIG_PyInstanceMethod_New
_swig_new_static_method = _lsm_matcher.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_MODULE_ALREADY_DONE = _lsm_matcher.SWIG_MODULE_ALREADY_DONE
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _lsm_matcher.delete_SwigPyIterator
    value = _swig_new_instance_method(_lsm_matcher.SwigPyIterator_value)
    incr = _swig_new_instance_method(_lsm_matcher.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_lsm_matcher.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_lsm_matcher.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_lsm_matcher.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_lsm_matcher.SwigPyIterator_copy)
    next = _swig_new_instance_method(_lsm_matcher.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_lsm_matcher.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_lsm_matcher.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_lsm_matcher.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_lsm_matcher.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_lsm_matcher.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_lsm_matcher.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_lsm_matcher.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_lsm_matcher.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_lsm_matcher.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _lsm_matcher:
_lsm_matcher.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _lsm_matcher.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_function.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_function.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.image_matcher
import geocal_swig.generic_object
import geocal_swig.with_parameter
import geocal_swig.geocal_exception
class LsmMatcher(geocal_swig.image_matcher.ImageMatcher):
    r"""

    This class performs image matching.

    This does a nonlinear least squares match. It also calculates an
    estimate of the error in its matching.

    We attempt to reach a goal of precision_goal in determining a0 and b0.
    If at any iteration, the uncertainty in determining a0 and b0 is
    greater than max_sigma, then we give up on doing LSM. If the final
    uncertainty in determining a0 and b0 is larger than
    precision_requirement, then we give up on doing LSM. We now also check
    radiometric uncertainty at each iteration as described in MISR SDS
    DFM-0245-I. The maximum allowed radiometric uncertainty is calculated
    by multiplying the factor radiometric_uncertainty_factor by the
    minimum of the template and target window sigmas. After each iteration
    in the lsm the uncertainty in the calculation of h0 is greater than
    this threshold we stop doing LSM and return unsuccessful.

    The minimum uncertainty that will be returned is precision_goal (i.e.,
    if the estimated uncertainty is smaller than this value, then
    precision_goal is returned instead).

    The model used is to resample the target using an affine
    transformation combined with a linear correction to the radiometry:

    g'(i, j) = h0 + h1 * g(a0 + a1 * i + a2 * j, b0 + b1 * i + b2 * j)

    Where g is the target, g' is the template.

    As a convention, internal to this class we index things so g'(0, 0) is
    the center of the template.

    We solve for the parameters giving the best fit against the template.

    C++ includes: lsm_matcher.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, Number_line=21, Number_sample=21, Border_size=3, Precision_goal=0.0625, Precision_requirement=0.2, Max_sigma=0.5, Rad_uncertainty_factor=2.0, Precision_min_geo_goal=0.15, Precision_min_rad_goal=1):
        r"""

        BZ_END_STENCIL LsmMatcher::LsmMatcher(int Number_line=21, int Number_sample=21, int Border_size=3, double
        Precision_goal=0.0625, double Precision_requirement=0.2, double
        Max_sigma=0.5, double Rad_uncertainty_factor=2.0, double
        Precision_min_geo_goal=0.15, double Precision_min_rad_goal=1)
        GeoCal::LsmMatcher::LsmMatcher
        Constructor.
        Default values were tuned for MISR imagery, but work well for other
        imagery. 
        """
        _lsm_matcher.LsmMatcher_swiginit(self, _lsm_matcher.new_LsmMatcher(Number_line, Number_sample, Border_size, Precision_goal, Precision_requirement, Max_sigma, Rad_uncertainty_factor, Precision_min_geo_goal, Precision_min_rad_goal))
    _v_number_line = _swig_new_instance_method(_lsm_matcher.LsmMatcher__v_number_line)

    @property
    def number_line(self):
        return self._v_number_line()

    _v_number_sample = _swig_new_instance_method(_lsm_matcher.LsmMatcher__v_number_sample)

    @property
    def number_sample(self):
        return self._v_number_sample()

    _v_border_size = _swig_new_instance_method(_lsm_matcher.LsmMatcher__v_border_size)

    @property
    def border_size(self):
        return self._v_border_size()

    _v_precision_goal = _swig_new_instance_method(_lsm_matcher.LsmMatcher__v_precision_goal)

    @property
    def precision_goal(self):
        return self._v_precision_goal()

    _v_precision_requirement = _swig_new_instance_method(_lsm_matcher.LsmMatcher__v_precision_requirement)

    @property
    def precision_requirement(self):
        return self._v_precision_requirement()

    _v_max_sigma = _swig_new_instance_method(_lsm_matcher.LsmMatcher__v_max_sigma)

    @property
    def max_sigma(self):
        return self._v_max_sigma()

    _v_rad_uncertainty_factor = _swig_new_instance_method(_lsm_matcher.LsmMatcher__v_rad_uncertainty_factor)

    @property
    def rad_uncertainty_factor(self):
        return self._v_rad_uncertainty_factor()

    _v_precision_min_geo_goal = _swig_new_instance_method(_lsm_matcher.LsmMatcher__v_precision_min_geo_goal)

    @property
    def precision_min_geo_goal(self):
        return self._v_precision_min_geo_goal()

    _v_precision_min_rad_goal = _swig_new_instance_method(_lsm_matcher.LsmMatcher__v_precision_min_rad_goal)

    @property
    def precision_min_rad_goal(self):
        return self._v_precision_min_rad_goal()


    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)

    __swig_destroy__ = _lsm_matcher.delete_LsmMatcher

# Register LsmMatcher in _lsm_matcher:
_lsm_matcher.LsmMatcher_swigregister(LsmMatcher)

__all__ = ["LsmMatcher"]


