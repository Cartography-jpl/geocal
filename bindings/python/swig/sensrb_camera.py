# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _sensrb_camera.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_sensrb_camera')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_sensrb_camera')
    _sensrb_camera = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_sensrb_camera', [dirname(__file__)])
        except ImportError:
            import _sensrb_camera
            return _sensrb_camera
        try:
            _mod = imp.load_module('_sensrb_camera', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _sensrb_camera = swig_import_helper()
    del swig_import_helper
else:
    import _sensrb_camera
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SWIG_MODULE_ALREADY_DONE = _sensrb_camera.SWIG_MODULE_ALREADY_DONE
class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _sensrb_camera.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_sensrb_camera.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_sensrb_camera.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_sensrb_camera.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_sensrb_camera.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_sensrb_camera.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_sensrb_camera.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_sensrb_camera.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_sensrb_camera.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_sensrb_camera.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_sensrb_camera.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_sensrb_camera.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_sensrb_camera.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_sensrb_camera.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_sensrb_camera.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_sensrb_camera.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_sensrb_camera.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _sensrb_camera.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _sensrb_camera.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_function.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_function.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.quaternion_camera
import geocal_swig.generic_object
import geocal_swig.observer
import geocal_swig.camera
import geocal_swig.with_parameter
class SensrbCamera(geocal_swig.quaternion_camera.QuaternionCamera):
    """

    This is a QuaternionCamera where the nonlinearity of the camera is
    described by a radial model.

    r^2 = x^2 + y^2 dr/r = k1 * r^2 + k2 * r^4 + k3 * r^3 x_corrected = x
    + (dr/r)*x + p1 * (r^2 + 2 x^2) + 2 p2 * x * y + b1 * x + b2 * y
    y_corrected = x + (dr/r)*x + p2 *(r^2 + 2 y^2) + 2 p1 * x * y

    Note this is similar to but not identical to the Brown-Conrady
    distortion model,
    seehttps://en.wikipedia.org/wiki/Distortion_(optics).

    Note, I think we need to have the various constants in mm rather than
    pixel - I think this is required by MSP library and normally we do
    this in x,y space - not line/sample space.

    This is the camera model used by the SENSRB TRE in NITF files.

    The convention used by SENSRB is that line is in the +y direction,
    sample is the -x direction (so different than the default for
    QuaternionCamera class). This is the "Camera" coordinates, there is
    another (and different) coordinate system called "Sensor". See
    "SENSRB Profile Frame Image-To-Ground Transformation Description" by
    Michael J. Lenihan.

    The coordinate system for the angles is "SENSOR_ANGLE_MODEL = 1"
    which actually has a bit of a odd orientation. It appears to be
    something like the pilot holding the camera in front of his face. This
    means that all angles 0 actually doesn't point the camera towards the
    ground (most of our models have had nadir pointing camera have an
    identity quaternion).

    There are other SENSOR_ANGLE_MODEL (2 and 3), but the MSP library
    doesn't support these. We could add support for these in the future if
    useful (e.g., change quaternion_to_sensor_angle to take the model
    number).

    The actual camera model just as a normal frame_to_sc() like other
    QuaternionCamera. We handle mapping this too and from the sensor
    angles used NITF through the various static functions (e.g.,
    quaternion_to_sensor_angle).

    C++ includes: sensrb_camera.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        GeoCal::SensrbCamera::SensrbCamera(const boost::math::quaternion< double > &Frame_to_sc_q, double K1,
        double K2, double K3, double P1, double P2, double B1, double B2,
        double Radial_distort_limit, int Number_line, int Number_sample,
        double Line_pitch, double Sample_pitch, double Focal_length, const
        FrameCoordinate &Principal_point, const std::string
        &Detection_type="VIS", const std::string
        &Calibration_date="20000101", QuaternionCamera::FrameConvention
        Frame_convention=QuaternionCamera::LINE_IS_Y,
        QuaternionCamera::FrameDirection
        Line_direction=QuaternionCamera::INCREASE_IS_POSITIVE,
        QuaternionCamera::FrameDirection
        Sample_direction=QuaternionCamera::INCREASE_IS_NEGATIVE)
        Create a QuaternionCamera with a radial distortion model given by
        kdistort.

        We currently limit kdistort.rows() <= 3, although we could relax that
        if it ends up being useful. 
        """
        _sensrb_camera.SensrbCamera_swiginit(self, _sensrb_camera.new_SensrbCamera(*args))

    def _v_p_distort(self):
        """

        const blitz::Array<double, 1>& GeoCal::SensrbCamera::p_distort() const
        Parameters describing nonlinearity. 
        """
        return _sensrb_camera.SensrbCamera__v_p_distort(self)


    @property
    def p_distort(self):
        return self._v_p_distort()


    def _v_k1(self, *args):
        """

        void GeoCal::SensrbCamera::k1(double V)

        """
        return _sensrb_camera.SensrbCamera__v_k1(self, *args)


    @property
    def k1(self):
        return self._v_k1()

    @k1.setter
    def k1(self, value):
      self._v_k1(value)


    def _v_k2(self, *args):
        """

        void GeoCal::SensrbCamera::k2(double V)

        """
        return _sensrb_camera.SensrbCamera__v_k2(self, *args)


    @property
    def k2(self):
        return self._v_k2()

    @k2.setter
    def k2(self, value):
      self._v_k2(value)


    def _v_k3(self, *args):
        """

        void GeoCal::SensrbCamera::k3(double V)

        """
        return _sensrb_camera.SensrbCamera__v_k3(self, *args)


    @property
    def k3(self):
        return self._v_k3()

    @k3.setter
    def k3(self, value):
      self._v_k3(value)


    def _v_p1(self, *args):
        """

        void GeoCal::SensrbCamera::p1(double V)

        """
        return _sensrb_camera.SensrbCamera__v_p1(self, *args)


    @property
    def p1(self):
        return self._v_p1()

    @p1.setter
    def p1(self, value):
      self._v_p1(value)


    def _v_p2(self, *args):
        """

        void GeoCal::SensrbCamera::p2(double V)

        """
        return _sensrb_camera.SensrbCamera__v_p2(self, *args)


    @property
    def p2(self):
        return self._v_p2()

    @p2.setter
    def p2(self, value):
      self._v_p2(value)


    def _v_b1(self, *args):
        """

        void GeoCal::SensrbCamera::b1(double V)

        """
        return _sensrb_camera.SensrbCamera__v_b1(self, *args)


    @property
    def b1(self):
        return self._v_b1()

    @b1.setter
    def b1(self, value):
      self._v_b1(value)


    def _v_b2(self, *args):
        """

        void GeoCal::SensrbCamera::b2(double V)

        """
        return _sensrb_camera.SensrbCamera__v_b2(self, *args)


    @property
    def b2(self):
        return self._v_b2()

    @b2.setter
    def b2(self, value):
      self._v_b2(value)


    def _v_radial_distort_limit(self, *args):
        """

        void GeoCal::SensrbCamera::radial_distort_limit(double V)

        """
        return _sensrb_camera.SensrbCamera__v_radial_distort_limit(self, *args)


    @property
    def radial_distort_limit(self):
        return self._v_radial_distort_limit()

    @radial_distort_limit.setter
    def radial_distort_limit(self, value):
      self._v_radial_distort_limit(value)


    def _v_calibration_date(self, *args):
        """

        void GeoCal::SensrbCamera::calibration_date(const std::string &V)

        """
        return _sensrb_camera.SensrbCamera__v_calibration_date(self, *args)


    @property
    def calibration_date(self):
        return self._v_calibration_date()

    @calibration_date.setter
    def calibration_date(self, value):
      self._v_calibration_date(value)


    def _v_detection_type(self, *args):
        """

        void GeoCal::SensrbCamera::detection_type(const std::string &V)

        """
        return _sensrb_camera.SensrbCamera__v_detection_type(self, *args)


    @property
    def detection_type(self):
        return self._v_detection_type()

    @detection_type.setter
    def detection_type(self, value):
      self._v_detection_type(value)


    def quaternion_to_sensor_angle(Frame_to_sc_or_ned):
        """

        void SensrbCamera::quaternion_to_sensor_angle(const boost::math::quaternion< double > &Frame_to_sc_or_ned, double
        &Sensor_angle_1, double &Sensor_angle_2, double &Sensor_angle_3)
        Convert a quaternion to sensor angles 1 through 3.

        Depending on the values in SENSRB, the angles either describe the
        angles relative to the platform coordinate system or relative the
        local NED coordinate system. In the first case, the quaternion would
        be the normal frame_to_sc() quaternion found in a SensrbCamera, or the
        combination of the frame_to_sc() and the body_to_local_north() found
        in AircraftOrbitData.

        Note that the angles are in degrees. They are also passive rotation
        angles rather than active (so negative of the angles we normally use
        in our quaternion calculations). 
        """
        return _sensrb_camera.SensrbCamera_quaternion_to_sensor_angle(Frame_to_sc_or_ned)

    quaternion_to_sensor_angle = staticmethod(quaternion_to_sensor_angle)

    def sensor_angle_to_quaternion(Sensor_angle_1, Sensor_angle_2, Sensor_angle_3):
        """

        boost::math::quaternion< double > SensrbCamera::sensor_angle_to_quaternion(double Sensor_angle_1, double Sensor_angle_2, double Sensor_angle_3)
        Convert sensor angles 1 through 3 to a frame_to_sc() quaternion.

        This version is for when this is relative to the platform.

        Note that the angles are in degrees. They are also passive rotation
        angles rather than active (so negative of the angles we normally use
        in our quaternion calculations). 
        """
        return _sensrb_camera.SensrbCamera_sensor_angle_to_quaternion(Sensor_angle_1, Sensor_angle_2, Sensor_angle_3)

    sensor_angle_to_quaternion = staticmethod(sensor_angle_to_quaternion)

    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)

    __swig_destroy__ = _sensrb_camera.delete_SensrbCamera
SensrbCamera._v_p_distort = new_instancemethod(_sensrb_camera.SensrbCamera__v_p_distort, None, SensrbCamera)
SensrbCamera._v_k1 = new_instancemethod(_sensrb_camera.SensrbCamera__v_k1, None, SensrbCamera)
SensrbCamera._v_k2 = new_instancemethod(_sensrb_camera.SensrbCamera__v_k2, None, SensrbCamera)
SensrbCamera._v_k3 = new_instancemethod(_sensrb_camera.SensrbCamera__v_k3, None, SensrbCamera)
SensrbCamera._v_p1 = new_instancemethod(_sensrb_camera.SensrbCamera__v_p1, None, SensrbCamera)
SensrbCamera._v_p2 = new_instancemethod(_sensrb_camera.SensrbCamera__v_p2, None, SensrbCamera)
SensrbCamera._v_b1 = new_instancemethod(_sensrb_camera.SensrbCamera__v_b1, None, SensrbCamera)
SensrbCamera._v_b2 = new_instancemethod(_sensrb_camera.SensrbCamera__v_b2, None, SensrbCamera)
SensrbCamera._v_radial_distort_limit = new_instancemethod(_sensrb_camera.SensrbCamera__v_radial_distort_limit, None, SensrbCamera)
SensrbCamera._v_calibration_date = new_instancemethod(_sensrb_camera.SensrbCamera__v_calibration_date, None, SensrbCamera)
SensrbCamera._v_detection_type = new_instancemethod(_sensrb_camera.SensrbCamera__v_detection_type, None, SensrbCamera)
SensrbCamera_swigregister = _sensrb_camera.SensrbCamera_swigregister
SensrbCamera_swigregister(SensrbCamera)

def SensrbCamera_quaternion_to_sensor_angle(Frame_to_sc_or_ned):
    """

    void SensrbCamera::quaternion_to_sensor_angle(const boost::math::quaternion< double > &Frame_to_sc_or_ned, double
    &Sensor_angle_1, double &Sensor_angle_2, double &Sensor_angle_3)
    Convert a quaternion to sensor angles 1 through 3.

    Depending on the values in SENSRB, the angles either describe the
    angles relative to the platform coordinate system or relative the
    local NED coordinate system. In the first case, the quaternion would
    be the normal frame_to_sc() quaternion found in a SensrbCamera, or the
    combination of the frame_to_sc() and the body_to_local_north() found
    in AircraftOrbitData.

    Note that the angles are in degrees. They are also passive rotation
    angles rather than active (so negative of the angles we normally use
    in our quaternion calculations). 
    """
    return _sensrb_camera.SensrbCamera_quaternion_to_sensor_angle(Frame_to_sc_or_ned)

def SensrbCamera_sensor_angle_to_quaternion(Sensor_angle_1, Sensor_angle_2, Sensor_angle_3):
    """

    boost::math::quaternion< double > SensrbCamera::sensor_angle_to_quaternion(double Sensor_angle_1, double Sensor_angle_2, double Sensor_angle_3)
    Convert sensor angles 1 through 3 to a frame_to_sc() quaternion.

    This version is for when this is relative to the platform.

    Note that the angles are in degrees. They are also passive rotation
    angles rather than active (so negative of the angles we normally use
    in our quaternion calculations). 
    """
    return _sensrb_camera.SensrbCamera_sensor_angle_to_quaternion(Sensor_angle_1, Sensor_angle_2, Sensor_angle_3)


__all__ = ["SensrbCamera"]



