#! /usr/bin/env python
#
# This map projects a ImageGroundConnection to the surface, generating
# a map projected image.

from afids import *
from functools import partial
from multiprocessing import Pool

version = "October 8, 2013"
usage='''Usage: 
  igc_project [options] <igc> <output>
  igc_project [options] <igc_collection> <image_index> <output>
  igc_project -h | --help
  igc_project -v | --version

This map projects a ImageGroundConnection to the surface, generating
a map projected image. The igc_collection should be in the normal
"file:key" format. The index number for which image to use is supplied,
this is -0-based. The output is also "file:key". To actually generate
a file, use "write_image" program.

Options:
  -h --help         
       Print this message

  --avg_factor=d
       The averaging factor to use on the original data before projecting
       it. If this isn't specified, we match the map resolution to the
       resolution of center pixel of the projected ImageGroundCollection.
       Otherwise, we average by the given factor. [default: -1]

  --bounding-box=mi
       Use the given image to supply the bounding box for the output. 
       Note that we use the projection and bounding box, but not the
       resolution of the map info (unlike --map-info). This can be useful
       to for example cover the area of a generated DEM, even if the DEM
       is lower resolution than what we want to project here.

  --dem=shelve
       DEM to use, specified as file:key. If not specified, we use the 
       DEM from the IGC.

  --grid-spacing=g
       Grid spacing to exactly calculate the image ground connection
       for, doing a linear interpolation in between. This can greatly
       affect how long the processing takes. If the grid spacing is
       something like the DEM resolution, usually you get almost as
       good output but much faster. [default: 1]

  --map-info=f
       Rather than generating a image to cover the full area, match exactly
       the supplied shelve image. This is useful to when comparing against
       an existing image/DEM.

  --resolution=r
       Resolution in meters of output. [default: 1.0]

  -v --version      
       Print program version
'''

args = docopt_simple(usage, version=version)

if(args.igc_collection):
    igc_col = read_shelve(args.igc_collection)
    igc = igc_col.image_ground_connection(args.image_index)
else:
    igc = read_shelve(args.igc)

if(args.dem):
    igc.dem = read_shelve(args.dem)

# Create the map projection object, and the output object

if(args.map_info):
    mi = read_shelve(args.map_info).map_info
elif(args.bounding_box):
    mibase = read_shelve(args.bounding_box).map_info
    resbase = mibase.resolution_meter
    miscale = mibase.scale(args.resolution / resbase, args.resolution / resbase)
    if(igc.image):
        mp = IgcMapProjected(miscale, igc, 1, -1, False)
        mi = mp.map_info
    else:
        mp = IgcMapProjectedMultiBand(miscale, igc, 1, -1, False)
        mi = mp.raster_image(0).map_info
    mp = None
else:
    mibase = cib01_mapinfo()
    resbase = mibase.resolution_meter
    miscale = mibase.scale(args.resolution / resbase, args.resolution / resbase)
    mi = igc.cover(miscale)
    if(igc.image):
        mp = IgcMapProjected(mi, igc, 1, -1, False)
        mi = mp.map_info
    else:
        mp = IgcMapProjectedMultiBand(mi, igc, 1, -1, False)
        mi = mp.raster_image(0).map_info
    mp = None

if(igc.image):
    igc = IgcMapProjected(mi, igc, args.grid_spacing, args.avg_factor, False)
else:
    igc = IgcMapProjectedMultiBand(mi, igc, args.grid_spacing, 
                                   args.avg_factor, False)
    
write_shelve(args.output, igc)
