# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _orbit_quaternion_list.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_orbit_quaternion_list')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_orbit_quaternion_list')
    _orbit_quaternion_list = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_orbit_quaternion_list', [dirname(__file__)])
        except ImportError:
            import _orbit_quaternion_list
            return _orbit_quaternion_list
        try:
            _mod = imp.load_module('_orbit_quaternion_list', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _orbit_quaternion_list = swig_import_helper()
    del swig_import_helper
else:
    import _orbit_quaternion_list
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SWIG_MODULE_ALREADY_DONE = _orbit_quaternion_list.SWIG_MODULE_ALREADY_DONE
class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _orbit_quaternion_list.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_orbit_quaternion_list.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_orbit_quaternion_list.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_orbit_quaternion_list.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_orbit_quaternion_list.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_orbit_quaternion_list.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_orbit_quaternion_list.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_orbit_quaternion_list.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_orbit_quaternion_list.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_orbit_quaternion_list.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_orbit_quaternion_list.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_orbit_quaternion_list.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_orbit_quaternion_list.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_orbit_quaternion_list.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_orbit_quaternion_list.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_orbit_quaternion_list.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_orbit_quaternion_list.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _orbit_quaternion_list.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _orbit_quaternion_list.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_function.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_function.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.orbit
import geocal_swig.generic_object
import geocal_swig.observer
import geocal_swig.with_parameter
import geocal_swig.look_vector
class OrbitQuaternionList(geocal_swig.orbit.Orbit):
    """

    This is an implementation of an Orbit that is a list of
    QuaternionOrbitData values.

    For times that fall between these values, we interpolate to get the
    OrbitData.

    Note that for some classes the calculation of the full list of
    QuaternionOrbitData might not be needed, for example an Orbit file
    covering a full day of which we are only using a subset of the data.
    To support this, we allow a lazy evaluation of the
    QuaternionOrbitData. It can initially be supplied as a null
    boost::shared_ptr, and when we encounter a null we call the function
    orbit_data_create. This function should be overriden by a derived
    class to supply the calculation of a QuaternionOrbitData for a
    particular time on demand.

    A note about AutoDerivative in the underlying Orbit. For the orbit
    creation (orbit_data_create) we use a constant time only. This is
    really just what we mean by doing a time interpolation. We select
    points at a specific, exact time - t0, t1, t2, etc. No derivatives,
    the times are exact constants. However, when we interpolate to time t
    using orbit data at t0 and t1, that is where the derivative enters in.
    So we propagate time gradients through the linear interpolation in
    orbit_data. Note that this is the time behavior of
    OrbitQuaterntionList, even if it isn’t the derivative of the
    underlying orbit. This is one differences in using a
    OrbitQuaternionList vs. some other Orbit - the time behavior is by
    design linear.

    So you should calculate your quaternions in orbit_data_create using
    AutoDerivative (if the orbit supports it and has parameters), but hold
    time constant (either don’t include as one of the gradient variables,
    or give it a gradient of zero). The OrbitQuaternionList will then
    given the correct gradients of how it behaves, even if this isn’t the
    same gradient you would have gotten from the underlying Orbit.

    C++ includes: orbit_quaternion_list.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, Data):
        """

        GeoCal::OrbitQuaternionList::OrbitQuaternionList(iterator ibeg, iterator iend)
        Constructor that takes a list of QuaternionOrbitData values.

        Note that the data doesn't need to be sorted, we handle sorting as we
        ingest the data.

        QuaternionOrbitData pointer can be null if we want to do a lazy
        evaluation of the data (see description of class for details). 
        """
        _orbit_quaternion_list.OrbitQuaternionList_swiginit(self, _orbit_quaternion_list.new_OrbitQuaternionList(Data))

    def orbit_data(self, *args):
        """

        boost::shared_ptr< OrbitData > OrbitQuaternionList::orbit_data(const TimeWithDerivative &T) const

        """
        return _orbit_quaternion_list.OrbitQuaternionList_orbit_data(self, *args)


    def _v_quaternion_orbit_data(self):
        """

        std::vector< boost::shared_ptr< QuaternionOrbitData > > OrbitQuaternionList::quaternion_orbit_data() const
        Return the list of QuaternionOrbitData. 
        """
        return _orbit_quaternion_list.OrbitQuaternionList__v_quaternion_orbit_data(self)


    @property
    def quaternion_orbit_data(self):
        return self._v_quaternion_orbit_data()


    def _v_quaternion_orbit_data_time(self):
        """

        std::vector< boost::shared_ptr< Time > > OrbitQuaternionList::quaternion_orbit_data_time() const
        Return the Times of QuaternionOrbitData. 
        """
        return _orbit_quaternion_list.OrbitQuaternionList__v_quaternion_orbit_data_time(self)


    @property
    def quaternion_orbit_data_time(self):
        return self._v_quaternion_orbit_data_time()


    def quaternion_orbit_data_i(self, I):
        """

        boost::shared_ptr<QuaternionOrbitData> GeoCal::OrbitQuaternionList::quaternion_orbit_data_i(int I) const
        Python will sometime crash with quaternion_orbit_data if it is larger,
        probably just a SWIG sort of bug.

        But for use with python, supply a function that returns the data
        directly for an index. This is redundant for C++, just call
        quaternion_orbit_data and index the results. But this is useful for
        python. 
        """
        return _orbit_quaternion_list.OrbitQuaternionList_quaternion_orbit_data_i(self, I)


    def _v_quaternion_orbit_data_size(self):
        """

        int GeoCal::OrbitQuaternionList::quaternion_orbit_data_size() const

        """
        return _orbit_quaternion_list.OrbitQuaternionList__v_quaternion_orbit_data_size(self)


    @property
    def quaternion_orbit_data_size(self):
        return self._v_quaternion_orbit_data_size()


    def _v_set_min_time(self, T):
        """

        void GeoCal::OrbitQuaternionList::set_min_time(const Time &T)
        It can be useful in some cases to modify the min_time and max_time.

        For example, we don't usually allow extrapolation outside of the range
        of orbit data, but in some case this might be desirable (e.g., orbit
        data doesn't fully cover our image data, but will if we extrapolate a
        short ways). 
        """
        return _orbit_quaternion_list.OrbitQuaternionList__v_set_min_time(self, T)


    def _v_set_max_time(self, T):
        """

        void GeoCal::OrbitQuaternionList::set_max_time(const Time &T)
        It can be useful in some cases to modify the min_time and max_time.

        For example, we don't usually allow extrapolation outside of the range
        of orbit data, but in some case this might be desirable (e.g., orbit
        data doesn't fully cover our image data, but will if we extrapolate a
        short ways). 
        """
        return _orbit_quaternion_list.OrbitQuaternionList__v_set_max_time(self, T)


    @property
    def min_time(self):
      return self._v_min_time()

    @min_time.setter
    def min_time(self, value):
      self._v_set_min_time(value)

    @property
    def max_time(self):
      return self._v_max_time()

    @max_time.setter
    def max_time(self, value):
      self._v_set_max_time(value)

    def quaternion_orbit_data_gen(self):
      '''Generator version of quaternion_orbit_data'''
      for i in range(self.quaternion_orbit_data_size):
          yield self.quaternion_orbit_data_i(i)

    __swig_destroy__ = _orbit_quaternion_list.delete_OrbitQuaternionList
OrbitQuaternionList.orbit_data = new_instancemethod(_orbit_quaternion_list.OrbitQuaternionList_orbit_data, None, OrbitQuaternionList)
OrbitQuaternionList._v_quaternion_orbit_data = new_instancemethod(_orbit_quaternion_list.OrbitQuaternionList__v_quaternion_orbit_data, None, OrbitQuaternionList)
OrbitQuaternionList._v_quaternion_orbit_data_time = new_instancemethod(_orbit_quaternion_list.OrbitQuaternionList__v_quaternion_orbit_data_time, None, OrbitQuaternionList)
OrbitQuaternionList.quaternion_orbit_data_i = new_instancemethod(_orbit_quaternion_list.OrbitQuaternionList_quaternion_orbit_data_i, None, OrbitQuaternionList)
OrbitQuaternionList._v_quaternion_orbit_data_size = new_instancemethod(_orbit_quaternion_list.OrbitQuaternionList__v_quaternion_orbit_data_size, None, OrbitQuaternionList)
OrbitQuaternionList._v_set_min_time = new_instancemethod(_orbit_quaternion_list.OrbitQuaternionList__v_set_min_time, None, OrbitQuaternionList)
OrbitQuaternionList._v_set_max_time = new_instancemethod(_orbit_quaternion_list.OrbitQuaternionList__v_set_max_time, None, OrbitQuaternionList)
OrbitQuaternionList_swigregister = _orbit_quaternion_list.OrbitQuaternionList_swigregister
OrbitQuaternionList_swigregister(OrbitQuaternionList)

class OrbitListCache(OrbitQuaternionList):
    """

    Some orbits are expensive to calculate (e.g., SpicePlanetOrbit).

    Often it is perfectly fine to only calculate this at some fixed set of
    times and then interpolate, which can be significantly faster. This
    class supports this.

    C++ includes: orbit_quaternion_list.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, Orbit_underlying, Tt, Sample=0.0):
        """

        GeoCal::OrbitListCache::OrbitListCache(const boost::shared_ptr< Orbit > &Orbit_underlying, const
        boost::shared_ptr< TimeTable > &Tt, double Sample=0.0)
        Create a OrbitListCache that calculates the orbit at each time found
        for image coordinate line from Tt.min_line() to tt.max_line() for the
        given sample.

        We cache the orbit data. If the underlying orbit changes, we throw
        away the cached values. 
        """
        _orbit_quaternion_list.OrbitListCache_swiginit(self, _orbit_quaternion_list.new_OrbitListCache(Orbit_underlying, Tt, Sample))

    def _v_orbit_underlying(self):
        """

        const boost::shared_ptr<Orbit>& GeoCal::OrbitListCache::orbit_underlying() const
        Underlying orbit. 
        """
        return _orbit_quaternion_list.OrbitListCache__v_orbit_underlying(self)


    @property
    def orbit_underlying(self):
        return self._v_orbit_underlying()


    def _v_time_table(self):
        """

        const boost::shared_ptr<TimeTable>& GeoCal::OrbitListCache::time_table() const
        Time table we sample orbit at. 
        """
        return _orbit_quaternion_list.OrbitListCache__v_time_table(self)


    @property
    def time_table(self):
        return self._v_time_table()


    def _v_sample(self):
        """

        double GeoCal::OrbitListCache::sample() const
        Sample we use with time table. 
        """
        return _orbit_quaternion_list.OrbitListCache__v_sample(self)


    @property
    def sample(self):
        return self._v_sample()


    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)

    __swig_destroy__ = _orbit_quaternion_list.delete_OrbitListCache
OrbitListCache._v_orbit_underlying = new_instancemethod(_orbit_quaternion_list.OrbitListCache__v_orbit_underlying, None, OrbitListCache)
OrbitListCache._v_time_table = new_instancemethod(_orbit_quaternion_list.OrbitListCache__v_time_table, None, OrbitListCache)
OrbitListCache._v_sample = new_instancemethod(_orbit_quaternion_list.OrbitListCache__v_sample, None, OrbitListCache)
OrbitListCache_swigregister = _orbit_quaternion_list.OrbitListCache_swigregister
OrbitListCache_swigregister(OrbitListCache)


__all__ = ["OrbitQuaternionList","OrbitListCache"]



