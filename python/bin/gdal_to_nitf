#! /usr/bin/env python
#
# This copies a GDAL file to a new NITF file. This is very similar to
# gdal_translate already found in GDAL, but this adds handling of TREs
# in NITF for things like RPC and igeolo information.

try:
    from afids import *
except ImportError:
    from geocal import *
from tempfile import NamedTemporaryFile
import subprocess
import os

version="%prog May 9, 2014"
usage="""Usage: 
  gdal_to_nitf [options] <input_file> <output_nitf>
  gdal_to_nitf -h | --help
  gdal_to_nitf -v | --version

This copies a GDAL file to a new NITF file. This is very similar to
gdal_translate already found in GDAL, but this adds handling of TREs
in NITF for things like RPC and igeolo information.

The input file can be any file supported by GDAL, including VICAR.

Note that this program should be a replacement for the old VICAR
proc vicar2ntf

Options:
  -h --help         
       Print this message

  -k --keep-aux
       By default, we remove the .aux.xml file gdal_translate creates to
       store things that don't fit in the NITF file. Use this option to
       keep that file.

  --unsigned-int16
       Force output to unsigned int16.

  -q --quiet
       Don't print status message as we copy the data.

  -v --version      
       Print program version

"""
args = docopt_simple(usage, version=version)

# Create a "virtual raster image". This is a text file that allows us to
# set various metadata fields without changing the original file. GDAL then
# treats this raster image we can later copy.

with NamedTemporaryFile() as tmp:
    cmd = ["gdal_translate", "-of", "VRT", "-q"]
    if(args.unsigned_int16):
        cmd.extend(["-ot", "UInt16"])
    cmd.extend([args.input_file, tmp.name])
    subprocess.check_call(cmd)
    fin = GdalMultiBand(args.input_file)
    fvrt = GdalRasterImage(tmp.name)
    creation_option = []
    if(fin.raster_image(0).has_rpc):
        if(fin.raster_image(0).rpc.rpc_type == Rpc.RPC_A):
            tre = TreRPC00A()
            tre.rpc = fin.raster_image(0).rpc
            fvrt.rpc00a = tre
        else:
            tre = TreRPC00B()
            tre.rpc = fin.raster_image(0).rpc
            fvrt.rpc00b = tre

    # NITF creates its IGEOLO data structure from a map projection. If
    # the input file doesn't already have map info, create an approximate
    # one if we can from the NITF corner metadata in the file
    if(not fvrt.has_map_info):
        mi = fvrt.map_info_from_nitf_corner
        if(mi is not None):
            fvrt.set_map_info(mi)

    # Quiet a warning message in case we have the wrong header version 
    # information (e.g., this was copied from an older NITF file). As
    # of GDAL 1.9, it supports writing 2.10 only
    if("NITF_FHDR" in fvrt):
        fvrt["NITF_FHDR"] = "NITF02.10"

    # Copy over use00a information, if found
    tre_use00a(fin, fvrt, creation_option)

    # Function is only optionally available, depending on options
    # used at build time of AFIDS. If this isn't found then just
    # continue without complaint
    try:
        tre_afid_a(fin, fvrt, creation_option)
    except NameError as exc:
        pass
    fvrt.close()
    cmd = ["gdal_translate", "-of", "NITF"]
    if(args.quiet):
        cmd.append("-q")
    cmd.extend(creation_option)
    cmd.append(tmp.name)
    cmd.append(args.output_nitf)
    subprocess.check_call(cmd)
    if(not args.keep_aux):
        try:
            os.remove(args.output_nitf + ".aux.xml")
        except OSError:
            # Ok if file doesn't exist
            pass
