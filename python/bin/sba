#! /usr/bin/env python
#
# This runs a simultatenous bundle adjustment to adjust the parameters of
# a image ground connnection collection to more closely fit a given set o
# tiepoints.

from afids import *

version = "February 4, 2013"
usage='''Usage: 
  sba [options] <igc_in> <tpcol_in> <igc_out> <tpcol_out>
  sba -h | --help
  sba -v | --version

This runs a simultatenous bundle adjustment to adjust the parameters of
a image ground connnection collection to more closely fit a given set of
tiepoints.

The input igc collection and tie point array, and the final output are
given as sqlite shelve objects. The sqlite shelve objects are in
"file:key" format, e.g., "my_data.db:tp".

We output an updated igc collection, and a tie point array with the
ground location of the tie points updated to the final location used
in the SBA.

This requires a DEM to use. Most commonly the same DEM is used for all the
image ground connections in the collection, and this is the same one we
want to use for the SBA. In this case, you don't need to specify the DEM, we
just grab the DEM from the first image ground connection. You can optionally
specify a different DEM to use.

Options:
  -h --help         
       Print this message

  --dem=shelve
       DEM to use, specified as file:key. If not specified, we use the 
       DEM from the first IGC.

  --dem-sigma=v
       Weighting to give surface constraint from DEM [default: 10.0]

  --gcp-sigma=v
       Weighting to give GCP constraint [default: 10.0]

  -q --quiet
       Suppress print status messages to stdout.

  --tp-epsilon=v
       Epsilon to use during the calculation of the tie point Jacobian.
       [default: 1.0]

  -v --version      
       Print program version
'''

args = docopt_simple(usage, version=version)

igc = read_shelve(args.igc_in)
tpcol = read_shelve(args.tpcol_in)
if(args.dem):
    dem = read_shelve(args.dem)
else:
    dem = igc.dem(0)

sba = SimultaneousBundleAdjustment(igc, tpcol, dem, dem_sigma=args.dem_sigma,
                                   gcp_sigma=args.gcp_sigma,
                                   tp_epsilon=args.tp_epsilon)
v = sba.sba_eq(sba.parameter)
chisq = np.inner(v, v) / (len(v) - len(sba.parameter))
verbose = not args.quiet

if(verbose):
    print "Initial Chisq: ", chisq
parm = lm_optimize(sba.sba_eq, sba.parameter, sba.sba_jacobian, 
                   diagnostic = verbose)
sba.parameter = parm
v = sba.sba_eq(sba.parameter)
chisq = np.inner(v, v) / (len(v) - len(sba.parameter))
if(verbose):
    print "Final Chisq: ", chisq
write_shelve(args.igc_out, sba.igc_coll)
tpcol = sba.tpcol
for i in range(len(tpcol)):
    tpcol[i].ground_location = sba.ground_location(i)
write_shelve(args.tpcol_out, tpcol)


