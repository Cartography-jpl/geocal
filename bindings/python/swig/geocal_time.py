# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _geocal_time.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_geocal_time', [dirname(__file__)])
        except ImportError:
            import _geocal_time
            return _geocal_time
        if fp is not None:
            try:
                _mod = imp.load_module('_geocal_time', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _geocal_time = swig_import_helper()
    del swig_import_helper
else:
    import _geocal_time
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _geocal_time.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_geocal_time.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_geocal_time.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_geocal_time.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_geocal_time.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_geocal_time.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_geocal_time.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_geocal_time.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_geocal_time.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_geocal_time.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_geocal_time.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_geocal_time.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_geocal_time.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_geocal_time.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_geocal_time.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_geocal_time.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_geocal_time.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _geocal_time.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_geocal_time.SHARED_PTR_DISOWN_swigconstant(_geocal_time)
SHARED_PTR_DISOWN = _geocal_time.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.generic_object

import datetime
import time

def _new_time(pgs):
  return Time.time_pgs(pgs)

def _new_time_with_derivative(pgs):
  return TimeWithDerivative.time_pgs(pgs)

class Time(geocal_swig.generic_object.GenericObject):
    """

    C++ includes: geocal_time.h

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def time_et(et):
        """

        Time Time::time_et(double et)
        Return time from given SPICE ET time. 
        """
        return _geocal_time.Time_time_et(et)

    time_et = staticmethod(time_et)

    def time_pgs(pgs):
        """

        static Time GeoCal::Time::time_pgs(double pgs)
        Return time from given PGS toolkit time (epoch of 1993-01-01). 
        """
        return _geocal_time.Time_time_pgs(pgs)

    time_pgs = staticmethod(time_pgs)

    def time_j2000(j2000):
        """

        static Time GeoCal::Time::time_j2000(double j2000)
        Return time from given J2000 time (epoch of 2000-01-01 12:00:00 TT).

        Note that TT is different than UTC noon by about 64.184 seconds 
        """
        return _geocal_time.Time_time_j2000(j2000)

    time_j2000 = staticmethod(time_j2000)

    def time_gps(*args):
        """

        static Time GeoCal::Time::time_gps(int week, double week_offset)
        Often GPS time is reported as week number and seconds offset in that
        week.

        This alternative version of time_gps takes weeks and week offset. Note
        that older GPS units have the week number roll over at 1024, this
        happen in 1999 and the next roll over will be If you have data like
        that you need to just "know" to add 1024 or 2 * 1024. Newer GPS
        units might not have this problem. 
        """
        return _geocal_time.Time_time_gps(*args)

    time_gps = staticmethod(time_gps)

    def time_unix(unix_time):
        """

        static Time GeoCal::Time::time_unix(double unix_time)
        Return time from given Unix time (epoch of 1970-01-01). 
        """
        return _geocal_time.Time_time_unix(unix_time)

    time_unix = staticmethod(time_unix)

    def time_acs(acs):
        """

        Time Time::time_acs(double acs_time)
        Return time from ACS time.

        ACS time is an odd time system. It is measured in UTC seconds from a
        particular epoch. The choice of UTC seconds means that this cannot
        correctly handle times that occur during a leapsecond, by definition
        the UTC time before and after a leapsecond is the same. The epoch is
        noon January, 1 2000 in UTC. Note that this is 64.184 seconds
        different from terrestrial time J2000. 
        """
        return _geocal_time.Time_time_acs(acs)

    time_acs = staticmethod(time_acs)

    def time_sclk(Sclk, Spacecraft_name):
        """

        Time Time::time_sclk(const std::string &Sclk, const std::string &Spacecraft_name)
        Return time from a given SCLK (spacecraft clock string). 
        """
        return _geocal_time.Time_time_sclk(Sclk, Spacecraft_name)

    time_sclk = staticmethod(time_sclk)

    def sclk(self, Spacecraft_name):
        """

        std::string Time::sclk(const std::string &Spacecraft_name)
        Return SCLK (spacecraft clock string) for the given time. 
        """
        return _geocal_time.Time_sclk(self, Spacecraft_name)


    def _v_acs(self):
        """

        double Time::acs() const
        Give ACS time. 
        """
        return _geocal_time.Time__v_acs(self)


    @property
    def acs(self):
        return self._v_acs()


    def _v_pgs(self):
        """

        double  GeoCal::TimeBase< double  >::pgs() const
        Give time in PGS toolkit time (epoch 1993-01-01). 
        """
        return _geocal_time.Time__v_pgs(self)


    @property
    def pgs(self):
        return self._v_pgs()


    def _v_gps(self):
        """

        double  GeoCal::TimeBase< double  >::gps() const
        Give time in GPS. 
        """
        return _geocal_time.Time__v_gps(self)


    @property
    def gps(self):
        return self._v_gps()


    def _v_gps_week(self):
        """

        int GeoCal::Time::gps_week() const
        Give GPS week number.

        Note that older GPS units roll over at 1024 (happened in 1999, will
        again in 2019). The number returned here does not roll over, so it can
        be > 1024. If you need to match an older GPS unit you may need to mod
        1024 the value returned. 
        """
        return _geocal_time.Time__v_gps_week(self)


    @property
    def gps_week(self):
        return self._v_gps_week()


    def _v_gps_week_offset(self):
        """

        double GeoCal::Time::gps_week_offset() const
        Gives GPS offset to the gps_week. 
        """
        return _geocal_time.Time__v_gps_week_offset(self)


    @property
    def gps_week_offset(self):
        return self._v_gps_week_offset()


    def _v_j2000(self):
        """

        double  GeoCal::TimeBase< double  >::j2000() const
        Give time in j2000. 
        """
        return _geocal_time.Time__v_j2000(self)


    @property
    def j2000(self):
        return self._v_j2000()


    def _v_et(self):
        """

        double Time::et() const
        Give time as SPICE ET time. 
        """
        return _geocal_time.Time__v_et(self)


    @property
    def et(self):
        return self._v_et()


    def parse_time(Time_string):
        """

        static Time GeoCal::Time::parse_time(const std::string &Time_string)

        """
        return _geocal_time.Time_parse_time(Time_string)

    parse_time = staticmethod(parse_time)

    def unix_time(self):
        """

        std::time_t GeoCal::Time::unix_time() const
        Give time in unix time.

        Note that this is only accurate to the nearest second. 
        """
        return _geocal_time.Time_unix_time(self)


    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)


    def __init__(self):
        _geocal_time.Time_swiginit(self, _geocal_time.new_Time())
    __swig_destroy__ = _geocal_time.delete_Time
Time.sclk = new_instancemethod(_geocal_time.Time_sclk, None, Time)
Time._v_acs = new_instancemethod(_geocal_time.Time__v_acs, None, Time)
Time._v_pgs = new_instancemethod(_geocal_time.Time__v_pgs, None, Time)
Time._v_gps = new_instancemethod(_geocal_time.Time__v_gps, None, Time)
Time._v_gps_week = new_instancemethod(_geocal_time.Time__v_gps_week, None, Time)
Time._v_gps_week_offset = new_instancemethod(_geocal_time.Time__v_gps_week_offset, None, Time)
Time._v_j2000 = new_instancemethod(_geocal_time.Time__v_j2000, None, Time)
Time._v_et = new_instancemethod(_geocal_time.Time__v_et, None, Time)
Time.__str__ = new_instancemethod(_geocal_time.Time___str__, None, Time)
Time.__lt__ = new_instancemethod(_geocal_time.Time___lt__, None, Time)
Time.__le__ = new_instancemethod(_geocal_time.Time___le__, None, Time)
Time.__eq__ = new_instancemethod(_geocal_time.Time___eq__, None, Time)
Time.__ne__ = new_instancemethod(_geocal_time.Time___ne__, None, Time)
Time.__gt__ = new_instancemethod(_geocal_time.Time___gt__, None, Time)
Time.__ge__ = new_instancemethod(_geocal_time.Time___ge__, None, Time)
Time.__add__ = new_instancemethod(_geocal_time.Time___add__, None, Time)
Time.__radd__ = new_instancemethod(_geocal_time.Time___radd__, None, Time)
Time.__sub__ = new_instancemethod(_geocal_time.Time___sub__, None, Time)
Time.unix_time = new_instancemethod(_geocal_time.Time_unix_time, None, Time)
Time_swigregister = _geocal_time.Time_swigregister
Time_swigregister(Time)

def Time_time_et(et):
    """

    Time Time::time_et(double et)
    Return time from given SPICE ET time. 
    """
    return _geocal_time.Time_time_et(et)

def Time_time_pgs(pgs):
    """

    static Time GeoCal::Time::time_pgs(double pgs)
    Return time from given PGS toolkit time (epoch of 1993-01-01). 
    """
    return _geocal_time.Time_time_pgs(pgs)

def Time_time_j2000(j2000):
    """

    static Time GeoCal::Time::time_j2000(double j2000)
    Return time from given J2000 time (epoch of 2000-01-01 12:00:00 TT).

    Note that TT is different than UTC noon by about 64.184 seconds 
    """
    return _geocal_time.Time_time_j2000(j2000)

def Time_time_gps(*args):
    """

    static Time GeoCal::Time::time_gps(int week, double week_offset)
    Often GPS time is reported as week number and seconds offset in that
    week.

    This alternative version of time_gps takes weeks and week offset. Note
    that older GPS units have the week number roll over at 1024, this
    happen in 1999 and the next roll over will be If you have data like
    that you need to just "know" to add 1024 or 2 * 1024. Newer GPS
    units might not have this problem. 
    """
    return _geocal_time.Time_time_gps(*args)

def Time_time_unix(unix_time):
    """

    static Time GeoCal::Time::time_unix(double unix_time)
    Return time from given Unix time (epoch of 1970-01-01). 
    """
    return _geocal_time.Time_time_unix(unix_time)

def Time_time_acs(acs):
    """

    Time Time::time_acs(double acs_time)
    Return time from ACS time.

    ACS time is an odd time system. It is measured in UTC seconds from a
    particular epoch. The choice of UTC seconds means that this cannot
    correctly handle times that occur during a leapsecond, by definition
    the UTC time before and after a leapsecond is the same. The epoch is
    noon January, 1 2000 in UTC. Note that this is 64.184 seconds
    different from terrestrial time J2000. 
    """
    return _geocal_time.Time_time_acs(acs)

def Time_time_sclk(Sclk, Spacecraft_name):
    """

    Time Time::time_sclk(const std::string &Sclk, const std::string &Spacecraft_name)
    Return time from a given SCLK (spacecraft clock string). 
    """
    return _geocal_time.Time_time_sclk(Sclk, Spacecraft_name)

def Time_parse_time(Time_string):
    """

    static Time GeoCal::Time::parse_time(const std::string &Time_string)

    """
    return _geocal_time.Time_parse_time(Time_string)
cvar = _geocal_time.cvar
Time.min_valid_time = _geocal_time.cvar.Time_min_valid_time
Time.max_valid_time = _geocal_time.cvar.Time_max_valid_time

class TimeWithDerivative(geocal_swig.generic_object.GenericObject):
    """

    C++ includes: geocal_time.h

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        GeoCal::TimeWithDerivative::TimeWithDerivative()

        """
        _geocal_time.TimeWithDerivative_swiginit(self, _geocal_time.new_TimeWithDerivative(*args))

    def time_pgs(pgs):
        """

        static TimeWithDerivative GeoCal::TimeWithDerivative::time_pgs(const AutoDerivative< double > pgs)
        Return time from given PGS toolkit time (epoch of 1993-01-01). 
        """
        return _geocal_time.TimeWithDerivative_time_pgs(pgs)

    time_pgs = staticmethod(time_pgs)

    def time_j2000(j2000):
        """

        static TimeWithDerivative GeoCal::TimeWithDerivative::time_j2000(const AutoDerivative< double > j2000)
        Return time from given J2000 time (epoch of 2000-01-01 12:00:00 TT).

        Note that TT is different than UTC noon by about 64.184 seconds 
        """
        return _geocal_time.TimeWithDerivative_time_j2000(j2000)

    time_j2000 = staticmethod(time_j2000)

    def time_gps(*args):
        """

        static TimeWithDerivative GeoCal::TimeWithDerivative::time_gps(int week, const AutoDerivative< double > &week_offset)
        Often GPS time is reported as week number and seconds offset in that
        week.

        This alternative version of time_gps takes weeks and week offset. Note
        that older GPS units have the week number roll over at 1024, this
        happen in 1999 and the next roll over will be If you have data like
        that you need to just "know" to add 1024 or 2 * 1024. Newer GPS
        units might not have this problem. 
        """
        return _geocal_time.TimeWithDerivative_time_gps(*args)

    time_gps = staticmethod(time_gps)

    def _v_pgs(self):
        """

        AutoDerivative< double >  GeoCal::TimeBase< AutoDerivative< double >  >::pgs() const
        Give time in PGS toolkit time (epoch 1993-01-01). 
        """
        return _geocal_time.TimeWithDerivative__v_pgs(self)


    @property
    def pgs(self):
        return self._v_pgs()


    def _v_gps(self):
        """

        AutoDerivative< double >  GeoCal::TimeBase< AutoDerivative< double >  >::gps() const
        Give time in GPS. 
        """
        return _geocal_time.TimeWithDerivative__v_gps(self)


    @property
    def gps(self):
        return self._v_gps()


    def _v_gps_week(self):
        """

        int GeoCal::TimeWithDerivative::gps_week() const
        Give GPS week number.

        Note that older GPS units roll over at 1024 (happened in 1999, will
        again in 2019). The number returned here does not roll over, so it can
        be > 1024. If you need to match an older GPS unit you may need to mod
        1024 the value returned. 
        """
        return _geocal_time.TimeWithDerivative__v_gps_week(self)


    @property
    def gps_week(self):
        return self._v_gps_week()


    def _v_gps_week_offset(self):
        """

        AutoDerivative<double> GeoCal::TimeWithDerivative::gps_week_offset() const
        Gives GPS offset to the gps_week. 
        """
        return _geocal_time.TimeWithDerivative__v_gps_week_offset(self)


    @property
    def gps_week_offset(self):
        return self._v_gps_week_offset()


    def _v_j2000(self):
        """

        AutoDerivative< double >  GeoCal::TimeBase< AutoDerivative< double >  >::j2000() const
        Give time in j2000. 
        """
        return _geocal_time.TimeWithDerivative__v_j2000(self)


    @property
    def j2000(self):
        return self._v_j2000()


    def _v_value(self):
        """

        Time GeoCal::TimeWithDerivative::value() const
        Strip off gradient to just give a time. 
        """
        return _geocal_time.TimeWithDerivative__v_value(self)


    @property
    def value(self):
        return self._v_value()


    def _v_gradient(self):
        """

        blitz::Array<double, 1> GeoCal::TimeWithDerivative::gradient() const
        Return gradient. 
        """
        return _geocal_time.TimeWithDerivative__v_gradient(self)


    @property
    def gradient(self):
        return self._v_gradient()


    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _geocal_time.delete_TimeWithDerivative
TimeWithDerivative._v_pgs = new_instancemethod(_geocal_time.TimeWithDerivative__v_pgs, None, TimeWithDerivative)
TimeWithDerivative._v_gps = new_instancemethod(_geocal_time.TimeWithDerivative__v_gps, None, TimeWithDerivative)
TimeWithDerivative._v_gps_week = new_instancemethod(_geocal_time.TimeWithDerivative__v_gps_week, None, TimeWithDerivative)
TimeWithDerivative._v_gps_week_offset = new_instancemethod(_geocal_time.TimeWithDerivative__v_gps_week_offset, None, TimeWithDerivative)
TimeWithDerivative._v_j2000 = new_instancemethod(_geocal_time.TimeWithDerivative__v_j2000, None, TimeWithDerivative)
TimeWithDerivative._v_value = new_instancemethod(_geocal_time.TimeWithDerivative__v_value, None, TimeWithDerivative)
TimeWithDerivative._v_gradient = new_instancemethod(_geocal_time.TimeWithDerivative__v_gradient, None, TimeWithDerivative)
TimeWithDerivative.__str__ = new_instancemethod(_geocal_time.TimeWithDerivative___str__, None, TimeWithDerivative)
TimeWithDerivative.__cmp__ = new_instancemethod(_geocal_time.TimeWithDerivative___cmp__, None, TimeWithDerivative)
TimeWithDerivative.__add__ = new_instancemethod(_geocal_time.TimeWithDerivative___add__, None, TimeWithDerivative)
TimeWithDerivative.__radd__ = new_instancemethod(_geocal_time.TimeWithDerivative___radd__, None, TimeWithDerivative)
TimeWithDerivative.__sub__ = new_instancemethod(_geocal_time.TimeWithDerivative___sub__, None, TimeWithDerivative)
TimeWithDerivative_swigregister = _geocal_time.TimeWithDerivative_swigregister
TimeWithDerivative_swigregister(TimeWithDerivative)

def TimeWithDerivative_time_pgs(pgs):
    """

    static TimeWithDerivative GeoCal::TimeWithDerivative::time_pgs(const AutoDerivative< double > pgs)
    Return time from given PGS toolkit time (epoch of 1993-01-01). 
    """
    return _geocal_time.TimeWithDerivative_time_pgs(pgs)

def TimeWithDerivative_time_j2000(j2000):
    """

    static TimeWithDerivative GeoCal::TimeWithDerivative::time_j2000(const AutoDerivative< double > j2000)
    Return time from given J2000 time (epoch of 2000-01-01 12:00:00 TT).

    Note that TT is different than UTC noon by about 64.184 seconds 
    """
    return _geocal_time.TimeWithDerivative_time_j2000(j2000)

def TimeWithDerivative_time_gps(*args):
    """

    static TimeWithDerivative GeoCal::TimeWithDerivative::time_gps(int week, const AutoDerivative< double > &week_offset)
    Often GPS time is reported as week number and seconds offset in that
    week.

    This alternative version of time_gps takes weeks and week offset. Note
    that older GPS units have the week number roll over at 1024, this
    happen in 1999 and the next roll over will be If you have data like
    that you need to just "know" to add 1024 or 2 * 1024. Newer GPS
    units might not have this problem. 
    """
    return _geocal_time.TimeWithDerivative_time_gps(*args)



