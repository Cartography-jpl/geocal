# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _iterative_morphological_dilation.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_iterative_morphological_dilation')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_iterative_morphological_dilation')
    _iterative_morphological_dilation = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_iterative_morphological_dilation', [dirname(__file__)])
        except ImportError:
            import _iterative_morphological_dilation
            return _iterative_morphological_dilation
        try:
            _mod = imp.load_module('_iterative_morphological_dilation', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _iterative_morphological_dilation = swig_import_helper()
    del swig_import_helper
else:
    import _iterative_morphological_dilation
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iterative_morphological_dilation.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_iterative_morphological_dilation.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _iterative_morphological_dilation.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _iterative_morphological_dilation.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.generic_object
class IterativeMorphologicalDilation(geocal_swig.generic_object.GenericObject):
    """

    This is a simple algorithm to fill in missing pixels in an image.

    This looks at all the pixels that are on the "edge" of the image -
    so pixels that aren't filled in but have at least one neighbor. We
    then fill in those pixels, and repeat the process iteratively. This is
    sometimes referred to as the "grass fire" algorithm.

    C++ includes: iterative_morphological_dilation.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    C_ORDER = _iterative_morphological_dilation.IterativeMorphologicalDilation_C_ORDER

    def __init__(self, *args):
        """

        IterativeMorphologicalDilation::IterativeMorphologicalDilation(const blitz::Array< double, 2 > &Image, const blitz::Array< bool, 2 >
        &Mask, const blitz::Array< double, 2 > &Kernel, FrontierFillOrder
        Frontier_fill_order=C_ORDER)
        Constructor.

        The Mask is "true" where we don't have Image data and wish to fill
        in data (i.e., this is the same sense as ImageMask).

        The Kernel to use to fill in the missing data values should have an
        odd extent.

        Right now, this just works with blitz arrays. We could extend this to
        work with RasterImage and ImageMask. But this is often called from
        python, which interacts better with blitz arrays (which map to numpy
        arrays in python). 
        """
        _iterative_morphological_dilation.IterativeMorphologicalDilation_swiginit(self, _iterative_morphological_dilation.new_IterativeMorphologicalDilation(*args))

    def _v_filled_image(self):
        """

        const blitz::Array<double, 2>& GeoCal::IterativeMorphologicalDilation::filled_image() const
        Image that has been filled in for missing data. 
        """
        return _iterative_morphological_dilation.IterativeMorphologicalDilation__v_filled_image(self)


    @property
    def filled_image(self):
        return self._v_filled_image()


    def _v_filled_mask(self):
        """

        const blitz::Array<bool, 2>& GeoCal::IterativeMorphologicalDilation::filled_mask() const
        Mask for filled_image. 
        """
        return _iterative_morphological_dilation.IterativeMorphologicalDilation__v_filled_mask(self)


    @property
    def filled_mask(self):
        return self._v_filled_mask()


    def _v_kernel(self):
        """

        const blitz::Array<double, 2>& GeoCal::IterativeMorphologicalDilation::kernel() const
        Kernel used for neighborhood averaging to fill in missing data. 
        """
        return _iterative_morphological_dilation.IterativeMorphologicalDilation__v_kernel(self)


    @property
    def kernel(self):
        return self._v_kernel()


    def _v_frontier_fill_order(self):
        """

        FrontierFillOrder GeoCal::IterativeMorphologicalDilation::frontier_fill_order() const
        Order that we fill the frontier pixels in an iteration. 
        """
        return _iterative_morphological_dilation.IterativeMorphologicalDilation__v_frontier_fill_order(self)


    @property
    def frontier_fill_order(self):
        return self._v_frontier_fill_order()


    def _v_iteration_count(self):
        """

        int GeoCal::IterativeMorphologicalDilation::iteration_count() const
        The iteration count for filling in the data. 
        """
        return _iterative_morphological_dilation.IterativeMorphologicalDilation__v_iteration_count(self)


    @property
    def iteration_count(self):
        return self._v_iteration_count()


    def fill_missing_data(self):
        """

        void IterativeMorphologicalDilation::fill_missing_data()
        Iteratively fill in missing data until everything is filled.

        This just runs fill_iteration() until there is nothing left. 
        """
        return _iterative_morphological_dilation.IterativeMorphologicalDilation_fill_missing_data(self)


    def predicted_value(self, i, j):
        """

        double IterativeMorphologicalDilation::predicted_value(int i, int j) const
        Predicted value for the given pixel.

        We only include data that as filled_mask_ false, and we normalize by
        the portion of the kernel included. 
        """
        return _iterative_morphological_dilation.IterativeMorphologicalDilation_predicted_value(self, i, j)


    def frontier_pixel_neighbor_count(self):
        """

        blitz::Array< unsigned short int, 2 > IterativeMorphologicalDilation::frontier_pixel_neighbor_count() const
        Dilate the mask with a simple 3x3 kernel of all 1's.

        Subtract the original mask - so this returns nonzero for all the new
        "frontier" pixels. Because it is useful, fill the nonzero values
        with a count of neighbors in the original mask (this can be useful to
        fill in points with the most neighbors first in an iteration). So this
        returns all masked pixels that have at least one immediate neighbor.

        """
        return _iterative_morphological_dilation.IterativeMorphologicalDilation_frontier_pixel_neighbor_count(self)


    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _iterative_morphological_dilation.delete_IterativeMorphologicalDilation
IterativeMorphologicalDilation.__str__ = new_instancemethod(_iterative_morphological_dilation.IterativeMorphologicalDilation___str__, None, IterativeMorphologicalDilation)
IterativeMorphologicalDilation._v_filled_image = new_instancemethod(_iterative_morphological_dilation.IterativeMorphologicalDilation__v_filled_image, None, IterativeMorphologicalDilation)
IterativeMorphologicalDilation._v_filled_mask = new_instancemethod(_iterative_morphological_dilation.IterativeMorphologicalDilation__v_filled_mask, None, IterativeMorphologicalDilation)
IterativeMorphologicalDilation._v_kernel = new_instancemethod(_iterative_morphological_dilation.IterativeMorphologicalDilation__v_kernel, None, IterativeMorphologicalDilation)
IterativeMorphologicalDilation._v_frontier_fill_order = new_instancemethod(_iterative_morphological_dilation.IterativeMorphologicalDilation__v_frontier_fill_order, None, IterativeMorphologicalDilation)
IterativeMorphologicalDilation._v_iteration_count = new_instancemethod(_iterative_morphological_dilation.IterativeMorphologicalDilation__v_iteration_count, None, IterativeMorphologicalDilation)
IterativeMorphologicalDilation.fill_missing_data = new_instancemethod(_iterative_morphological_dilation.IterativeMorphologicalDilation_fill_missing_data, None, IterativeMorphologicalDilation)
IterativeMorphologicalDilation.predicted_value = new_instancemethod(_iterative_morphological_dilation.IterativeMorphologicalDilation_predicted_value, None, IterativeMorphologicalDilation)
IterativeMorphologicalDilation.frontier_pixel_neighbor_count = new_instancemethod(_iterative_morphological_dilation.IterativeMorphologicalDilation_frontier_pixel_neighbor_count, None, IterativeMorphologicalDilation)
IterativeMorphologicalDilation_swigregister = _iterative_morphological_dilation.IterativeMorphologicalDilation_swigregister
IterativeMorphologicalDilation_swigregister(IterativeMorphologicalDilation)


__all__ = ["IterativeMorphologicalDilation"]



