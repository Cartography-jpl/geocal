#include "rsm_nitf.h"
#include "boost_pcall.h"
#include <boost/lexical_cast.hpp>
#define SWIG_MAPPER_NAMESPACE GeoCal
#include "serialize_function.h"
#include <cstdio>
using namespace GeoCal;

//-----------------------------------------------------------------------
/// We have support for saving RSMs as boost XML serialization
/// objects. This works well, but this is not an official standard. It
/// is useful to use a official standard for saving data, so we use
/// the RSM NITF standard, such as:
/// "Replacement Sensor Model Tagged Record Extensions Specification for NITF
/// 2.1" (http://www.gwg.nga.mil/ntb/baseline/docs/RSM/RSM_NITF_TREs_v1.0_.pdf)
///
/// While we could implement this entirely in C++, it is tricky to
/// handle everything. We already have an implementation in
/// python. This function uses a simple wrapper program that goes to
/// and from a NITF file, using python (boost_nitf_rsm). This should
/// be sufficient, we can always revisit this if there is an issue
/// with performance or the python dependency. But for now, we just
/// route the RSM through a system call.
///
/// This writes the given Rsm to a NITF file with the same name. The
/// NITF file has a single image segment in it with a size of 1x1, and
/// the TREs attached to the image segment supply the RSM.
//-----------------------------------------------------------------------

void GeoCal::rsm_write_nitf(const std::string& Fname,
		    const boost::shared_ptr<Rsm>& R)
{
  boost_pcall_noret("boost_nitf_rsm to_nitf " + Fname, R);
}

//-----------------------------------------------------------------------
/// Like rsm_write_nitf, but for GLAS/GFM ImageGroundConnection
//-----------------------------------------------------------------------

void GeoCal::glas_gfm_write_nitf(const std::string& Fname,
		 const boost::shared_ptr<ImageGroundConnection>& Igc)
{
  boost_pcall_noret("boost_nitf_glas_gfm to_nitf " + Fname, Igc);
}

//-----------------------------------------------------------------------
/// We have support for saving RSMs as boost XML serialization
/// objects. This works well, but this is not an official standard. It
/// is useful to use a official standard for saving data, so we use
/// the RSM NITF standard, such as:
/// "Replacement Sensor Model Tagged Record Extensions Specification for NITF
/// 2.1" (http://www.gwg.nga.mil/ntb/baseline/docs/RSM/RSM_NITF_TREs_v1.0_.pdf)
///
/// While we could implement this entirely in C++, it is tricky to
/// handle everything. We already have an implementation in
/// python. This function uses a simple wrapper program that goes to
/// and from a NITF file, using python (boost_nitf_rsm). This should
/// be sufficient, we can always revisit this if there is an issue
/// with performance or the python dependency. But for now, we just
/// route the RSM through a system call.
///
/// This reads a NITF file generated by rsm_write_nitf. We just take
/// the first image segment found in the file, and RSM defined by that
/// image segments TREs.
///
/// The NITF doesn't keep the Naif_code, so we pass that in. This gets
/// store in the VICAR file.
//-----------------------------------------------------------------------

boost::shared_ptr<Rsm> GeoCal::rsm_read_nitf(const std::string& Fname,
					     int Naif_code)
{
  return boost_pcall<Rsm>("boost_nitf_rsm from_nitf " +
			  Fname  + " " +
			  boost::lexical_cast<std::string>(Naif_code));
}

//-----------------------------------------------------------------------
/// Same as rsm_read_nitf, but for GLAS/GFM ImageGroundConnection
//-----------------------------------------------------------------------

boost::shared_ptr<ImageGroundConnection>
GeoCal::glas_gfm_read_nitf(const std::string& Fname, int Naif_code)
{
  return boost_pcall<ImageGroundConnection>("boost_nitf_glas_gfm from_nitf " +
			    Fname  + " " +
			    boost::lexical_cast<std::string>(Naif_code));
}
