# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _glas_gfm_camera.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_glas_gfm_camera')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_glas_gfm_camera')
    _glas_gfm_camera = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_glas_gfm_camera', [dirname(__file__)])
        except ImportError:
            import _glas_gfm_camera
            return _glas_gfm_camera
        try:
            _mod = imp.load_module('_glas_gfm_camera', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _glas_gfm_camera = swig_import_helper()
    del swig_import_helper
else:
    import _glas_gfm_camera
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _glas_gfm_camera.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_glas_gfm_camera.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_glas_gfm_camera.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_glas_gfm_camera.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_glas_gfm_camera.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_glas_gfm_camera.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_glas_gfm_camera.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_glas_gfm_camera.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_glas_gfm_camera.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_glas_gfm_camera.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_glas_gfm_camera.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_glas_gfm_camera.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_glas_gfm_camera.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_glas_gfm_camera.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_glas_gfm_camera.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_glas_gfm_camera.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_glas_gfm_camera.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _glas_gfm_camera.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _glas_gfm_camera.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.camera
import geocal_swig.generic_object
import geocal_swig.observer
import geocal_swig.with_parameter
class GlasGfmCamera(geocal_swig.camera.Camera):
    """

    This is a Camera with some extra metadata the pointing described by a
    field angle map.

    This is represented by the NITF DES CSSFAB.

    For some of these lower level objects we have directly read the TRE or
    DES (see for example PosCsephb). We haven't currently done this with
    this particular class - the data isn't large or at all slow to read so
    it is easier to just read/write this in python and use this lower
    level class for actually using the camera. We may revisit this, but at
    least for now this is really tied in with the NITF code in the python
    code in geocal_nitf_des.

    C++ includes: glas_gfm_camera.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        GlasGfmCamera::GlasGfmCamera(int Number_line=1, int Number_sample=256)

        """
        _glas_gfm_camera.GlasGfmCamera_swiginit(self, _glas_gfm_camera.new_GlasGfmCamera(*args))

    def set_number_line(self, V):
        """

        void GeoCal::GlasGfmCamera::set_number_line(int V)

        """
        return _glas_gfm_camera.GlasGfmCamera_set_number_line(self, V)


    def set_number_sample(self, V):
        """

        void GeoCal::GlasGfmCamera::set_number_sample(int V)

        """
        return _glas_gfm_camera.GlasGfmCamera_set_number_sample(self, V)


    def _v_focal_length(self, *args):
        """

        void GeoCal::GlasGfmCamera::focal_length(double V)
        Set focal length, in meters (so not mm like QuaternionCamera) 
        """
        return _glas_gfm_camera.GlasGfmCamera__v_focal_length(self, *args)


    @property
    def focal_length(self):
        return self._v_focal_length()

    @focal_length.setter
    def focal_length(self, value):
      self._v_focal_length(value)


    def _v_focal_length_with_derivative(self, *args):
        """

        void GeoCal::GlasGfmCamera::focal_length_with_derivative(const AutoDerivative< double > &V)
        Set focal length, in meters (so not mm like QuaternionCamera) 
        """
        return _glas_gfm_camera.GlasGfmCamera__v_focal_length_with_derivative(self, *args)


    @property
    def focal_length_with_derivative(self):
        return self._v_focal_length_with_derivative()

    @focal_length_with_derivative.setter
    def focal_length_with_derivative(self, value):
      self._v_focal_length_with_derivative(value)


    def frame_coordinate_to_xy(self, F, Band):
        """

        void GlasGfmCamera::frame_coordinate_to_xy(const FrameCoordinate &F, int Band, double &xfp, double &yfp) const
        Return the focal plane x and y for the given FrameCoordinate. 
        """
        return _glas_gfm_camera.GlasGfmCamera_frame_coordinate_to_xy(self, F, Band)


    def _v_frame_to_sc(self, *args):
        """

        void GeoCal::GlasGfmCamera::frame_to_sc(const boost::math::quaternion< double > &frame_to_sc_q)
        Set frame to spacecraft quaternion. 
        """
        return _glas_gfm_camera.GlasGfmCamera__v_frame_to_sc(self, *args)


    @property
    def frame_to_sc(self):
        return self._v_frame_to_sc()

    @frame_to_sc.setter
    def frame_to_sc(self, value):
      self._v_frame_to_sc(value)


    def _v_frame_to_sc_with_derivative(self, *args):
        """

        void GeoCal::GlasGfmCamera::frame_to_sc_with_derivative(const boost::math::quaternion< AutoDerivative< double > >
        &frame_to_sc_q)
        Set frame to spacecraft quaternion. 
        """
        return _glas_gfm_camera.GlasGfmCamera__v_frame_to_sc_with_derivative(self, *args)


    @property
    def frame_to_sc_with_derivative(self):
        return self._v_frame_to_sc_with_derivative()

    @frame_to_sc_with_derivative.setter
    def frame_to_sc_with_derivative(self, value):
      self._v_frame_to_sc_with_derivative(value)


    def _v_id(self, *args):
        """

        void GeoCal::GlasGfmCamera::id(const std::string &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_id(self, *args)


    @property
    def id(self):
        return self._v_id()

    @id.setter
    def id(self, value):
      self._v_id(value)


    def _v_sensor_type(self):
        """

        std::string GeoCal::GlasGfmCamera::sensor_type() const
        Sensor type, "S" or "F". 
        """
        return _glas_gfm_camera.GlasGfmCamera__v_sensor_type(self)


    @property
    def sensor_type(self):
        return self._v_sensor_type()


    def _v_fit_epsilon(self, *args):
        """

        void GeoCal::GlasGfmCamera::fit_epsilon(bool V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_fit_epsilon(self, *args)


    @property
    def fit_epsilon(self):
        return self._v_fit_epsilon()

    @fit_epsilon.setter
    def fit_epsilon(self, value):
      self._v_fit_epsilon(value)


    def _v_fit_beta(self, *args):
        """

        void GeoCal::GlasGfmCamera::fit_beta(bool V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_fit_beta(self, *args)


    @property
    def fit_beta(self):
        return self._v_fit_beta()

    @fit_beta.setter
    def fit_beta(self, value):
      self._v_fit_beta(value)


    def _v_fit_delta(self, *args):
        """

        void GeoCal::GlasGfmCamera::fit_delta(bool V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_fit_delta(self, *args)


    @property
    def fit_delta(self):
        return self._v_fit_delta()

    @fit_delta.setter
    def fit_delta(self, value):
      self._v_fit_delta(value)


    def _v_fit_focal_length(self, *args):
        """

        void GeoCal::GlasGfmCamera::fit_focal_length(bool V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_fit_focal_length(self, *args)


    @property
    def fit_focal_length(self):
        return self._v_fit_focal_length()

    @fit_focal_length.setter
    def fit_focal_length(self, value):
      self._v_fit_focal_length(value)


    def _v_band_type(self, *args):
        """

        void GeoCal::GlasGfmCamera::band_type(const std::string &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_band_type(self, *args)


    @property
    def band_type(self):
        return self._v_band_type()

    @band_type.setter
    def band_type(self, value):
      self._v_band_type(value)


    def _v_band_wavelength(self, *args):
        """

        void GeoCal::GlasGfmCamera::band_wavelength(double V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_band_wavelength(self, *args)


    @property
    def band_wavelength(self):
        return self._v_band_wavelength()

    @band_wavelength.setter
    def band_wavelength(self, value):
      self._v_band_wavelength(value)


    def _v_band_index(self, *args):
        """

        void GeoCal::GlasGfmCamera::band_index(const std::vector< int > &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_band_index(self, *args)


    @property
    def band_index(self):
        return self._v_band_index()

    @band_index.setter
    def band_index(self, value):
      self._v_band_index(value)


    def _v_irepband(self, *args):
        """

        void GeoCal::GlasGfmCamera::irepband(const std::vector< std::string > &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_irepband(self, *args)


    @property
    def irepband(self):
        return self._v_irepband()

    @irepband.setter
    def irepband(self, value):
      self._v_irepband(value)


    def _v_isubcat(self, *args):
        """

        void GeoCal::GlasGfmCamera::isubcat(const std::vector< std::string > &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_isubcat(self, *args)


    @property
    def isubcat(self):
        return self._v_isubcat()

    @isubcat.setter
    def isubcat(self, value):
      self._v_isubcat(value)


    def _v_focal_length_time(self, *args):
        """

        void GeoCal::GlasGfmCamera::focal_length_time(const Time &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_focal_length_time(self, *args)


    @property
    def focal_length_time(self):
        return self._v_focal_length_time()

    @focal_length_time.setter
    def focal_length_time(self, value):
      self._v_focal_length_time(value)


    def _v_ppoff(self, *args):
        """

        void GlasGfmCamera::ppoff(const blitz::Array< double, 1 > &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_ppoff(self, *args)


    @property
    def ppoff(self):
        return self._v_ppoff()

    @ppoff.setter
    def ppoff(self, value):
      self._v_ppoff(value)


    def _v_angoff(self, *args):
        """

        void GlasGfmCamera::angoff(const blitz::Array< double, 1 > &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_angoff(self, *args)


    @property
    def angoff(self):
        return self._v_angoff()

    @angoff.setter
    def angoff(self, value):
      self._v_angoff(value)


    def _v_sample_number_first(self, *args):
        """

        void GeoCal::GlasGfmCamera::sample_number_first(double V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_sample_number_first(self, *args)


    @property
    def sample_number_first(self):
        return self._v_sample_number_first()

    @sample_number_first.setter
    def sample_number_first(self, value):
      self._v_sample_number_first(value)


    def _v_delta_sample_pair(self, *args):
        """

        void GlasGfmCamera::delta_sample_pair(double V)
        Set delta Sample Pair. This is applicable for sensor type "S" only.

        """
        return _glas_gfm_camera.GlasGfmCamera__v_delta_sample_pair(self, *args)


    @property
    def delta_sample_pair(self):
        return self._v_delta_sample_pair()

    @delta_sample_pair.setter
    def delta_sample_pair(self, value):
      self._v_delta_sample_pair(value)


    def _v_field_alignment(self, *args):
        """

        void GeoCal::GlasGfmCamera::field_alignment(const blitz::Array< double, 2 > &V)
        Set Field Alignment.

        This is n x 4. The columns are start_x, start_y, end_x, end_y. This is
        applicable for sensor type "S" only.

        Note this does not change delta_sample_pair. If you alter the size of
        field_alignment you almost certainly want to also set
        delta_sample_pair, which is a separate step. 
        """
        return _glas_gfm_camera.GlasGfmCamera__v_field_alignment(self, *args)


    @property
    def field_alignment(self):
        return self._v_field_alignment()

    @field_alignment.setter
    def field_alignment(self, value):
      self._v_field_alignment(value)


    def field_alignment_fit(self, Cam, Delta_sample, Band=0):
        """

        void GlasGfmCamera::field_alignment_fit(const Camera &Cam, double Delta_sample, int Band=0)
        Populate the field_alignment, sample_number_first_, delta_sample_pair_
        to match the given camera.

        Only applicable for sensor type "S".

        You may want to call compare_camera to check how accurate the
        approximation is.

        Note that you should be careful not to double count any frame_t
        quaternion. If you pass that in with the Cam, then this is already
        accounted for in the field angle map (which has the effect of the
        quaternion embedded in it). If you want to assign the frame_to_sc to
        the GlasGfmCamera, then you should make sure to pass a Camera with a
        identity frame_to_sc. So a reasonable process (in python) would be
        something like:

        q_original = cam.frame_to_sc cam.frame_to_sc =
        Quaternion_double(1,0,0,0) gcam = GlasGfmCamera(cam, 0, ...)
        gcam.frame_to_sc = q_original cam.frame_to_sc = q_original 
        """
        return _glas_gfm_camera.GlasGfmCamera_field_alignment_fit(self, Cam, Delta_sample, Band)


    def _v_field_angle_type(self, *args):
        """

        void GeoCal::GlasGfmCamera::field_angle_type(int V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_field_angle_type(self, *args)


    @property
    def field_angle_type(self):
        return self._v_field_angle_type()

    @field_angle_type.setter
    def field_angle_type(self, value):
      self._v_field_angle_type(value)


    def _v_field_angle_interpolation_type(self, *args):
        """

        void GeoCal::GlasGfmCamera::field_angle_interpolation_type(int V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_field_angle_interpolation_type(self, *args)


    @property
    def field_angle_interpolation_type(self):
        return self._v_field_angle_interpolation_type()

    @field_angle_interpolation_type.setter
    def field_angle_interpolation_type(self, value):
      self._v_field_angle_interpolation_type(value)


    def _v_first_line_block(self, *args):
        """

        void GeoCal::GlasGfmCamera::first_line_block(const blitz::Array< double, 1 > &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_first_line_block(self, *args)


    @property
    def first_line_block(self):
        return self._v_first_line_block()

    @first_line_block.setter
    def first_line_block(self, value):
      self._v_first_line_block(value)


    def _v_first_sample_block(self, *args):
        """

        void GeoCal::GlasGfmCamera::first_sample_block(const blitz::Array< double, 1 > &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_first_sample_block(self, *args)


    @property
    def first_sample_block(self):
        return self._v_first_sample_block()

    @first_sample_block.setter
    def first_sample_block(self, value):
      self._v_first_sample_block(value)


    def _v_delta_line_block(self, *args):
        """

        void GeoCal::GlasGfmCamera::delta_line_block(const blitz::Array< double, 1 > &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_delta_line_block(self, *args)


    @property
    def delta_line_block(self):
        return self._v_delta_line_block()

    @delta_line_block.setter
    def delta_line_block(self, value):
      self._v_delta_line_block(value)


    def _v_delta_sample_block(self, *args):
        """

        void GeoCal::GlasGfmCamera::delta_sample_block(const blitz::Array< double, 1 > &V)

        """
        return _glas_gfm_camera.GlasGfmCamera__v_delta_sample_block(self, *args)


    @property
    def delta_sample_block(self):
        return self._v_delta_sample_block()

    @delta_sample_block.setter
    def delta_sample_block(self, value):
      self._v_delta_sample_block(value)


    def field_alignment_block(self, *args):
        """

        void GeoCal::GlasGfmCamera::field_alignment_block(int i, const blitz::Array< double, 5 > &V)

        """
        return _glas_gfm_camera.GlasGfmCamera_field_alignment_block(self, *args)


    def compare_camera(self, Cam, Band=0):
        """

        void GlasGfmCamera::compare_camera(const Camera &Cam, double &max_line_diff, double &max_sample_diff,
        int Band=0) const
        Return the maximum difference in frame coordinate line and sample
        between this camera and another camera.

        You may want to call this after doing field_alignment_block or
        field_alignment_fit. 
        """
        return _glas_gfm_camera.GlasGfmCamera_compare_camera(self, Cam, Band)


    def __reduce__(self):
      return _new_from_serialization, (geocal_swig.serialize_write_binary(self),)

    __swig_destroy__ = _glas_gfm_camera.delete_GlasGfmCamera
GlasGfmCamera.set_number_line = new_instancemethod(_glas_gfm_camera.GlasGfmCamera_set_number_line, None, GlasGfmCamera)
GlasGfmCamera.set_number_sample = new_instancemethod(_glas_gfm_camera.GlasGfmCamera_set_number_sample, None, GlasGfmCamera)
GlasGfmCamera._v_focal_length = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_focal_length, None, GlasGfmCamera)
GlasGfmCamera._v_focal_length_with_derivative = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_focal_length_with_derivative, None, GlasGfmCamera)
GlasGfmCamera.frame_coordinate_to_xy = new_instancemethod(_glas_gfm_camera.GlasGfmCamera_frame_coordinate_to_xy, None, GlasGfmCamera)
GlasGfmCamera._v_frame_to_sc = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_frame_to_sc, None, GlasGfmCamera)
GlasGfmCamera._v_frame_to_sc_with_derivative = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_frame_to_sc_with_derivative, None, GlasGfmCamera)
GlasGfmCamera._v_id = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_id, None, GlasGfmCamera)
GlasGfmCamera._v_sensor_type = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_sensor_type, None, GlasGfmCamera)
GlasGfmCamera._v_fit_epsilon = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_fit_epsilon, None, GlasGfmCamera)
GlasGfmCamera._v_fit_beta = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_fit_beta, None, GlasGfmCamera)
GlasGfmCamera._v_fit_delta = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_fit_delta, None, GlasGfmCamera)
GlasGfmCamera._v_fit_focal_length = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_fit_focal_length, None, GlasGfmCamera)
GlasGfmCamera._v_band_type = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_band_type, None, GlasGfmCamera)
GlasGfmCamera._v_band_wavelength = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_band_wavelength, None, GlasGfmCamera)
GlasGfmCamera._v_band_index = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_band_index, None, GlasGfmCamera)
GlasGfmCamera._v_irepband = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_irepband, None, GlasGfmCamera)
GlasGfmCamera._v_isubcat = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_isubcat, None, GlasGfmCamera)
GlasGfmCamera._v_focal_length_time = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_focal_length_time, None, GlasGfmCamera)
GlasGfmCamera._v_ppoff = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_ppoff, None, GlasGfmCamera)
GlasGfmCamera._v_angoff = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_angoff, None, GlasGfmCamera)
GlasGfmCamera._v_sample_number_first = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_sample_number_first, None, GlasGfmCamera)
GlasGfmCamera._v_delta_sample_pair = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_delta_sample_pair, None, GlasGfmCamera)
GlasGfmCamera._v_field_alignment = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_field_alignment, None, GlasGfmCamera)
GlasGfmCamera.field_alignment_fit = new_instancemethod(_glas_gfm_camera.GlasGfmCamera_field_alignment_fit, None, GlasGfmCamera)
GlasGfmCamera._v_field_angle_type = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_field_angle_type, None, GlasGfmCamera)
GlasGfmCamera._v_field_angle_interpolation_type = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_field_angle_interpolation_type, None, GlasGfmCamera)
GlasGfmCamera._v_first_line_block = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_first_line_block, None, GlasGfmCamera)
GlasGfmCamera._v_first_sample_block = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_first_sample_block, None, GlasGfmCamera)
GlasGfmCamera._v_delta_line_block = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_delta_line_block, None, GlasGfmCamera)
GlasGfmCamera._v_delta_sample_block = new_instancemethod(_glas_gfm_camera.GlasGfmCamera__v_delta_sample_block, None, GlasGfmCamera)
GlasGfmCamera.field_alignment_block = new_instancemethod(_glas_gfm_camera.GlasGfmCamera_field_alignment_block, None, GlasGfmCamera)
GlasGfmCamera.compare_camera = new_instancemethod(_glas_gfm_camera.GlasGfmCamera_compare_camera, None, GlasGfmCamera)
GlasGfmCamera_swigregister = _glas_gfm_camera.GlasGfmCamera_swigregister
GlasGfmCamera_swigregister(GlasGfmCamera)


__all__ = ["GlasGfmCamera"]



