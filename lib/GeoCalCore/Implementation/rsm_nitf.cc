#include "rsm_nitf.h"
#define SWIG_MAPPER_NAMESPACE GeoCal
#include "serialize_function.h"
#include <boost/lexical_cast.hpp>
#include <cstdio>
using namespace GeoCal;

//-----------------------------------------------------------------------
/// We have support for saving RSMs as boost XML serialization
/// objects. This works well, but this is not an official standard. It
/// is useful to use a official standard for saving data, so we use
/// the RSM NITF standard, such as:
/// "Replacement Sensor Model Tagged Record Extensions Specification for NITF
/// 2.1" (http://www.gwg.nga.mil/ntb/baseline/docs/RSM/RSM_NITF_TREs_v1.0_.pdf)
///
/// While we could implement this entirely in C++, it is tricky to
/// handle everything. We already have an implementation in
/// python. This function uses a simple wrapper program that goes to
/// and from a NITF file, using python (boost_nitf_rsm). This should
/// be sufficient, we can always revisit this if there is an issue
/// with performance or the python dependency. But for now, we just
/// route the RSM through a system call.
///
/// This writes the given Rsm to a NITF file with the same name. The
/// NITF file has a single image segment in it with a size of 1x1, and
/// the TREs attached to the image segment supply the RSM.
//-----------------------------------------------------------------------

void GeoCal::rsm_write_nitf(const std::string& Fname,
		    const boost::shared_ptr<Rsm>& R)
{
  std::string data = serialize_write_binary(R);
  std::string cmd = "boost_nitf_rsm to_nitf " + Fname;
  FILE* f = popen(cmd.c_str(), "w");
  if(!f)
    throw Exception("Trouble calling boost_nitf_rsm in rsm_write_nitf");
  fwrite(data.c_str(), sizeof(char), data.size(), f);
  int status = pclose(f);
  if(status)
    throw Exception("Trouble calling boost_nitf_rsm in rsm_write_nitf");
}

//-----------------------------------------------------------------------
/// Like rsm_write_nitf, but for GLAS/GFM ImageGroundConnection
//-----------------------------------------------------------------------

void GeoCal::glas_gfm_write_nitf(const std::string& Fname,
		 const boost::shared_ptr<ImageGroundConnection>& Igc)
{
  std::string data = serialize_write_binary(Igc);
  std::string cmd = "boost_nitf_glas_gfm to_nitf " + Fname;
  FILE* f = popen(cmd.c_str(), "w");
  if(!f)
    throw Exception("Trouble calling boost_nitf_glas_gfm in glas_gfm_write_nitf");
  fwrite(data.c_str(), sizeof(char), data.size(), f);
  int status = pclose(f);
  if(status)
    throw Exception("Trouble calling boost_nitf_glas_gfm in glas_gfm_write_nitf");
}

//-----------------------------------------------------------------------
/// We have support for saving RSMs as boost XML serialization
/// objects. This works well, but this is not an official standard. It
/// is useful to use a official standard for saving data, so we use
/// the RSM NITF standard, such as:
/// "Replacement Sensor Model Tagged Record Extensions Specification for NITF
/// 2.1" (http://www.gwg.nga.mil/ntb/baseline/docs/RSM/RSM_NITF_TREs_v1.0_.pdf)
///
/// While we could implement this entirely in C++, it is tricky to
/// handle everything. We already have an implementation in
/// python. This function uses a simple wrapper program that goes to
/// and from a NITF file, using python (boost_nitf_rsm). This should
/// be sufficient, we can always revisit this if there is an issue
/// with performance or the python dependency. But for now, we just
/// route the RSM through a system call.
///
/// This reads a NITF file generated by rsm_write_nitf. We just take
/// the first image segment found in the file, and RSM defined by that
/// image segments TREs.
///
/// The NITF doesn't keep the Naif_code, so we pass that in. This gets
/// store in the VICAR file.
//-----------------------------------------------------------------------

boost::shared_ptr<Rsm> GeoCal::rsm_read_nitf(const std::string& Fname,
					     int Naif_code)
{
  std::string cmd = "boost_nitf_rsm from_nitf " + Fname + " " +
    boost::lexical_cast<std::string>(Naif_code);
  FILE* f = popen(cmd.c_str(), "r");
  if(!f)
    throw Exception("Trouble calling boost_nitf_rsm in rsm_read_nitf");
  std::string data;
  data.reserve(1000);		// We'll need some space, so go ahead
				// at set it aside.
  int c = fgetc(f);
  while(!feof(f)) {
    data.push_back((char) c);
    c = getc(f);
  }
  int status = pclose(f);
  if(status)
    throw Exception("Trouble calling boost_nitf_rsm in rsm_read_nitf");
  return serialize_read_binary_string<Rsm>(data);
}

//-----------------------------------------------------------------------
/// Same as rsm_read_nitf, but for GLAS/GFM ImageGroundConnection
//-----------------------------------------------------------------------

boost::shared_ptr<ImageGroundConnection>
GeoCal::glas_gfm_read_nitf(const std::string& Fname, int Naif_code)
{
  std::string cmd = "boost_nitf_glas_gfm from_nitf " + Fname  + " " +
    boost::lexical_cast<std::string>(Naif_code);
  FILE* f = popen(cmd.c_str(), "r");
  if(!f)
    throw Exception("Trouble calling boost_nitf_glas_gfm in glas_gfm_read_nitf");
  std::string data;
  data.reserve(1000);		// We'll need some space, so go ahead
				// at set it aside.
  int c = fgetc(f);
  while(!feof(f)) {
    data.push_back((char) c);
    c = getc(f);
  }
  int status = pclose(f);
  if(status)
    throw Exception("Trouble calling boost_nitf_glas_gfm in glas_gfm_read_nitf");
  return serialize_read_binary_string<ImageGroundConnection>(data);
}
