#! /usr/bin/env python
#
# This collects tie points.

from afids import *
from multiprocessing import Pool

version = "February 4, 2013"
usage="""Usage: 
  tp_collect [options] <igc> <output>
  tp_collect --gcp [options] <igc> <reference_image> <output>
  tp_collect -h | --help
  tp_collect -v | --version

This program is used to generate a collection of tie points or ground control
points (tie points with the addition of ground truth).

This creates a sqlite shelve object that holds an array of TiePoints. The
output should be in "file:key" format, e.g., "my_data.db:tp". The input is
the IgcCollection to use, also in the same format (which can be in the same
or a different input file).

If you supply a reference image, this should be a "file:key" object.

Options:
  -h --help         
       Print this message

  --add-tp
       The default behavior is to overwrite whatever "file:key" value is
       specified as the output. You can optionally add the TP/GCPs we 
       generate.

  --reference-dem=shelve
       DEM to use with the reference image specified as file:key. 
       If not specified, we use the DEM from the first IGC.

  --gcp
       Create GCPs, which requires the additional arguments of a reference
       image.

  --number-process=n 
       Number of processors to use. [default: 1]

  --number-x=n      
       Number of grid points in the X direction to try for [default: 100]

  --number-y=n      
       Number of grid points in the Y direction to try for [default: 100]
 
  -v --version      
       Print program version
"""

args = docopt_simple(usage, version=version)
pool = None
if(args.number_process > 1):
    pool = Pool(args.number_process)

igc = read_shelve(args.igc)
if(args.gcp):
    if(args.reference_dem):
        dem = read_shelve(args.reference_dem)
    else:
        dem = igc.dem(0)
    refimg = read_shelve(args.reference_image)
    tpcollect = GcpTiePointCollect(refimg, dem, igc)
else:
    tpcollect = TiePointCollect(igc)

tparr = tpcollect.tie_point_grid(args.number_x, args.number_y, 
                                 pool = pool)

if(args.add_tp):
    tparr.extend(read_shelve(args.output))

write_shelve(args.output, tparr)


