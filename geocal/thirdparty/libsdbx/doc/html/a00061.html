<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libsdbx-1.0: RTree/RTree.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_77e788db3be33bcba33e4b74c0683ce9.html">RTree</a>
  </div>
</div>
<div class="contents">
<h1>RTree.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  SDBX</span>
<a name="l00003"></a>00003 <span class="comment"> *      $Id: RTree.h 1844 2009-03-31 14:19:13Z virtuald $</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> *  Copyright (c) 2008 - 2009 Dustin Spicuzza &lt;dustin@virtualroadside.com&gt;</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> *  This program is free software; you can redistribute it and/or</span>
<a name="l00008"></a>00008 <span class="comment"> *  modify it under the terms of the GNU Lesser General Public</span>
<a name="l00009"></a>00009 <span class="comment"> *  License as published by the Free Software Foundation; either</span>
<a name="l00010"></a>00010 <span class="comment"> *  version 2.1 of the License, or (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment"> *  GNU Lesser General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> *  You should have received a copy of the GNU Lesser General Public</span>
<a name="l00018"></a>00018 <span class="comment"> *  License along with this library; if not, write to the Free Software</span>
<a name="l00019"></a>00019 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> *</span>
<a name="l00022"></a>00022 <span class="comment"> *      Do not include this file directly, include &lt;sdbx/RTree.h&gt; instead.</span>
<a name="l00023"></a>00023 <span class="comment"> */</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#ifndef SDBX_RTREE_RTREE_H</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#define SDBX_RTREE_RTREE_H</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#ifdef USE_MSVC_MEMORY_TRACING</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>        <span class="comment">// this enables advanced memory leak detection</span>
<a name="l00031"></a>00031 <span class="preprocessor">        #include &lt;wx/msw/msvcrt.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#endif</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 <span class="comment">// R* tree parameters</span>
<a name="l00035"></a>00035 <span class="preprocessor">#define RTREE_REINSERT_P 0.30</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#define RTREE_CHOOSE_SUBTREE_P 32</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#define SET_BAD_ERROR( code )   \</span>
<a name="l00040"></a>00040 <span class="preprocessor">        m_lastError = code;                     \</span>
<a name="l00041"></a>00041 <span class="preprocessor">        assert(0 &amp;&amp; #code)</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">// this is the template definition for the RTree.. no, I'm not</span>
<a name="l00045"></a>00045 <span class="comment">// kidding unfortunately</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#define __RTREE_TEMPLATE_DEFN                                                                                           \</span>
<a name="l00048"></a>00048 <span class="preprocessor">template &lt;                                                                                                                                      \</span>
<a name="l00049"></a>00049 <span class="preprocessor">        typename _bound_type,                                                                                                   \</span>
<a name="l00050"></a>00050 <span class="preprocessor">        typename _leaf_type,                                                                                                    \</span>
<a name="l00051"></a>00051 <span class="preprocessor">        std::size_t _dimensions,                                                                                                \</span>
<a name="l00052"></a>00052 <span class="preprocessor">        std::size_t _min_child_items,                                                                                   \</span>
<a name="l00053"></a>00053 <span class="preprocessor">        std::size_t _max_child_items,                                                                                   \</span>
<a name="l00054"></a>00054 <span class="preprocessor">        template &lt;                                                                                                                              \</span>
<a name="l00055"></a>00055 <span class="preprocessor">                typename _b_nb,                                                                                                         \</span>
<a name="l00056"></a>00056 <span class="preprocessor">                template &lt;typename _bn_i, std::size_t _bn_mi&gt; class _NodeType,          \</span>
<a name="l00057"></a>00057 <span class="preprocessor">                template &lt;typename _bni_k, typename _bni_i&gt; class _NodeItemType,        \</span>
<a name="l00058"></a>00058 <span class="preprocessor">                typename _b_l,                                                                                                          \</span>
<a name="l00059"></a>00059 <span class="preprocessor">                typename _b_k,                                                                                                          \</span>
<a name="l00060"></a>00060 <span class="preprocessor">                std::size_t _b_mi&gt;                                                                                                      \</span>
<a name="l00061"></a>00061 <span class="preprocessor">        class _Backend                                                                                                                  \</span>
<a name="l00062"></a>00062 <span class="preprocessor">&gt;</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00064"></a>00064 <span class="preprocessor">#define __RTREE_TEMPLATE_FN             \</span>
<a name="l00065"></a>00065 <span class="preprocessor">        _bound_type,                            \</span>
<a name="l00066"></a>00066 <span class="preprocessor">        _leaf_type,                                     \</span>
<a name="l00067"></a>00067 <span class="preprocessor">        _dimensions,                            \</span>
<a name="l00068"></a>00068 <span class="preprocessor">        _min_child_items,                       \</span>
<a name="l00069"></a>00069 <span class="preprocessor">        _max_child_items,                       \</span>
<a name="l00070"></a>00070 <span class="preprocessor">        _Backend                                                                                                </span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 
<a name="l00092"></a>00092 __RTREE_TEMPLATE_DEFN
<a name="l00093"></a><a class="code" href="a00013.html">00093</a> <span class="keyword">class </span><a class="code" href="a00013.html" title="Implementation of an RTree with an R* index.">RTree</a> {
<a name="l00094"></a>00094 <span class="keyword">public</span>:
<a name="l00095"></a>00095 
<a name="l00096"></a>00096         <span class="keyword">typedef</span> <a class="code" href="a00013.html" title="Implementation of an RTree with an R* index.">RTree&lt;__RTREE_TEMPLATE_FN&gt;</a>                                      <a class="code" href="a00013.html" title="Implementation of an RTree with an R* index.">this_type</a>;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098         <span class="comment">// expose template types</span>
<a name="l00099"></a>00099         <span class="keyword">enum</span> {
<a name="l00100"></a>00100                 dimensions = _dimensions,
<a name="l00101"></a>00101                 min_child_items = _min_child_items,
<a name="l00102"></a>00102                 max_child_items = _max_child_items,
<a name="l00103"></a>00103         };
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         <span class="keyword">typedef</span> RTreeBoundingBox&lt;dimensions, _bound_type&gt;       BoundingBox;
<a name="l00106"></a>00106         
<a name="l00107"></a>00107         <span class="comment">// indexed by bounding box</span>
<a name="l00108"></a>00108         <span class="keyword">typedef</span> BoundingBox                                                                     KeyType;
<a name="l00109"></a>00109         <span class="keyword">typedef</span> _leaf_type                                                                      LeafType;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111         <span class="comment">// shortcut definitions</span>
<a name="l00112"></a>00112         <span class="keyword">typedef</span> TreeNodeBase                                                            NodeBase;
<a name="l00113"></a>00113         
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <span class="keyword">typedef</span> TreeLeafItem&lt;KeyType, LeafType&gt;                         LeafItem;
<a name="l00116"></a>00116         <span class="keyword">typedef</span> <a class="code" href="a00022.html" title="Stores and handles serialization for items in a Tree.">TreeNode&lt;LeafItem, max_child_items&gt;</a>             <a class="code" href="a00022.html" title="Stores and handles serialization for items in a Tree.">LeafNode</a>;
<a name="l00117"></a>00117         <span class="keyword">typedef</span> <span class="keyword">typename</span> LeafNode::ItemArray                            LeafItemArray;
<a name="l00118"></a>00118         <span class="keyword">typedef</span> <span class="keyword">typename</span> LeafItemArray::iterator                        LeafItemIterator;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120         <span class="comment">// import types from the backend</span>
<a name="l00121"></a>00121         <span class="keyword">typedef</span> _Backend&lt;
<a name="l00122"></a>00122                                         NodeBase, 
<a name="l00123"></a>00123                                         <a class="code" href="a00018.html" title="Stores and handles serialization for items in a Tree.">RTreeNode</a>, 
<a name="l00124"></a>00124                                         TreeNodeItem, 
<a name="l00125"></a>00125                                         <a class="code" href="a00022.html" title="Stores and handles serialization for items in a Tree.">LeafNode</a>, 
<a name="l00126"></a>00126                                         KeyType, 
<a name="l00127"></a>00127                                         max_child_items&gt;                                        Backend;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129         <span class="keyword">typedef</span> <span class="keyword">typename</span> Backend::Args                                          BackendArgs;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         <span class="keyword">typedef</span> <span class="keyword">typename</span> Backend::size_type                                     size_type;
<a name="l00132"></a>00132         <span class="keyword">typedef</span> <span class="keyword">typename</span> Backend::IdType                                        IdType;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134         <span class="keyword">typedef</span> <span class="keyword">typename</span> Backend::NodeItem                                      NodeItem;
<a name="l00135"></a>00135         <span class="keyword">typedef</span> <span class="keyword">typename</span> Backend::Node                                          Node;
<a name="l00136"></a>00136         <span class="keyword">typedef</span> <span class="keyword">typename</span> Node::ItemArray                                        NodeItemArray;
<a name="l00137"></a>00137         <span class="keyword">typedef</span> <span class="keyword">typename</span> NodeItemArray::iterator                        NodeItemIterator;
<a name="l00138"></a>00138         
<a name="l00139"></a>00139         <span class="comment">// acceptor functors</span>
<a name="l00140"></a>00140 
<a name="l00142"></a><a class="code" href="a00013.html#b1cd11ac78af030c3a1edb30692a9c3e">00142</a>         <span class="keyword">typedef</span> <a class="code" href="a00016.html" title="returns true if the Item overlaps the specified bound">RTreeAcceptOverlapping&lt;NodeItem, LeafItem&gt;</a>      <a class="code" href="a00016.html" title="returns true if the Item overlaps the specified bound">AcceptOverlapping</a>;
<a name="l00143"></a>00143 
<a name="l00145"></a><a class="code" href="a00013.html#050521fcb0828dae353cd4aa8225a6b4">00145</a>         <span class="keyword">typedef</span> <a class="code" href="a00015.html" title="returns true if the compared boundary is within the specified bound">RTreeAcceptEnclosing&lt;NodeItem, LeafItem&gt;</a>        <a class="code" href="a00015.html" title="returns true if the compared boundary is within the specified bound">AcceptEnclosing</a>;
<a name="l00146"></a>00146 
<a name="l00148"></a><a class="code" href="a00013.html#6a0b56a93da62f760939f62d5e841711">00148</a>         <span class="keyword">typedef</span> <a class="code" href="a00014.html" title="will always return true, no matter what -- used to iterate over the entire set of...">RTreeAcceptAny&lt;NodeItem, LeafItem&gt;</a>                      <a class="code" href="a00014.html" title="will always return true, no matter what -- used to iterate over the entire set of...">AcceptAny</a>;
<a name="l00149"></a>00149         
<a name="l00150"></a>00150         <span class="comment">// define iterator types (not STL compatible)</span>
<a name="l00151"></a>00151         <span class="keyword">typedef</span> <a class="code" href="a00017.html" title="This defines an iterator for the R Tree.">RTreeIterator&lt;this_type, AcceptOverlapping&gt;</a>     <a class="code" href="a00017.html" title="This defines an iterator for the R Tree.">OverlappingIterator</a>;
<a name="l00152"></a>00152         <span class="keyword">typedef</span> <a class="code" href="a00017.html" title="This defines an iterator for the R Tree.">RTreeIterator&lt;this_type, AcceptEnclosing&gt;</a>       <a class="code" href="a00017.html" title="This defines an iterator for the R Tree.">EnclosedIterator</a>;
<a name="l00153"></a>00153         <span class="keyword">typedef</span> <a class="code" href="a00017.html" title="This defines an iterator for the R Tree.">RTreeIterator&lt;this_type, AcceptAny&gt;</a>                     <a class="code" href="a00017.html" title="This defines an iterator for the R Tree.">Iterator</a>;
<a name="l00154"></a>00154         
<a name="l00155"></a>00155         
<a name="l00156"></a>00156         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> this_type, <span class="keyword">typename</span> Acceptor&gt; 
<a name="l00157"></a>00157         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00017.html" title="This defines an iterator for the R Tree.">RTreeIterator</a>;
<a name="l00158"></a>00158         
<a name="l00159"></a>00159         
<a name="l00160"></a>00160         <span class="comment">// error codes</span>
<a name="l00161"></a>00161         <span class="keyword">enum</span> ErrorCode {
<a name="l00162"></a>00162                 ERR_NONE = 0,
<a name="l00163"></a>00163                 ERR_CREATE_ROOT,
<a name="l00164"></a>00164                 ERR_GET_LEAFNODE,
<a name="l00165"></a>00165                 ERR_GET_NODE,
<a name="l00166"></a>00166                 ERR_GET_ROOT,
<a name="l00167"></a>00167                 ERR_CREATE_NODE_IN_SPLIT,
<a name="l00168"></a>00168                 ERR_CREATE_SPLIT_ROOT,
<a name="l00169"></a>00169                 ERR_GET_SPLIT_ROOT,
<a name="l00170"></a>00170                 ERR_EXTEND_BOUNDS_FAILED
<a name="l00171"></a>00171         };
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00176"></a><a class="code" href="a00013.html#311d1bfc3a3f75f8ac2366602cbf009a">00176</a>         <a class="code" href="a00013.html#311d1bfc3a3f75f8ac2366602cbf009a" title="Default constructor.">RTree</a>()
<a name="l00177"></a>00177         { 
<a name="l00178"></a>00178                 assert(1 &lt;= min_child_items &amp;&amp; min_child_items &lt;= max_child_items/2);
<a name="l00179"></a>00179         }
<a name="l00180"></a>00180         
<a name="l00181"></a>00181         <span class="comment">// destructor</span>
<a name="l00182"></a>00182         ~<a class="code" href="a00013.html" title="Implementation of an RTree with an R* index.">RTree</a>() {
<a name="l00183"></a>00183         }
<a name="l00184"></a>00184 
<a name="l00187"></a>00187 
<a name="l00188"></a>00188         <span class="comment">// initializes the backend using the specified arguments</span>
<a name="l00189"></a>00189         <span class="keywordtype">bool</span> Initialize(BackendArgs &amp;args) WARN_IF_UNUSED
<a name="l00190"></a>00190         {
<a name="l00191"></a>00191                 <span class="keywordflow">return</span> backend.Initialize(args);
<a name="l00192"></a>00192         }
<a name="l00193"></a>00193         
<a name="l00194"></a>00194         <span class="keywordtype">bool</span> IsOk()
<a name="l00195"></a>00195         {
<a name="l00196"></a>00196                 <span class="keywordflow">return</span> backend.IsOk();
<a name="l00197"></a>00197         }
<a name="l00198"></a>00198         
<a name="l00200"></a><a class="code" href="a00013.html#73cc91cc6815efa9acaea74b294bb960">00200</a>         ErrorCode <a class="code" href="a00013.html#73cc91cc6815efa9acaea74b294bb960" title="returns the last error code">GetErrorCode</a>()<span class="keyword"> const</span>
<a name="l00201"></a>00201 <span class="keyword">        </span>{
<a name="l00202"></a>00202                 <span class="keywordflow">return</span> m_lastError;
<a name="l00203"></a>00203         }
<a name="l00204"></a>00204         
<a name="l00206"></a>00206         
<a name="l00209"></a>00209         
<a name="l00210"></a>00210         <span class="comment">// find items that overlap a specified bounding box</span>
<a name="l00211"></a>00211         OverlappingIterator * FindOverlapping(<span class="keyword">const</span> BoundingBox &amp;bound)
<a name="l00212"></a>00212         {
<a name="l00213"></a>00213                 <span class="keywordflow">return</span> <span class="keyword">new</span> OverlappingIterator(<span class="keyword">this</span>, <a class="code" href="a00013.html#b1cd11ac78af030c3a1edb30692a9c3e" title="overlapping the specified bound">AcceptOverlapping</a>(bound));
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215         
<a name="l00216"></a>00216         <span class="comment">// find items that are enclosed in a specified bounding box</span>
<a name="l00217"></a>00217         EnclosedIterator * FindEnclosed(<span class="keyword">const</span> BoundingBox &amp;bound)
<a name="l00218"></a>00218         {       
<a name="l00219"></a>00219                 <span class="keywordflow">return</span> <span class="keyword">new</span> EnclosedIterator(<span class="keyword">this</span>, <a class="code" href="a00013.html#050521fcb0828dae353cd4aa8225a6b4" title="enclosed in the specified bound">AcceptEnclosing</a>(bound));
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221         
<a name="l00222"></a>00222         <span class="comment">// iterate the entire tree</span>
<a name="l00223"></a>00223         Iterator * Begin()
<a name="l00224"></a>00224         {
<a name="l00225"></a>00225                 <span class="keywordflow">return</span> <span class="keyword">new</span> Iterator(<span class="keyword">this</span>, <a class="code" href="a00013.html#6a0b56a93da62f760939f62d5e841711" title="accepts every single node">AcceptAny</a>());
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227         
<a name="l00229"></a>00229         
<a name="l00230"></a>00230         
<a name="l00231"></a>00231         <span class="comment">// Single insert function, adds a new item to the tree</span>
<a name="l00232"></a>00232         <span class="keywordtype">bool</span> Insert(<span class="keyword">const</span> BoundingBox &amp;key, <span class="keyword">const</span> LeafType &amp;leaf) WARN_IF_UNUSED
<a name="l00233"></a>00233         {
<a name="l00234"></a>00234                 m_lastError = ERR_NONE;
<a name="l00235"></a>00235                 
<a name="l00236"></a>00236                 <span class="comment">// do not insert invalid bounding boxes</span>
<a name="l00237"></a>00237                 <span class="keywordflow">if</span> (!key.verify())
<a name="l00238"></a>00238                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00239"></a>00239         
<a name="l00240"></a>00240                 <span class="comment">// ID1: Invoke Insert starting with the leaf level as a</span>
<a name="l00241"></a>00241                 <span class="comment">// parameter, to Insert a new data rectangle</span>
<a name="l00242"></a>00242 
<a name="l00243"></a>00243                 <span class="comment">// create a new root node if necessary</span>
<a name="l00244"></a>00244                 <span class="keywordflow">if</span> (backend.m_treeHeight == 0)
<a name="l00245"></a>00245                 {
<a name="l00246"></a>00246                         <span class="comment">// create a root node</span>
<a name="l00247"></a>00247                         <span class="keywordflow">if</span> (!backend.create_root_node())
<a name="l00248"></a>00248                         {
<a name="l00249"></a>00249                                 SET_BAD_ERROR(ERR_CREATE_ROOT);
<a name="l00250"></a>00250                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00251"></a>00251                         }
<a name="l00252"></a>00252                         
<a name="l00253"></a>00253                         <span class="comment">// reserve memory</span>
<a name="l00254"></a>00254                         LeafNode * root = backend.get_leaf_node(backend.m_rootId);
<a name="l00255"></a>00255         
<a name="l00256"></a>00256                         <span class="keywordflow">if</span> (!root)
<a name="l00257"></a>00257                         {
<a name="l00258"></a>00258                                 SET_BAD_ERROR(ERR_GET_ROOT);
<a name="l00259"></a>00259                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00260"></a>00260                         }
<a name="l00261"></a>00261                         
<a name="l00262"></a>00262                         root-&gt;items.push_back(LeafItem(key, leaf));
<a name="l00263"></a>00263                         root-&gt;is_dirty = <span class="keyword">true</span>;
<a name="l00264"></a>00264                 }
<a name="l00265"></a>00265                 <span class="keywordflow">else</span>
<a name="l00266"></a>00266                 {
<a name="l00267"></a>00267                         <span class="comment">// begin a recursive insert</span>
<a name="l00268"></a>00268 <span class="preprocessor">                        #ifndef NDEBUG</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span>                                OverflowItem * oi = 
<a name="l00270"></a>00270 <span class="preprocessor">                        #endif</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span>                        
<a name="l00272"></a>00272                         InsertInternal(LeafItem(key, leaf), backend.m_rootId, 1);
<a name="l00273"></a>00273                         assert(!oi &amp;&amp; <span class="stringliteral">"this should always be NULL"</span>);    
<a name="l00274"></a>00274                 }
<a name="l00275"></a>00275                         
<a name="l00276"></a>00276                 <span class="keywordflow">if</span> (m_lastError != ERR_NONE)
<a name="l00277"></a>00277                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279                 <span class="comment">// stretch the root bound -- this isn't used, but maybe it should</span>
<a name="l00280"></a>00280                 <span class="comment">// be at some point.. </span>
<a name="l00281"></a>00281                 <span class="comment">//backend.m_rootItem.key.stretch(key);</span>
<a name="l00282"></a>00282                         
<a name="l00283"></a>00283                 backend.m_size += 1;
<a name="l00284"></a>00284                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00285"></a>00285         }
<a name="l00286"></a>00286         
<a name="l00287"></a>00287         <span class="keywordtype">bool</span> ExtendBounds(<span class="keyword">const</span> BoundingBox &amp;key, <span class="keyword">const</span> LeafType &amp;leaf) WARN_IF_UNUSED
<a name="l00288"></a>00288         {
<a name="l00289"></a>00289                 m_lastError = ERR_NONE;
<a name="l00290"></a>00290         
<a name="l00291"></a>00291                 <span class="comment">// fast search first</span>
<a name="l00292"></a>00292                 OverlappingIterator * it1 = <span class="keyword">new</span> OverlappingIterator(<span class="keyword">this</span>, <a class="code" href="a00013.html#b1cd11ac78af030c3a1edb30692a9c3e" title="overlapping the specified bound">AcceptOverlapping</a>(key));
<a name="l00293"></a>00293                 
<a name="l00294"></a>00294                 <span class="keywordflow">if</span> (!it1-&gt;end())
<a name="l00295"></a>00295                 {
<a name="l00296"></a>00296                         <span class="keywordflow">do</span>
<a name="l00297"></a>00297                         {
<a name="l00298"></a>00298                                 <span class="comment">// find the object and extend the bounds </span>
<a name="l00299"></a>00299                                 LeafType &amp;l = it1-&gt;current().value;
<a name="l00300"></a>00300                                 
<a name="l00301"></a>00301                                 <span class="keywordflow">if</span> (l == leaf)
<a name="l00302"></a>00302                                 {
<a name="l00303"></a>00303                                         <span class="comment">//bool ret = it1-&gt;ExtendStackBounds(key);</span>
<a name="l00304"></a>00304                                         <span class="keyword">delete</span> it1;
<a name="l00305"></a>00305                                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00306"></a>00306                                 }
<a name="l00307"></a>00307                         } <span class="keywordflow">while</span> (it1-&gt;next());
<a name="l00308"></a>00308                 }
<a name="l00309"></a>00309                 
<a name="l00310"></a>00310                 <span class="keyword">delete</span> it1;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312                 <span class="comment">// slow search next.. </span>
<a name="l00313"></a>00313                 Iterator * it2 = <span class="keyword">new</span> Iterator(<span class="keyword">this</span>, <a class="code" href="a00013.html#6a0b56a93da62f760939f62d5e841711" title="accepts every single node">AcceptAny</a>());
<a name="l00314"></a>00314                 
<a name="l00315"></a>00315                 <span class="keywordflow">if</span> (!it2-&gt;end())
<a name="l00316"></a>00316                 {
<a name="l00317"></a>00317                         <span class="keywordflow">do</span>
<a name="l00318"></a>00318                         {
<a name="l00319"></a>00319                                 <span class="comment">// find the object and extend the bounds </span>
<a name="l00320"></a>00320                                 LeafType &amp;l = it2-&gt;current().value;
<a name="l00321"></a>00321                                 
<a name="l00322"></a>00322                                 <span class="keywordflow">if</span> (l == leaf)
<a name="l00323"></a>00323                                 {
<a name="l00324"></a>00324                                         <span class="comment">//bool ret = it2-&gt;ExtendStackBounds(key);</span>
<a name="l00325"></a>00325                                         <span class="keyword">delete</span> it2;
<a name="l00326"></a>00326                                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00327"></a>00327                                 }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329                         } <span class="keywordflow">while</span> (it2-&gt;next());
<a name="l00330"></a>00330                 }
<a name="l00331"></a>00331                 
<a name="l00332"></a>00332                 <span class="keyword">delete</span> it2;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334                 <span class="comment">// this should never happen</span>
<a name="l00335"></a>00335                 SET_BAD_ERROR( ERR_EXTEND_BOUNDS_FAILED );
<a name="l00336"></a>00336                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00337"></a>00337         }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339         
<a name="l00340"></a>00340         size_type GetItemCount()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> backend.m_size; }
<a name="l00341"></a>00341         size_type GetHeight()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> backend.m_treeHeight; }
<a name="l00342"></a>00342         size_type GetDimensions()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dimensions; }
<a name="l00343"></a>00343         
<a name="l00344"></a>00344         <span class="keywordtype">bool</span> <a class="code" href="a00013.html#a97acc30439f24081de19765d8598484" title="Use this to verify that a tree has a valid structure (walks all nodes).">Verify</a>();
<a name="l00345"></a>00345         
<a name="l00346"></a>00346 <span class="keyword">private</span>:
<a name="l00347"></a>00347         
<a name="l00360"></a>00360         IdType ChooseSubtree(Node * node, <span class="keyword">const</span> size_type &amp;level, <span class="keyword">const</span> BoundingBox &amp;bound)
<a name="l00361"></a>00361         {
<a name="l00362"></a>00362                 assert(node);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364                 NodeItemIterator next_item;
<a name="l00365"></a>00365                 
<a name="l00366"></a>00366                 <span class="comment">// If the child pointers in N point to leaves </span>
<a name="l00367"></a>00367                 <span class="keywordflow">if</span> (level + 1 == backend.m_treeHeight)
<a name="l00368"></a>00368                 {
<a name="l00369"></a>00369                         <span class="comment">// determine the minimum overlap cost</span>
<a name="l00370"></a>00370                         <span class="keywordflow">if</span> (max_child_items &gt; (RTREE_CHOOSE_SUBTREE_P*2)/3  &amp;&amp; node-&gt;items.size() &gt; RTREE_CHOOSE_SUBTREE_P)
<a name="l00371"></a>00371                         {
<a name="l00372"></a>00372                                 <span class="comment">// ** alternative algorithm:</span>
<a name="l00373"></a>00373                                 <span class="comment">// Sort the rectangles in N in increasing order of</span>
<a name="l00374"></a>00374                                 <span class="comment">// the area enlargement needed to include the new</span>
<a name="l00375"></a>00375                                 <span class="comment">// data rectangle</span>
<a name="l00376"></a>00376                                 
<a name="l00377"></a>00377                                 <span class="comment">// Let A be the group of the first p entrles</span>
<a name="l00378"></a>00378                                 std::partial_sort( node-&gt;items.begin(), node-&gt;items.begin() + RTREE_CHOOSE_SUBTREE_P, node-&gt;items.end(), 
<a name="l00379"></a>00379                                         SortBoundedItemsByAreaEnlargement&lt;NodeItem&gt;(bound));
<a name="l00380"></a>00380                                 
<a name="l00381"></a>00381                                 <span class="comment">// From the items in A, considering all items in</span>
<a name="l00382"></a>00382                                 <span class="comment">// N, choose the leaf whose rectangle needs least</span>
<a name="l00383"></a>00383                                 <span class="comment">// overlap enlargement</span>
<a name="l00384"></a>00384                                 
<a name="l00385"></a>00385                                 next_item = std::min_element(node-&gt;items.begin(), node-&gt;items.begin() + RTREE_CHOOSE_SUBTREE_P,
<a name="l00386"></a>00386                                         SortBoundedItemsByOverlapEnlargement&lt;NodeItem&gt;(bound));
<a name="l00387"></a>00387                         }
<a name="l00388"></a>00388                         <span class="keywordflow">else</span>
<a name="l00389"></a>00389                         {
<a name="l00390"></a>00390                                 <span class="comment">// choose the leaf in N whose rectangle needs least</span>
<a name="l00391"></a>00391                                 <span class="comment">// overlap enlargement to include the new data</span>
<a name="l00392"></a>00392                                 <span class="comment">// rectangle Resolve ties by choosmg the leaf</span>
<a name="l00393"></a>00393                                 <span class="comment">// whose rectangle needs least area enlargement, then</span>
<a name="l00394"></a>00394                                 <span class="comment">// the leaf with the rectangle of smallest area</span>
<a name="l00395"></a>00395                                 
<a name="l00396"></a>00396                                 next_item = std::min_element(node-&gt;items.begin(), node-&gt;items.end(),
<a name="l00397"></a>00397                                         SortBoundedItemsByOverlapEnlargement&lt;NodeItem&gt;(bound)); 
<a name="l00398"></a>00398                         }
<a name="l00399"></a>00399                 }
<a name="l00400"></a>00400                 <span class="keywordflow">else</span> <span class="comment">// if the chlld pointers in N do not point to leaves</span>
<a name="l00401"></a>00401                 {
<a name="l00402"></a>00402                         <span class="comment">// [determine the minimum area cost],</span>
<a name="l00403"></a>00403                         <span class="comment">// choose the leaf in N whose rectangle needs least</span>
<a name="l00404"></a>00404                         <span class="comment">// area enlargement to include the new data</span>
<a name="l00405"></a>00405                         <span class="comment">// rectangle. Resolve ties by choosing the leaf</span>
<a name="l00406"></a>00406                         <span class="comment">// with the rectangle of smallest area</span>
<a name="l00407"></a>00407                                 
<a name="l00408"></a>00408                         next_item =     std::min_element( node-&gt;items.begin(), node-&gt;items.end(),
<a name="l00409"></a>00409                                         SortBoundedItemsByAreaEnlargement&lt;NodeItem&gt;(bound));
<a name="l00410"></a>00410                 }
<a name="l00411"></a>00411                 
<a name="l00412"></a>00412                 <span class="comment">// I4: Adjust all covering rectangles in the insertion path</span>
<a name="l00413"></a>00413                 <span class="comment">// such that they are minimum bounding boxes</span>
<a name="l00414"></a>00414                 <span class="comment">// enclosing the children rectangles</span>
<a name="l00415"></a>00415                 next_item-&gt;key.stretch(bound);
<a name="l00416"></a>00416                 node-&gt;is_dirty = <span class="keyword">true</span>;
<a name="l00417"></a>00417                 
<a name="l00418"></a>00418                 <span class="keywordflow">return</span> next_item-&gt;id;
<a name="l00419"></a>00419         }
<a name="l00420"></a>00420         
<a name="l00421"></a>00421         <span class="keyword">struct </span>OverflowItem {
<a name="l00422"></a>00422                 BoundingBox oldBound;                   <span class="comment">// bound for the old item, to be updated</span>
<a name="l00423"></a>00423                 NodeItem * splitItem;                   <span class="comment">// the new item to add to that level</span>
<a name="l00424"></a>00424                 LeafItemArray removed_items;
<a name="l00425"></a>00425 
<a name="l00426"></a>00426                 OverflowItem(<span class="keyword">const</span> BoundingBox &amp;b, NodeItem * i) :
<a name="l00427"></a>00427                         oldBound(b), splitItem(i) {}
<a name="l00428"></a>00428 
<a name="l00429"></a>00429                 ~OverflowItem() { <span class="keywordflow">if</span> (splitItem) <span class="keyword">delete</span> splitItem; }
<a name="l00430"></a>00430         };
<a name="l00431"></a>00431         
<a name="l00432"></a>00432         <span class="comment">// inserts nodes recursively. As an optimization, the algorithm steps are</span>
<a name="l00433"></a>00433         <span class="comment">// way out of order. :) If this returns something, then that item should</span>
<a name="l00434"></a>00434         <span class="comment">// be added to the caller's level of the tree and then the object should</span>
<a name="l00435"></a>00435         <span class="comment">// be deleted</span>
<a name="l00436"></a>00436         OverflowItem * InsertInternal(
<a name="l00437"></a>00437                 <span class="keyword">const</span> LeafItem &amp;leafItem, 
<a name="l00438"></a>00438                 <span class="keyword">const</span> IdType node_id,
<a name="l00439"></a>00439                 <span class="keyword">const</span> std::size_t level, 
<a name="l00440"></a>00440                 <span class="keyword">const</span> <span class="keywordtype">bool</span> firstInsert = <span class="keyword">true</span>)
<a name="l00441"></a>00441         {
<a name="l00442"></a>00442                 <span class="comment">// normally we would stretch the rectangle of the retrieved</span>
<a name="l00443"></a>00443                 <span class="comment">// node here. However, we shall assume that it has already</span>
<a name="l00444"></a>00444                 <span class="comment">// been done for us (when the decent to the next level occurs),</span>
<a name="l00445"></a>00445                 <span class="comment">// since that value is stored in the level above (it is done in</span>
<a name="l00446"></a>00446                 <span class="comment">// ChooseSubTree)</span>
<a name="l00447"></a>00447                 
<a name="l00448"></a>00448                 <span class="comment">// CS2: If we're at a leaf, then use that level</span>
<a name="l00449"></a>00449                 <span class="keywordflow">if</span> (level == backend.m_treeHeight)
<a name="l00450"></a>00450                 {
<a name="l00451"></a>00451                         LeafNode * node = backend.get_leaf_node(node_id);
<a name="l00452"></a>00452                         
<a name="l00453"></a>00453                         <span class="comment">// make sure there are no errors</span>
<a name="l00454"></a>00454                         <span class="keywordflow">if</span> (!node) { SET_BAD_ERROR(ERR_GET_LEAFNODE); <span class="keywordflow">return</span> NULL; }
<a name="l00455"></a>00455                         
<a name="l00456"></a>00456                         assert(!node-&gt;items.empty());
<a name="l00457"></a>00457                 
<a name="l00458"></a>00458                         <span class="comment">// I2: If N has less than M items, accommodate E in N</span>
<a name="l00459"></a>00459                         node-&gt;items.push_back(leafItem);
<a name="l00460"></a>00460                         node-&gt;is_dirty = <span class="keyword">true</span>;
<a name="l00461"></a>00461                         
<a name="l00462"></a>00462                         <span class="comment">// see if we need to deal with overflow on this node: this is step I3</span>
<a name="l00463"></a>00463                         <span class="keywordflow">return</span> OverflowTreatment(node, level, firstInsert);
<a name="l00464"></a>00464                 }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466                 <span class="comment">// I1: Invoke ChooseSubtree. with the level as a parameter,</span>
<a name="l00467"></a>00467                 <span class="comment">// to find an appropriate node N, m which to place the</span>
<a name="l00468"></a>00468                 <span class="comment">// new leaf E</span>
<a name="l00469"></a>00469         
<a name="l00470"></a>00470                 <span class="comment">// grab the node from the cache</span>
<a name="l00471"></a>00471                 Node * node = backend.get_node(node_id);
<a name="l00472"></a>00472                 
<a name="l00473"></a>00473                 <span class="keywordflow">if</span> (!node) { SET_BAD_ERROR( ERR_GET_NODE ); <span class="keywordflow">return</span> NULL; }
<a name="l00474"></a>00474                 
<a name="l00475"></a>00475                 assert(!node-&gt;items.empty());
<a name="l00476"></a>00476         
<a name="l00477"></a>00477                 <span class="comment">// ChooseSubtree also does I4</span>
<a name="l00478"></a>00478                 IdType selected_id = ChooseSubtree(node, level, leafItem.key);
<a name="l00479"></a>00479         
<a name="l00480"></a>00480                 <span class="comment">// of course, this already does all of that recursively. we just need to</span>
<a name="l00481"></a>00481                 <span class="comment">// determine whether we need to split the overflow or not</span>
<a name="l00482"></a>00482                 OverflowItem * overflowItem = InsertInternal( 
<a name="l00483"></a>00483                         leafItem, 
<a name="l00484"></a>00484                         selected_id, 
<a name="l00485"></a>00485                         level+1, 
<a name="l00486"></a>00486                         firstInsert );
<a name="l00487"></a>00487 
<a name="l00488"></a>00488                 
<a name="l00489"></a>00489                 <span class="keywordflow">if</span> (!overflowItem)
<a name="l00490"></a>00490                         <span class="keywordflow">return</span> NULL;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492                 <span class="comment">// finish any overflow stuff that is pending</span>
<a name="l00493"></a>00493                 node = FinishOverflowOperation(overflowItem, node_id, selected_id);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495                 <span class="comment">// see if we need to deal with overflow on this node: this is step I3</span>
<a name="l00496"></a>00496                 <span class="keywordflow">return</span> OverflowTreatment(node, level, firstInsert);
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498         
<a name="l00499"></a>00499 
<a name="l00500"></a>00500         <span class="comment">// this may invalidate the node passed to it</span>
<a name="l00501"></a>00501         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodeType&gt;
<a name="l00502"></a>00502         OverflowItem * OverflowTreatment(
<a name="l00503"></a>00503                 NodeType * node, 
<a name="l00504"></a>00504                 <span class="keyword">const</span> std::size_t &amp;level, 
<a name="l00505"></a>00505                 <span class="keywordtype">bool</span> firstInsert)
<a name="l00506"></a>00506         {
<a name="l00507"></a>00507                 <span class="comment">// If N has M+1 items. invoke OverflowTreatment with the</span>
<a name="l00508"></a>00508                 <span class="comment">// level of N as a parameter [for reinsertion or split]</span>
<a name="l00509"></a>00509                 <span class="keywordflow">if</span> (node-&gt;items.size() &lt;= max_child_items )
<a name="l00510"></a>00510                         <span class="keywordflow">return</span> NULL;
<a name="l00511"></a>00511         
<a name="l00512"></a>00512                 <span class="comment">// I3: If OverflowTreatment was called and a split was</span>
<a name="l00513"></a>00513                 <span class="comment">// performed, propagate OverflowTreatment upwards</span>
<a name="l00514"></a>00514                 <span class="comment">// if necessary (this is done with the return values)</span>
<a name="l00515"></a>00515         
<a name="l00516"></a>00516                 <span class="comment">// OT1: If the level is not the root level AND this is the first</span>
<a name="l00517"></a>00517                 <span class="comment">// call of OverflowTreatment in the given level during the </span>
<a name="l00518"></a>00518                 <span class="comment">// insertion of one data rectangle, then invoke Reinsert</span>
<a name="l00519"></a>00519                 <span class="keywordflow">if</span> (level != 1 &amp;&amp; firstInsert)
<a name="l00520"></a>00520                 {
<a name="l00521"></a>00521                         assert(level == backend.m_treeHeight);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523                         <span class="comment">// this is a really ugly cast, but its perfectly valid</span>
<a name="l00524"></a>00524                         <span class="comment">// because the NodeType is a template and it will always be a</span>
<a name="l00525"></a>00525                         <span class="comment">// LeafNode if the assert() doesn't fail</span>
<a name="l00526"></a>00526                         <span class="keywordflow">return</span> QueueReinsert( (LeafNode*) (NodeBase*) node);
<a name="l00527"></a>00527                 }
<a name="l00528"></a>00528                 
<a name="l00529"></a>00529                 OverflowItem * overflowItem = Split(node, level);
<a name="l00530"></a>00530                 
<a name="l00531"></a>00531                 <span class="comment">// check to see if we are splitting the root</span>
<a name="l00532"></a>00532                 <span class="keywordflow">if</span> (level == 1)
<a name="l00533"></a>00533                         <span class="keywordflow">return</span> SplitRoot(overflowItem);
<a name="l00534"></a>00534                 
<a name="l00535"></a>00535                 <span class="keywordflow">return</span> overflowItem;
<a name="l00536"></a>00536         }
<a name="l00537"></a>00537         
<a name="l00546"></a>00546         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodeType&gt;
<a name="l00547"></a>00547         OverflowItem * Split(NodeType * node, <span class="keyword">const</span> std::size_t &amp;level)
<a name="l00548"></a>00548         {
<a name="l00549"></a>00549                 <span class="comment">// If N has M+1 items, split the node</span>
<a name="l00550"></a>00550                 <span class="keywordflow">if</span> (node-&gt;items.size() &lt;= max_child_items )
<a name="l00551"></a>00551                         <span class="keywordflow">return</span> NULL;
<a name="l00552"></a>00552         
<a name="l00553"></a>00553                 <span class="comment">// this should always hold true</span>
<a name="l00554"></a>00554                 assert(node-&gt;items.size() == max_child_items + 1);
<a name="l00555"></a>00555         
<a name="l00556"></a>00556                 <span class="comment">// this will be true soon</span>
<a name="l00557"></a>00557                 node-&gt;is_dirty = <span class="keyword">true</span>;
<a name="l00558"></a>00558         
<a name="l00559"></a>00559                 <span class="comment">// create a new node id</span>
<a name="l00560"></a>00560                 IdType new_id;
<a name="l00561"></a>00561                 NodeBase * tmp;
<a name="l00562"></a>00562                 
<a name="l00563"></a>00563                 <span class="comment">// do it this way to avoid compile errors.. </span>
<a name="l00564"></a>00564                 <span class="keywordflow">if</span> (level == backend.m_treeHeight)
<a name="l00565"></a>00565                 {
<a name="l00566"></a>00566                         new_id =        backend.new_leaf_node_id();
<a name="l00567"></a>00567                         tmp =           backend.create_leaf_node(new_id);
<a name="l00568"></a>00568                 }
<a name="l00569"></a>00569                 <span class="keywordflow">else</span>
<a name="l00570"></a>00570                 {
<a name="l00571"></a>00571                         new_id =        backend.new_node_id();
<a name="l00572"></a>00572                         tmp =           backend.create_node(new_id);
<a name="l00573"></a>00573                 }
<a name="l00574"></a>00574                 
<a name="l00575"></a>00575                 <span class="keywordflow">if</span> (!tmp) { SET_BAD_ERROR( ERR_CREATE_NODE_IN_SPLIT ); <span class="keywordflow">return</span> NULL;}
<a name="l00576"></a>00576                 
<a name="l00577"></a>00577                 <span class="comment">// cast it to the proper type</span>
<a name="l00578"></a>00578                 NodeType * new_node = <span class="keyword">static_cast&lt;</span>NodeType*<span class="keyword">&gt;</span>(tmp);
<a name="l00579"></a>00579                 
<a name="l00580"></a>00580 
<a name="l00581"></a>00581                 <span class="keyword">const</span> size_type n_items = node-&gt;items.size();
<a name="l00582"></a>00582                 <span class="keyword">const</span> size_type distribution_count = n_items - 2*min_child_items + 1;
<a name="l00583"></a>00583                 
<a name="l00584"></a>00584                 size_type split_axis = dimensions+1, split_edge = 0, split_index = 0;
<a name="l00585"></a>00585                 <span class="keywordtype">int</span> split_margin = 0;
<a name="l00586"></a>00586                 
<a name="l00587"></a>00587                 BoundingBox R1, R2;
<a name="l00588"></a>00588 
<a name="l00589"></a>00589                 <span class="comment">// these should always hold true</span>
<a name="l00590"></a>00590                 assert(distribution_count &gt; 0);
<a name="l00591"></a>00591                 assert(min_child_items + distribution_count-1 &lt;= n_items);
<a name="l00592"></a>00592                 
<a name="l00593"></a>00593                 <span class="comment">// S1: Invoke ChooseSplitAxis to determine the axis,</span>
<a name="l00594"></a>00594                 <span class="comment">// perpendicular to which the split 1s performed</span>
<a name="l00595"></a>00595                 <span class="comment">// S2: Invoke ChooseSplitIndex to determine the best</span>
<a name="l00596"></a>00596                 <span class="comment">// distribution into two groups along that axis</span>
<a name="l00597"></a>00597                 
<a name="l00598"></a>00598                 <span class="comment">// NOTE: We don't compare against node-&gt;bound, so it gets overwritten</span>
<a name="l00599"></a>00599                 <span class="comment">// at the end of the loop</span>
<a name="l00600"></a>00600                 
<a name="l00601"></a>00601                 <span class="comment">// CSA1: For each axis</span>
<a name="l00602"></a>00602                 <span class="keywordflow">for</span> (size_type axis = 0; axis &lt; dimensions; axis++)
<a name="l00603"></a>00603                 {
<a name="l00604"></a>00604                         <span class="comment">// initialize per-loop items</span>
<a name="l00605"></a>00605                         <span class="keywordtype">int</span> margin = 0;
<a name="l00606"></a>00606                         <span class="keywordtype">double</span> overlap = 0, dist_area, dist_overlap;
<a name="l00607"></a>00607                         size_type dist_edge = 0, dist_index = 0;
<a name="l00608"></a>00608                 
<a name="l00609"></a>00609                         dist_area = dist_overlap = std::numeric_limits&lt;double&gt;::max();
<a name="l00610"></a>00610                         
<a name="l00611"></a>00611                         
<a name="l00612"></a>00612                         <span class="comment">// Sort the items by the lower then by the upper</span>
<a name="l00613"></a>00613                         <span class="comment">// edge of their bounding box on this particular axis and </span>
<a name="l00614"></a>00614                         <span class="comment">// determine all distributions as described . Compute S. the</span>
<a name="l00615"></a>00615                         <span class="comment">// sum of all margin-values of the different</span>
<a name="l00616"></a>00616                         <span class="comment">// distributions</span>
<a name="l00617"></a>00617                 
<a name="l00618"></a>00618                         <span class="comment">// lower edge == 0, upper edge = 1</span>
<a name="l00619"></a>00619                         <span class="keywordflow">for</span> (size_type edge = 0; edge &lt; 2; edge++)
<a name="l00620"></a>00620                         {
<a name="l00621"></a>00621                                 <span class="comment">// sort the items by the correct key (upper edge, lower edge)</span>
<a name="l00622"></a>00622                                 <span class="keywordflow">if</span> (edge == 0)
<a name="l00623"></a>00623                                         std::sort(node-&gt;items.begin(), node-&gt;items.end(), SortBoundedItemsByFirstEdge&lt;typename NodeType::Item&gt;(axis));
<a name="l00624"></a>00624                                 <span class="keywordflow">else</span>
<a name="l00625"></a>00625                                         std::sort(node-&gt;items.begin(), node-&gt;items.end(), SortBoundedItemsBySecondEdge&lt;typename NodeType::Item&gt;(axis));
<a name="l00626"></a>00626                 
<a name="l00627"></a>00627                                 <span class="comment">// Distributions: pick a point m in the middle of the thing, call the left</span>
<a name="l00628"></a>00628                                 <span class="comment">// R1 and the right R2. Calculate the bounding box of R1 and R2, then </span>
<a name="l00629"></a>00629                                 <span class="comment">// calculate the margins. Then do it again for some more points </span>
<a name="l00630"></a>00630                                 <span class="keywordflow">for</span> (size_type k = 0; k &lt; distribution_count; k++)
<a name="l00631"></a>00631                         {
<a name="l00632"></a>00632                                         <span class="keywordtype">double</span> area = 0;
<a name="l00633"></a>00633                                 
<a name="l00634"></a>00634                                         <span class="comment">// calculate bounding box of R1</span>
<a name="l00635"></a>00635                                         R1.reset();
<a name="l00636"></a>00636                                         std::for_each(node-&gt;items.begin(), node-&gt;items.begin()+(min_child_items+k), StretchBoundingBox&lt;typename NodeType::Item&gt;(&amp;R1));
<a name="l00637"></a>00637                                                         
<a name="l00638"></a>00638                                         <span class="comment">// then do the same for R2</span>
<a name="l00639"></a>00639                                         R2.reset();
<a name="l00640"></a>00640                                         std::for_each(node-&gt;items.begin()+(min_child_items+k+1), node-&gt;items.end(), StretchBoundingBox&lt;typename NodeType::Item&gt;(&amp;R2));
<a name="l00641"></a>00641                                         
<a name="l00642"></a>00642                                         
<a name="l00643"></a>00643                                         <span class="comment">// calculate the three values</span>
<a name="l00644"></a>00644                                         margin  += R1.edgeDeltas() + R2.edgeDeltas();
<a name="l00645"></a>00645                                         area    += R1.area() + R2.area();               <span class="comment">// TODO: need to subtract.. overlap?</span>
<a name="l00646"></a>00646                                         overlap =  R1.overlap(R2);
<a name="l00647"></a>00647                                         
<a name="l00648"></a>00648                                         
<a name="l00649"></a>00649                                         <span class="comment">// CSI1: Along the split axis, choose the distribution with the </span>
<a name="l00650"></a>00650                                         <span class="comment">// minimum overlap-value. Resolve ties by choosing the distribution</span>
<a name="l00651"></a>00651                                         <span class="comment">// with minimum area-value. </span>
<a name="l00652"></a>00652                                         <span class="keywordflow">if</span> (overlap &lt; dist_overlap || (overlap == dist_overlap &amp;&amp; area &lt; dist_area))
<a name="l00653"></a>00653                                         {
<a name="l00654"></a>00654                                                 <span class="comment">// if so, store the parameters that allow us to recreate it at the end</span>
<a name="l00655"></a>00655                                                 dist_edge =     edge;
<a name="l00656"></a>00656                                                 dist_index =    min_child_items+k;
<a name="l00657"></a>00657                                                 dist_overlap =  overlap;
<a name="l00658"></a>00658                                                 dist_area =     area;
<a name="l00659"></a>00659                                         }               
<a name="l00660"></a>00660                                 }
<a name="l00661"></a>00661                         }
<a name="l00662"></a>00662                         
<a name="l00663"></a>00663                         <span class="comment">// CSA2: Choose the axis with the minimum S as split axis</span>
<a name="l00664"></a>00664                         <span class="keywordflow">if</span> (split_axis == dimensions+1 || split_margin &gt; margin )
<a name="l00665"></a>00665                         {
<a name="l00666"></a>00666                                 split_axis              = axis;
<a name="l00667"></a>00667                                 split_margin    = margin;
<a name="l00668"></a>00668                                 split_edge              = dist_edge;
<a name="l00669"></a>00669                                 split_index     = dist_index;
<a name="l00670"></a>00670                         }
<a name="l00671"></a>00671                 }
<a name="l00672"></a>00672         
<a name="l00673"></a>00673                 <span class="comment">// S3: Distribute the items into two groups</span>
<a name="l00674"></a>00674         
<a name="l00675"></a>00675                 <span class="comment">// ok, we're done, and the best distribution on the selected split</span>
<a name="l00676"></a>00676                 <span class="comment">// axis has been recorded, so we just have to recreate it and</span>
<a name="l00677"></a>00677                 <span class="comment">// return the correct index</span>
<a name="l00678"></a>00678                 
<a name="l00679"></a>00679                 <span class="keywordflow">if</span> (split_edge == 0)
<a name="l00680"></a>00680                         std::sort(node-&gt;items.begin(), node-&gt;items.end(), SortBoundedItemsByFirstEdge&lt;typename NodeType::Item&gt;(split_axis));
<a name="l00681"></a>00681 
<a name="l00682"></a>00682                 <span class="comment">// only reinsert the sort key if we have to</span>
<a name="l00683"></a>00683                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (split_axis != dimensions-1)
<a name="l00684"></a>00684                         std::sort(node-&gt;items.begin(), node-&gt;items.end(), SortBoundedItemsBySecondEdge&lt;typename NodeType::Item&gt;(split_axis));   
<a name="l00685"></a>00685                 
<a name="l00686"></a>00686                 <span class="comment">// distribute the end of the array to the new node, then erase them from the original node</span>
<a name="l00687"></a>00687                 new_node-&gt;items.assign(node-&gt;items.begin() + split_index, node-&gt;items.end());
<a name="l00688"></a>00688                 node-&gt;items.erase(node-&gt;items.begin() + split_index, node-&gt;items.end());
<a name="l00689"></a>00689                 
<a name="l00690"></a>00690                 <span class="comment">// adjust the bounding box for each node resulting from the split</span>
<a name="l00691"></a>00691                 BoundingBox new_node_bound;
<a name="l00692"></a>00692                 new_node_bound.reset();
<a name="l00693"></a>00693                 std::for_each(new_node-&gt;items.begin(), new_node-&gt;items.end(), StretchBoundingBox&lt;typename NodeType::Item&gt;(&amp;new_node_bound));
<a name="l00694"></a>00694 
<a name="l00695"></a>00695                 BoundingBox old_node_bound;
<a name="l00696"></a>00696                 old_node_bound.reset();
<a name="l00697"></a>00697                 std::for_each(node-&gt;items.begin(), node-&gt;items.end(), StretchBoundingBox&lt;typename NodeType::Item&gt;(&amp;old_node_bound));
<a name="l00698"></a>00698 
<a name="l00699"></a>00699                 <span class="comment">// return the item that needs to be added to the level above </span>
<a name="l00700"></a>00700                 <span class="keywordflow">return</span> <span class="keyword">new</span> OverflowItem(old_node_bound, <span class="keyword">new</span> NodeItem(new_node_bound, new_id));
<a name="l00701"></a>00701         }
<a name="l00702"></a>00702         
<a name="l00703"></a>00703         
<a name="l00704"></a>00704         <span class="comment">// If OverflowTreatment caused a split of the root, create a new root</span>
<a name="l00705"></a>00705         OverflowItem * SplitRoot(OverflowItem * overflowItem )
<a name="l00706"></a>00706         {
<a name="l00707"></a>00707                 <span class="comment">// retain the id of the old root</span>
<a name="l00708"></a>00708                 IdType old_root_id = backend.m_rootId;
<a name="l00709"></a>00709                 
<a name="l00710"></a>00710                 <span class="comment">// create a new root node</span>
<a name="l00711"></a>00711                 <span class="keywordflow">if</span> (!backend.create_root_node())
<a name="l00712"></a>00712                 {
<a name="l00713"></a>00713                         SET_BAD_ERROR( ERR_CREATE_SPLIT_ROOT );
<a name="l00714"></a>00714                         <span class="keywordflow">return</span> NULL;
<a name="l00715"></a>00715                 }
<a name="l00716"></a>00716                 
<a name="l00717"></a>00717                 <span class="comment">// if we split the root -- it will always be a node</span>
<a name="l00718"></a>00718                 Node * root = backend.get_node(backend.m_rootId);
<a name="l00719"></a>00719 
<a name="l00720"></a>00720                 <span class="keywordflow">if</span> (!root) { SET_BAD_ERROR( ERR_GET_SPLIT_ROOT ); <span class="keywordflow">return</span> NULL; }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722                 <span class="comment">// fill in the new root using the information in overflowItem,</span>
<a name="l00723"></a>00723                 <span class="comment">// the old root gets the 'old' bound, and the other split item</span>
<a name="l00724"></a>00724                 <span class="comment">// is inserted after that</span>
<a name="l00725"></a>00725                 root-&gt;items.push_back(NodeItem(overflowItem-&gt;oldBound, old_root_id));
<a name="l00726"></a>00726                 root-&gt;items.push_back(*(overflowItem-&gt;splitItem));
<a name="l00727"></a>00727                 root-&gt;is_dirty = <span class="keyword">true</span>;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729                 <span class="comment">// and done</span>
<a name="l00730"></a>00730                 <span class="keyword">delete</span> overflowItem;
<a name="l00731"></a>00731                 <span class="keywordflow">return</span> NULL;
<a name="l00732"></a>00732         }
<a name="l00733"></a>00733         
<a name="l00734"></a>00734         
<a name="l00735"></a>00735         <span class="comment">// This routine is used to queue the opportunistic reinsertion that the</span>
<a name="l00736"></a>00736         <span class="comment">// R* algorithm calls for</span>
<a name="l00737"></a>00737         OverflowItem * QueueReinsert(LeafNode * node)
<a name="l00738"></a>00738         {
<a name="l00739"></a>00739                 OverflowItem * overflowItem = <span class="keyword">new</span> OverflowItem(BoundingBox(), NULL);
<a name="l00740"></a>00740 
<a name="l00741"></a>00741                 <span class="keyword">const</span> size_type n_items = node-&gt;items.size();
<a name="l00742"></a>00742                 <span class="keyword">const</span> size_type p = (size_type)((<span class="keywordtype">double</span>)n_items * RTREE_REINSERT_P) &gt; 0 ? (size_type)((double)n_items * RTREE_REINSERT_P) : 1;
<a name="l00743"></a>00743                 
<a name="l00744"></a>00744                 <span class="comment">// RI1 For all M+l items of a node N, compute the distance</span>
<a name="l00745"></a>00745                 <span class="comment">// between the centers of their rectangles and the center</span>
<a name="l00746"></a>00746                 <span class="comment">// of the bounding rectangle of N</span>
<a name="l00747"></a>00747                 assert(n_items == max_child_items + 1);
<a name="l00748"></a>00748 
<a name="l00749"></a>00749                 <span class="comment">// recompute this, since we don't have the bounding box for N</span>
<a name="l00750"></a>00750                 <span class="comment">// (though it exists somewhere, we can't guarantee it will</span>
<a name="l00751"></a>00751                 <span class="comment">// still exist by the time we get here)</span>
<a name="l00752"></a>00752                 BoundingBox bound;
<a name="l00753"></a>00753                 bound.reset();
<a name="l00754"></a>00754                 std::for_each(node-&gt;items.begin(), node-&gt;items.end(), StretchBoundingBox&lt;LeafItem&gt;(&amp;bound));
<a name="l00755"></a>00755                 
<a name="l00756"></a>00756                 <span class="comment">// RI2: Sort the items in increasing order of their distances</span>
<a name="l00757"></a>00757                 <span class="comment">// computed in RI1</span>
<a name="l00758"></a>00758                 std::partial_sort(node-&gt;items.begin(), node-&gt;items.end() - p, node-&gt;items.end(), 
<a name="l00759"></a>00759                         SortBoundedItemsByDistanceFromCenter&lt;LeafItem&gt;(bound));
<a name="l00760"></a>00760                         
<a name="l00761"></a>00761                 <span class="comment">// RI3.A: Remove the last p items from N</span>
<a name="l00762"></a>00762                 overflowItem-&gt;removed_items.assign(node-&gt;items.end() - p, node-&gt;items.end());
<a name="l00763"></a>00763                 node-&gt;items.erase(node-&gt;items.end() - p, node-&gt;items.end());
<a name="l00764"></a>00764                 
<a name="l00765"></a>00765                 node-&gt;is_dirty = <span class="keyword">true</span>;
<a name="l00766"></a>00766 
<a name="l00767"></a>00767                 <span class="comment">// RI3.B: adjust the bounding rectangle of N</span>
<a name="l00768"></a>00768                 overflowItem-&gt;oldBound.reset();
<a name="l00769"></a>00769                 std::for_each(node-&gt;items.begin(), node-&gt;items.end(), StretchBoundingBox&lt;LeafItem&gt;(&amp;overflowItem-&gt;oldBound));
<a name="l00770"></a>00770 
<a name="l00771"></a>00771                 <span class="comment">// return the information to be done later</span>
<a name="l00772"></a>00772                 <span class="keywordflow">return</span> overflowItem;
<a name="l00773"></a>00773         }
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 
<a name="l00778"></a>00778         <span class="comment">/*</span>
<a name="l00779"></a>00779 <span class="comment">                Used by InsertInternal to finish off any overflow operation</span>
<a name="l00780"></a>00780 <span class="comment"></span>
<a name="l00781"></a>00781 <span class="comment">                The reason this exists is because split() and reinsert() both</span>
<a name="l00782"></a>00782 <span class="comment">                require the 'current' node bounding box to be modified, and </span>
<a name="l00783"></a>00783 <span class="comment">                the bounding box does not reside on the node itself, but in </span>
<a name="l00784"></a>00784 <span class="comment">                its parent. </span>
<a name="l00785"></a>00785 <span class="comment"></span>
<a name="l00786"></a>00786 <span class="comment">                So, this does a few things:</span>
<a name="l00787"></a>00787 <span class="comment"></span>
<a name="l00788"></a>00788 <span class="comment">                        a) always sets the bound for the item with id = id</span>
<a name="l00789"></a>00789 <span class="comment">                        </span>
<a name="l00790"></a>00790 <span class="comment">                        b) If there is a split item, it propagates the split</span>
<a name="l00791"></a>00791 <span class="comment"></span>
<a name="l00792"></a>00792 <span class="comment">                        c) If there is a list of nodes to be reinserted, then</span>
<a name="l00793"></a>00793 <span class="comment">                        it goes ahead and does the actual reinsertion</span>
<a name="l00794"></a>00794 <span class="comment"></span>
<a name="l00795"></a>00795 <span class="comment">        */</span>
<a name="l00796"></a>00796         Node * FinishOverflowOperation(OverflowItem * overflowItem, IdType node_id, IdType bound_id)
<a name="l00797"></a>00797         {
<a name="l00798"></a>00798                 Node * node = backend.get_node(node_id);
<a name="l00799"></a>00799 
<a name="l00800"></a>00800                 <span class="comment">// set the bound for the selected item</span>
<a name="l00801"></a>00801                 SearchForItemAndSetBound(node, bound_id, overflowItem);
<a name="l00802"></a>00802                         
<a name="l00803"></a>00803                 <span class="comment">// propagate the split: this gets joined to the list of items </span>
<a name="l00804"></a>00804                 <span class="comment">// at this level</span>
<a name="l00805"></a>00805                 <span class="keywordflow">if</span> (overflowItem-&gt;splitItem)
<a name="l00806"></a>00806                         node-&gt;items.push_back(*(overflowItem-&gt;splitItem));
<a name="l00807"></a>00807 
<a name="l00808"></a>00808                 node-&gt;is_dirty = <span class="keyword">true</span>;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810                 <span class="comment">// if there are items to reinsert, do so now</span>
<a name="l00811"></a>00811                 <span class="keywordflow">if</span> (!overflowItem-&gt;removed_items.empty())
<a name="l00812"></a>00812                 {
<a name="l00813"></a>00813                         <span class="comment">// RI4: In the sort, defined in RI2, starting with the </span>
<a name="l00814"></a>00814                         <span class="comment">// minimum distance (= close reinsert), invoke Insert </span>
<a name="l00815"></a>00815                         <span class="comment">// to reinsert the items</span>
<a name="l00816"></a>00816                         LeafItemIterator end = overflowItem-&gt;removed_items.end();
<a name="l00817"></a>00817                         
<a name="l00818"></a>00818                         <span class="keywordflow">for</span> (LeafItemIterator it = overflowItem-&gt;removed_items.begin(); it != end; it++)
<a name="l00819"></a>00819                                 InsertInternal( *it, backend.m_rootId, 1, <span class="keyword">false</span>);
<a name="l00820"></a>00820                                 
<a name="l00821"></a>00821                         <span class="comment">// we have to assume that the current node id may have been invalidated</span>
<a name="l00822"></a>00822                         node = backend.get_node(node_id);
<a name="l00823"></a>00823                 }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825                 <span class="keyword">delete</span> overflowItem;
<a name="l00826"></a>00826                 <span class="keywordflow">return</span> node;
<a name="l00827"></a>00827         }
<a name="l00828"></a>00828 
<a name="l00829"></a>00829 
<a name="l00830"></a>00830         <span class="comment">// used for recovering from a split</span>
<a name="l00831"></a>00831         <span class="keywordtype">void</span> SearchForItemAndSetBound(Node * node, IdType node_id, OverflowItem * overflowItem )
<a name="l00832"></a>00832         {
<a name="l00833"></a>00833                 <span class="keyword">const</span> NodeItemIterator end = node-&gt;items.end();
<a name="l00834"></a>00834                 <span class="keywordflow">for</span> (NodeItemIterator it = node-&gt;items.begin(); it != end; it++)
<a name="l00835"></a>00835                         <span class="keywordflow">if</span> (it-&gt;id == node_id)
<a name="l00836"></a>00836                         {       
<a name="l00837"></a>00837                                 it-&gt;key = overflowItem-&gt;oldBound;
<a name="l00838"></a>00838                                 <span class="keywordflow">return</span>;
<a name="l00839"></a>00839                         }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841                 assert(NULL &amp;&amp; <span class="stringliteral">"should not get here"</span>);
<a name="l00842"></a>00842         }
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         Backend         backend;
<a name="l00846"></a>00846         ErrorCode       m_lastError;    
<a name="l00847"></a>00847         
<a name="l00848"></a>00848         
<a name="l00849"></a>00849 };
<a name="l00850"></a>00850 
<a name="l00851"></a>00851 <span class="preprocessor">#undef RTREE_REINSERT_P</span>
<a name="l00852"></a>00852 <span class="preprocessor"></span><span class="preprocessor">#undef RTREE_CHOOSE_SUBTREE_P</span>
<a name="l00853"></a>00853 <span class="preprocessor"></span>
<a name="l00854"></a>00854 <span class="preprocessor">#undef SET_BAD_ERROR</span>
<a name="l00855"></a>00855 <span class="preprocessor"></span>
<a name="l00856"></a>00856 
<a name="l00857"></a>00857 <span class="preprocessor">#endif</span>
<a name="l00858"></a>00858 <span class="preprocessor"></span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Aug 18 13:28:40 2009 for libsdbx-1.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7 </small></address>
</body>
</html>
