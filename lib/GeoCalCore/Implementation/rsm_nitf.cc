#include "rsm_nitf.h"
#include "geocal_serialize_function.h"
#include "geocal_internal_config.h"
#ifdef HAVE_CXX11
#include <boost/process/child.hpp>
#include <boost/process/io.hpp>
#define HAVE_BOOST_PROCESS
#endif
using namespace GeoCal;

//-----------------------------------------------------------------------
/// We have support for saving RSMs as boost XML serialization
/// objects. This works well, but this is not an official standard. It
/// is useful to use a official standard for saving data, so we use
/// the RSM NITF standard, such as:
/// "Replacement Sensor Model Tagged Record Extensions Specification for NITF
/// 2.1" (http://www.gwg.nga.mil/ntb/baseline/docs/RSM/RSM_NITF_TREs_v1.0_.pdf)
///
/// While we could implement this entirely in C++, it is tricky to
/// handle everything. We already have an implementation in
/// python. This function uses a simple wrapper program that goes to
/// and from a NITF file, using python (boost_nitf_rsm). This should
/// be sufficient, we can always revisit this if there is an issue
/// with performance or the python dependency. But for now, we just
/// route the RSM through a system call.
///
/// This writes the given Rsm to a NITF file with the same name. The
/// NITF file has a single image segment in it with a size of 1x1, and
/// the TREs attached to the image segment supply the RSM.
//-----------------------------------------------------------------------

void GeoCal::rsm_write_nitf(const std::string& Fname,
		    const boost::shared_ptr<Rsm>& R)
{
#ifdef HAVE_BOOST_PROCESS
  std::string data = serialize_write_binary(R);
  boost::process::opstream in;
  boost::process::child c("boost_nitf_rsm to_nitf " + Fname,
			  boost::process::std_in < in);
  in << data;
  c.wait();
#else
  throw Exception("rsm_write_nitf needs to have boost::process available (which in turn requires CXX11 support");
#endif
}

//-----------------------------------------------------------------------
/// We have support for saving RSMs as boost XML serialization
/// objects. This works well, but this is not an official standard. It
/// is useful to use a official standard for saving data, so we use
/// the RSM NITF standard, such as:
/// "Replacement Sensor Model Tagged Record Extensions Specification for NITF
/// 2.1" (http://www.gwg.nga.mil/ntb/baseline/docs/RSM/RSM_NITF_TREs_v1.0_.pdf)
///
/// While we could implement this entirely in C++, it is tricky to
/// handle everything. We already have an implementation in
/// python. This function uses a simple wrapper program that goes to
/// and from a NITF file, using python (boost_nitf_rsm). This should
/// be sufficient, we can always revisit this if there is an issue
/// with performance or the python dependency. But for now, we just
/// route the RSM through a system call.
///
/// This reads a NITF file generated by rsm_write_nitf. We just take
/// the first image segment found in the file, and RSM defined by that
/// image segments TREs.
//-----------------------------------------------------------------------

boost::shared_ptr<Rsm> GeoCal::rsm_read_nitf(const std::string& Fname)
{
}
