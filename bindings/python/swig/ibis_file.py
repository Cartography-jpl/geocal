# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _ibis_file.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ibis_file', [dirname(__file__)])
        except ImportError:
            import _ibis_file
            return _ibis_file
        if fp is not None:
            try:
                _mod = imp.load_module('_ibis_file', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ibis_file = swig_import_helper()
    del swig_import_helper
else:
    import _ibis_file
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _ibis_file.SHARED_PTR_DISOWN
def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import numpy as np

import geocal_swig.generic_object
class IbisColumn_byte(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _ibis_file.IbisColumn_byte_ibis_file(self)

    def _v_column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _ibis_file.IbisColumn_byte__v_column_index(self)

    @property
    def column_index(self):
        return self._v_column_index()

    def _v_size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _ibis_file.IbisColumn_byte__v_size_byte(self)

    @property
    def size_byte(self):
        return self._v_size_byte()

    data = _swig_property(_ibis_file.IbisColumn_byte_data_get, _ibis_file.IbisColumn_byte_data_set)
    update = _swig_property(_ibis_file.IbisColumn_byte_update_get, _ibis_file.IbisColumn_byte_update_set)
    def __getitem__(self, i):
      return self.data[i]

    def __setitem__(self, i, v):
      self.update = True
      self.data[i] = v

      
    __swig_destroy__ = _ibis_file.delete_IbisColumn_byte
IbisColumn_byte.ibis_file = new_instancemethod(_ibis_file.IbisColumn_byte_ibis_file,None,IbisColumn_byte)
IbisColumn_byte._v_column_index = new_instancemethod(_ibis_file.IbisColumn_byte__v_column_index,None,IbisColumn_byte)
IbisColumn_byte._v_size_byte = new_instancemethod(_ibis_file.IbisColumn_byte__v_size_byte,None,IbisColumn_byte)
IbisColumn_byte.__str__ = new_instancemethod(_ibis_file.IbisColumn_byte___str__,None,IbisColumn_byte)
IbisColumn_byte_swigregister = _ibis_file.IbisColumn_byte_swigregister
IbisColumn_byte_swigregister(IbisColumn_byte)

class IbisColumn_half(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _ibis_file.IbisColumn_half_ibis_file(self)

    def _v_column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _ibis_file.IbisColumn_half__v_column_index(self)

    @property
    def column_index(self):
        return self._v_column_index()

    def _v_size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _ibis_file.IbisColumn_half__v_size_byte(self)

    @property
    def size_byte(self):
        return self._v_size_byte()

    data = _swig_property(_ibis_file.IbisColumn_half_data_get, _ibis_file.IbisColumn_half_data_set)
    update = _swig_property(_ibis_file.IbisColumn_half_update_get, _ibis_file.IbisColumn_half_update_set)
    def __getitem__(self, i):
      return self.data[i]

    def __setitem__(self, i, v):
      self.update = True
      self.data[i] = v

      
    __swig_destroy__ = _ibis_file.delete_IbisColumn_half
IbisColumn_half.ibis_file = new_instancemethod(_ibis_file.IbisColumn_half_ibis_file,None,IbisColumn_half)
IbisColumn_half._v_column_index = new_instancemethod(_ibis_file.IbisColumn_half__v_column_index,None,IbisColumn_half)
IbisColumn_half._v_size_byte = new_instancemethod(_ibis_file.IbisColumn_half__v_size_byte,None,IbisColumn_half)
IbisColumn_half.__str__ = new_instancemethod(_ibis_file.IbisColumn_half___str__,None,IbisColumn_half)
IbisColumn_half_swigregister = _ibis_file.IbisColumn_half_swigregister
IbisColumn_half_swigregister(IbisColumn_half)

class IbisColumn_full(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _ibis_file.IbisColumn_full_ibis_file(self)

    def _v_column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _ibis_file.IbisColumn_full__v_column_index(self)

    @property
    def column_index(self):
        return self._v_column_index()

    def _v_size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _ibis_file.IbisColumn_full__v_size_byte(self)

    @property
    def size_byte(self):
        return self._v_size_byte()

    data = _swig_property(_ibis_file.IbisColumn_full_data_get, _ibis_file.IbisColumn_full_data_set)
    update = _swig_property(_ibis_file.IbisColumn_full_update_get, _ibis_file.IbisColumn_full_update_set)
    def __getitem__(self, i):
      return self.data[i]

    def __setitem__(self, i, v):
      self.update = True
      self.data[i] = v

      
    __swig_destroy__ = _ibis_file.delete_IbisColumn_full
IbisColumn_full.ibis_file = new_instancemethod(_ibis_file.IbisColumn_full_ibis_file,None,IbisColumn_full)
IbisColumn_full._v_column_index = new_instancemethod(_ibis_file.IbisColumn_full__v_column_index,None,IbisColumn_full)
IbisColumn_full._v_size_byte = new_instancemethod(_ibis_file.IbisColumn_full__v_size_byte,None,IbisColumn_full)
IbisColumn_full.__str__ = new_instancemethod(_ibis_file.IbisColumn_full___str__,None,IbisColumn_full)
IbisColumn_full_swigregister = _ibis_file.IbisColumn_full_swigregister
IbisColumn_full_swigregister(IbisColumn_full)

class IbisColumn_float(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _ibis_file.IbisColumn_float_ibis_file(self)

    def _v_column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _ibis_file.IbisColumn_float__v_column_index(self)

    @property
    def column_index(self):
        return self._v_column_index()

    def _v_size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _ibis_file.IbisColumn_float__v_size_byte(self)

    @property
    def size_byte(self):
        return self._v_size_byte()

    data = _swig_property(_ibis_file.IbisColumn_float_data_get, _ibis_file.IbisColumn_float_data_set)
    update = _swig_property(_ibis_file.IbisColumn_float_update_get, _ibis_file.IbisColumn_float_update_set)
    def __getitem__(self, i):
      return self.data[i]

    def __setitem__(self, i, v):
      self.update = True
      self.data[i] = v

      
    __swig_destroy__ = _ibis_file.delete_IbisColumn_float
IbisColumn_float.ibis_file = new_instancemethod(_ibis_file.IbisColumn_float_ibis_file,None,IbisColumn_float)
IbisColumn_float._v_column_index = new_instancemethod(_ibis_file.IbisColumn_float__v_column_index,None,IbisColumn_float)
IbisColumn_float._v_size_byte = new_instancemethod(_ibis_file.IbisColumn_float__v_size_byte,None,IbisColumn_float)
IbisColumn_float.__str__ = new_instancemethod(_ibis_file.IbisColumn_float___str__,None,IbisColumn_float)
IbisColumn_float_swigregister = _ibis_file.IbisColumn_float_swigregister
IbisColumn_float_swigregister(IbisColumn_float)

class IbisColumn_double(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _ibis_file.IbisColumn_double_ibis_file(self)

    def _v_column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _ibis_file.IbisColumn_double__v_column_index(self)

    @property
    def column_index(self):
        return self._v_column_index()

    def _v_size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _ibis_file.IbisColumn_double__v_size_byte(self)

    @property
    def size_byte(self):
        return self._v_size_byte()

    data = _swig_property(_ibis_file.IbisColumn_double_data_get, _ibis_file.IbisColumn_double_data_set)
    update = _swig_property(_ibis_file.IbisColumn_double_update_get, _ibis_file.IbisColumn_double_update_set)
    def __getitem__(self, i):
      return self.data[i]

    def __setitem__(self, i, v):
      self.update = True
      self.data[i] = v

      
    __swig_destroy__ = _ibis_file.delete_IbisColumn_double
IbisColumn_double.ibis_file = new_instancemethod(_ibis_file.IbisColumn_double_ibis_file,None,IbisColumn_double)
IbisColumn_double._v_column_index = new_instancemethod(_ibis_file.IbisColumn_double__v_column_index,None,IbisColumn_double)
IbisColumn_double._v_size_byte = new_instancemethod(_ibis_file.IbisColumn_double__v_size_byte,None,IbisColumn_double)
IbisColumn_double.__str__ = new_instancemethod(_ibis_file.IbisColumn_double___str__,None,IbisColumn_double)
IbisColumn_double_swigregister = _ibis_file.IbisColumn_double_swigregister
IbisColumn_double_swigregister(IbisColumn_double)

class IbisColumn_string(object):
    """
    This class handles reading and writing a single column of a IBIS file.

    If you update a column and want the results to be written out, then
    you need to mark the "updated" flag as true, otherwise whatever
    changes are made won't be written to disk.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ibis_file(self):
        """
        const IbisFile& GeoCal::IbisColumnBase::ibis_file() const
        IbisFile that this column is for. 
        """
        return _ibis_file.IbisColumn_string_ibis_file(self)

    def _v_column_index(self):
        """
        int GeoCal::IbisColumnBase::column_index() const
        Column index.

        This is 0-based rather than the 1-based used by some VICAR routines.

        """
        return _ibis_file.IbisColumn_string__v_column_index(self)

    @property
    def column_index(self):
        return self._v_column_index()

    def _v_size_byte(self):
        """
        int GeoCal::IbisColumnBase::size_byte() const
        Size in bytes of column element.

        This is mostly only interesting for the VICAR_ASCII types, since the
        other types are just the size of the underlying type. 
        """
        return _ibis_file.IbisColumn_string__v_size_byte(self)

    @property
    def size_byte(self):
        return self._v_size_byte()

    data = _swig_property(_ibis_file.IbisColumn_string_data_get, _ibis_file.IbisColumn_string_data_set)
    update = _swig_property(_ibis_file.IbisColumn_string_update_get, _ibis_file.IbisColumn_string_update_set)
    def __getitem__(self, i):
      return self.data[i]

    def __setitem__(self, i, v):
      self.update = True
      self.data[i] = v

      
    __swig_destroy__ = _ibis_file.delete_IbisColumn_string
IbisColumn_string.ibis_file = new_instancemethod(_ibis_file.IbisColumn_string_ibis_file,None,IbisColumn_string)
IbisColumn_string._v_column_index = new_instancemethod(_ibis_file.IbisColumn_string__v_column_index,None,IbisColumn_string)
IbisColumn_string._v_size_byte = new_instancemethod(_ibis_file.IbisColumn_string__v_size_byte,None,IbisColumn_string)
IbisColumn_string.__str__ = new_instancemethod(_ibis_file.IbisColumn_string___str__,None,IbisColumn_string)
IbisColumn_string_swigregister = _ibis_file.IbisColumn_string_swigregister
IbisColumn_string_swigregister(IbisColumn_string)

class IbisFile(geocal_swig.generic_object.GenericObject):
    """
    This provides read and write for a IBIS file.

    IBIS is VICAR format used for tabulating raster format data -
    basically it is a table. This is used to interact with existing VICAR
    routines.

    The ASCII column type is a bit of a special case. For IBIS files, the
    ASCII column type is a fixed number of characters. We access this a
    std::string type. If you attempt to write a string that is too large
    for a column, then we silently truncate the string. Alternatively, we
    could have triggered an error in that case, but after thinking about
    it truncating seemed like the better choice. We can revisit this
    decision if it becomes clear that triggering an error would be better.

    As an implementation detail, the class VicarFile and IbisFile need to
    coordinate in translating file names to unit numbers since the same
    underlying Vicar routine zvunit is used by both. We arbitrarily have
    VicarFile handle this, and IbisFile accesses VicarFile when it needs
    to do this.

    C++ includes: ibis_file.h 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    READ = _ibis_file.IbisFile_READ
    WRITE = _ibis_file.IbisFile_WRITE
    UPDATE = _ibis_file.IbisFile_UPDATE
    VICAR_BYTE = _ibis_file.IbisFile_VICAR_BYTE
    VICAR_HALF = _ibis_file.IbisFile_VICAR_HALF
    VICAR_FULL = _ibis_file.IbisFile_VICAR_FULL
    VICAR_FLOAT = _ibis_file.IbisFile_VICAR_FLOAT
    VICAR_DOUBLE = _ibis_file.IbisFile_VICAR_DOUBLE
    VICAR_ASCII = _ibis_file.IbisFile_VICAR_ASCII
    def __init__(self, *args): 
        """
        IbisFile::IbisFile(const std::string &Fname, access_type Access=READ)
        Open given file for read or update. 
        """
        _ibis_file.IbisFile_swiginit(self,_ibis_file.new_IbisFile(*args))
    def _v_access(self):
        """
        access_type GeoCal::IbisFile::access() const
        Access type of file. 
        """
        return _ibis_file.IbisFile__v_access(self)

    @property
    def access(self):
        return self._v_access()

    def close(self):
        """
        void IbisFile::close()
        Close a file.

        You don't normally need to call this directly, it is done by the
        destructor. But it is useful to have for use by python. 
        """
        return _ibis_file.IbisFile_close(self)

    def column_data_type(self, *args):
        """
        data_type GeoCal::IbisFile::column_data_type(int I) const
        Data type for given column.

        Note that this is 0-based rather than 1-based. 
        """
        return _ibis_file.IbisFile_column_data_type(self, *args)

    def _v_file_name(self):
        """
        const std::string& GeoCal::IbisFile::file_name() const
        File name. 
        """
        return _ibis_file.IbisFile__v_file_name(self)

    @property
    def file_name(self):
        return self._v_file_name()

    def _v_ibis_fh(self):
        """
        int IbisFile::ibis_fh() const
        IBIS file handle number used in IBIS calls. 
        """
        return _ibis_file.IbisFile__v_ibis_fh(self)

    @property
    def ibis_fh(self):
        return self._v_ibis_fh()

    def _v_number_row(self):
        """
        int GeoCal::IbisFile::number_row() const
        Number of rows in the file. 
        """
        return _ibis_file.IbisFile__v_number_row(self)

    @property
    def number_row(self):
        return self._v_number_row()

    def _v_number_col(self):
        """
        int GeoCal::IbisFile::number_col() const
        Number of columns in the file. 
        """
        return _ibis_file.IbisFile__v_number_col(self)

    @property
    def number_col(self):
        return self._v_number_col()

    def _v_unit(self):
        """
        int GeoCal::IbisFile::unit() const
        Unit number for VicarFile. 
        """
        return _ibis_file.IbisFile__v_unit(self)

    @property
    def unit(self):
        return self._v_unit()

    def flush(self):
        """
        void IbisFile::flush()
        Flush data to disk, including any changes.

        This is automatically called by the destructor. 
        """
        return _ibis_file.IbisFile_flush(self)

    @classmethod
    def pickle_format_version(cls):
      return 1

    def __reduce__(self):
      return _new_from_init, (self.__class__, 1, self.file_name,self.access)

    __swig_destroy__ = _ibis_file.delete_IbisFile
IbisFile._v_access = new_instancemethod(_ibis_file.IbisFile__v_access,None,IbisFile)
IbisFile.close = new_instancemethod(_ibis_file.IbisFile_close,None,IbisFile)
IbisFile.column_data_type = new_instancemethod(_ibis_file.IbisFile_column_data_type,None,IbisFile)
IbisFile._v_file_name = new_instancemethod(_ibis_file.IbisFile__v_file_name,None,IbisFile)
IbisFile._v_ibis_fh = new_instancemethod(_ibis_file.IbisFile__v_ibis_fh,None,IbisFile)
IbisFile._v_number_row = new_instancemethod(_ibis_file.IbisFile__v_number_row,None,IbisFile)
IbisFile._v_number_col = new_instancemethod(_ibis_file.IbisFile__v_number_col,None,IbisFile)
IbisFile._v_unit = new_instancemethod(_ibis_file.IbisFile__v_unit,None,IbisFile)
IbisFile.flush = new_instancemethod(_ibis_file.IbisFile_flush,None,IbisFile)
IbisFile.__str__ = new_instancemethod(_ibis_file.IbisFile___str__,None,IbisFile)
IbisFile.column_byte = new_instancemethod(_ibis_file.IbisFile_column_byte,None,IbisFile)
IbisFile.column_half = new_instancemethod(_ibis_file.IbisFile_column_half,None,IbisFile)
IbisFile.column_full = new_instancemethod(_ibis_file.IbisFile_column_full,None,IbisFile)
IbisFile.column_float = new_instancemethod(_ibis_file.IbisFile_column_float,None,IbisFile)
IbisFile.column_double = new_instancemethod(_ibis_file.IbisFile_column_double,None,IbisFile)
IbisFile.column_string = new_instancemethod(_ibis_file.IbisFile_column_string,None,IbisFile)
IbisFile_swigregister = _ibis_file.IbisFile_swigregister
IbisFile_swigregister(IbisFile)



