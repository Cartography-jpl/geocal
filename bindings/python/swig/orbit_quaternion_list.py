# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
from ._swig_wrap import _orbit_quaternion_list

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _orbit_quaternion_list.SWIG_PyInstanceMethod_New
_swig_new_static_method = _orbit_quaternion_list.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_MODULE_ALREADY_DONE = _orbit_quaternion_list.SWIG_MODULE_ALREADY_DONE
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _orbit_quaternion_list.delete_SwigPyIterator
    value = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator_value)
    incr = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator_copy)
    next = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_orbit_quaternion_list.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _orbit_quaternion_list:
_orbit_quaternion_list.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _orbit_quaternion_list.SHARED_PTR_DISOWN

import os

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_serialization(data):
    return geocal_swig.serialize_function.serialize_read_binary(data)

def _new_from_serialization_dir(dir, data):
    curdir = os.getcwd()
    try:
      os.chdir(dir)
      return geocal_swig.serialize_function.serialize_read_binary(data)
    finally:
      os.chdir(curdir)


def _new_vector(cls, version, lst):
    '''Create a vector from a list.'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    for i in lst:
       inst.append(i)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import geocal_swig.orbit
import geocal_swig.generic_object
import geocal_swig.observer
import geocal_swig.with_parameter
import geocal_swig.look_vector
class OrbitQuaternionList(geocal_swig.orbit.Orbit):
    r"""

    This is an implementation of an Orbit that is a list of
    QuaternionOrbitData values.

    For times that fall between these values, we interpolate to get the
    OrbitData.

    Note that for some classes the calculation of the full list of
    QuaternionOrbitData might not be needed, for example an Orbit file
    covering a full day of which we are only using a subset of the data.
    To support this, we allow a lazy evaluation of the
    QuaternionOrbitData. It can initially be supplied as a null
    boost::shared_ptr, and when we encounter a null we call the function
    orbit_data_create. This function should be overriden by a derived
    class to supply the calculation of a QuaternionOrbitData for a
    particular time on demand.

    A note about AutoDerivative in the underlying Orbit. For the orbit
    creation (orbit_data_create) we use a constant time only. This is
    really just what we mean by doing a time interpolation. We select
    points at a specific, exact time - t0, t1, t2, etc. No derivatives,
    the times are exact constants. However, when we interpolate to time t
    using orbit data at t0 and t1, that is where the derivative enters in.
    So we propagate time gradients through the linear interpolation in
    orbit_data. Note that this is the time behavior of
    OrbitQuaterntionList, even if it isn’t the derivative of the
    underlying orbit. This is one differences in using a
    OrbitQuaternionList vs. some other Orbit - the time behavior is by
    design linear.

    So you should calculate your quaternions in orbit_data_create using
    AutoDerivative (if the orbit supports it and has parameters), but hold
    time constant (either don’t include as one of the gradient variables,
    or give it a gradient of zero). The OrbitQuaternionList will then
    given the correct gradients of how it behaves, even if this isn’t the
    same gradient you would have gotten from the underlying Orbit.

    C++ includes: orbit_quaternion_list.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, Data):
        r"""

        GeoCal::OrbitQuaternionList::OrbitQuaternionList(iterator ibeg, iterator iend)
        GeoCal::OrbitQuaternionList::OrbitQuaternionList
        Constructor that takes a list of QuaternionOrbitData values.
        Note that the data doesn't need to be sorted, we handle sorting as we
        ingest the data.

        QuaternionOrbitData pointer can be null if we want to do a lazy
        evaluation of the data (see description of class for details). 
        """
        _orbit_quaternion_list.OrbitQuaternionList_swiginit(self, _orbit_quaternion_list.new_OrbitQuaternionList(Data))
    orbit_data = _swig_new_instance_method(_orbit_quaternion_list.OrbitQuaternionList_orbit_data)
    _v_quaternion_orbit_data = _swig_new_instance_method(_orbit_quaternion_list.OrbitQuaternionList__v_quaternion_orbit_data)

    @property
    def quaternion_orbit_data(self):
        return self._v_quaternion_orbit_data()

    _v_quaternion_orbit_data_time = _swig_new_instance_method(_orbit_quaternion_list.OrbitQuaternionList__v_quaternion_orbit_data_time)

    @property
    def quaternion_orbit_data_time(self):
        return self._v_quaternion_orbit_data_time()

    quaternion_orbit_data_i = _swig_new_instance_method(_orbit_quaternion_list.OrbitQuaternionList_quaternion_orbit_data_i)
    _v_quaternion_orbit_data_size = _swig_new_instance_method(_orbit_quaternion_list.OrbitQuaternionList__v_quaternion_orbit_data_size)

    @property
    def quaternion_orbit_data_size(self):
        return self._v_quaternion_orbit_data_size()

    _v_set_min_time = _swig_new_instance_method(_orbit_quaternion_list.OrbitQuaternionList__v_set_min_time)
    _v_set_max_time = _swig_new_instance_method(_orbit_quaternion_list.OrbitQuaternionList__v_set_max_time)

    @property
    def min_time(self):
      return self._v_min_time()

    @min_time.setter
    def min_time(self, value):
      self._v_set_min_time(value)

    @property
    def max_time(self):
      return self._v_max_time()

    @max_time.setter
    def max_time(self, value):
      self._v_set_max_time(value)

    def quaternion_orbit_data_gen(self):
      '''Generator version of quaternion_orbit_data'''
      for i in range(self.quaternion_orbit_data_size):
          yield self.quaternion_orbit_data_i(i)

    __swig_destroy__ = _orbit_quaternion_list.delete_OrbitQuaternionList

# Register OrbitQuaternionList in _orbit_quaternion_list:
_orbit_quaternion_list.OrbitQuaternionList_swigregister(OrbitQuaternionList)
class OrbitListCache(OrbitQuaternionList):
    r"""

    Some orbits are expensive to calculate (e.g., SpicePlanetOrbit).

    Often it is perfectly fine to only calculate this at some fixed set of
    times and then interpolate, which can be significantly faster. This
    class supports this.

    C++ includes: orbit_quaternion_list.h 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, Orbit_underlying, Tt, Sample=0.0):
        r"""

        GeoCal::OrbitListCache::OrbitListCache(const boost::shared_ptr< Orbit > &Orbit_underlying, const
        boost::shared_ptr< TimeTable > &Tt, double Sample=0.0)
        GeoCal::OrbitListCache::OrbitListCache
        Create a OrbitListCache that calculates the orbit at each time found for image coordinate
        line from Tt.min_line() to tt.max_line() for the given sample.
        We cache the orbit data. If the underlying orbit changes, we throw
        away the cached values. 
        """
        _orbit_quaternion_list.OrbitListCache_swiginit(self, _orbit_quaternion_list.new_OrbitListCache(Orbit_underlying, Tt, Sample))
    _v_orbit_underlying = _swig_new_instance_method(_orbit_quaternion_list.OrbitListCache__v_orbit_underlying)

    @property
    def orbit_underlying(self):
        return self._v_orbit_underlying()

    _v_time_table = _swig_new_instance_method(_orbit_quaternion_list.OrbitListCache__v_time_table)

    @property
    def time_table(self):
        return self._v_time_table()

    _v_sample = _swig_new_instance_method(_orbit_quaternion_list.OrbitListCache__v_sample)

    @property
    def sample(self):
        return self._v_sample()


    def __reduce__(self):
    #Special handling for when we are doing boost serialization, we set
    #"this" to None
      if(self.this is None):
        return super().__reduce__()
      return _new_from_serialization, (geocal_swig.serialize_function.serialize_write_binary(self),)

    __swig_destroy__ = _orbit_quaternion_list.delete_OrbitListCache

# Register OrbitListCache in _orbit_quaternion_list:
_orbit_quaternion_list.OrbitListCache_swigregister(OrbitListCache)

__all__ = ["OrbitQuaternionList","OrbitListCache"]


